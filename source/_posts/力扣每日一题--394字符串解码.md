---
title: 力扣--394
date: 2023-11-29 17:21:21
tags: [java,'力扣']
---

## 力扣每日一题--394字符串解码

### 题目

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。<!-- more -->

**示例 1：**

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

**示例 2：**

```
输入：s = "3[a2[c]]"
输出："accaccacc"
```

**示例 3：**

```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

**示例 4：**

```
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

### 解答

首先分析，出现的数字倍数可能不只是小于10的，完全可能是成百上千的，于是对于数字需要一直遍历，才能得出对应的数字意义。

其次，可能[ ]里面还包含有[ ]，故对[ ]的结果，应当存储起来，后续可能会再用到。

最后，经过分析，采用栈解答此问题。对于数字，一直遍历出对应得数字，得到值后放入栈中。对于字母和 [ ，直接放入栈中。当遍历到 ] 时，直接将其出栈到 [ 。之后再出栈，得到对应的倍数（ [ 之后出栈的数必定是对应的倍数）。将其按照倍数进行填充，结果再次入栈。直到原字符串遍历完毕。最后遍历栈，得出最后结果。（若使用传统的栈，则最后将整个栈翻转再遍历得出最后的结果）

### 代码

```java
class Solution {
    int index;
    public String decodeString(String s) {
        //数字需要重复判断，才能确定是数字啦
        //数字和左括号直接入栈，遇见右括号的时候，出栈
        index=0;
        LinkedList<String> list=new LinkedList();//栈
        while(index<s.length())
        {
            if(Character.isDigit(s.charAt(index)))
          {
              String s1=getDigit(s);
              //list.addLast(s1);
              list.push(s1);
          }
          else if(s.charAt(index)=='['||Character.isLetter(s.charAt(index)))
          //list.addLast(s.charAt(index++)+"");
          list.push(s.charAt(index++)+"");
          else  //出栈
          {
              StringBuilder out=new StringBuilder("");
             LinkedList<String> temp=new LinkedList();
          //  while(list.peekLast()!="[")
         //  while( !"[".equals(list.peekLast()))
         while(!"[".equals(list.peek()))
           //String不是重写==了吗？不就是调用
           //好像搞反了，别人重写的是equals，，==始终就是比的地址，对象的话，歪日
           //垃圾了垃圾了
            {
                //temp.addLast(list.pop());
                temp.push(list.pop());
            }
           // list.removeLast();
           list.pop();
            int f=Integer.parseInt(list.pop());
           // Collections.reverse(temp);
            String k=toString(temp);
            for(int i=0;i<f;i++)
            out.append(k);
            //list.addLast(out.toString());
            list.push(out.toString());
            index++;
          }

        }
        Collections.reverse(list);
        return toString(list);  

    }
    public String toString(LinkedList<String> temp)
    {
      StringBuilder out=new StringBuilder("");
      for(String c:temp)
      out.append(c);
      return out.toString();
    }
    public String getDigit(String t)
    {
        StringBuilder out=new StringBuilder("");
        while(Character.isDigit(t.charAt(index)))
           out.append(t.charAt(index++));
        return out.toString();
    }
}
```

## 感悟

为什么写这道题呢？是因为自己中间犯了些小错误。也对LinkedList有了些新的认识。

### LInkedList

​		采用双向链表结构，使用效率高于ArrayList。常用于栈和队列的使用。

```java
//用作栈
push()//向list的首部插入数据，对应addFirst()方法
pop()//删除list的首部的数据，并将它返回，对应removeFirst()方法
peek()//得到list的首部数据，但是不删除它，对应peekFirst()方法
/*使用这三个函数也可以得到一个栈的操作
addLast()
removeLast()
peekLast()
*/
    
//用作队列
offer()//向list的尾部插入数据，对应addLast()方法
poll()//删除list的首部数据，并将其返回，对应removeFirst()方法
peek()//得到list的首部数据，但是不删除它，对应peekFirst()方法
/*
比较：这么一看，栈和队列的删除方法其实是一个东西对吧。不是指删除的内容是一样的，但是对应的操作都是删除list首部的元素。
ps:我之前一直以为栈的操作对应的就是addFirst()和removeFirst(),队列的操作就是addLast()和removeLast(),丢，这么一看，被自己蠢哭了。addLast()和removeLast()对应的还是栈的操作了，先进后出。
*/
    
 //用作List
add()//向list尾部插入数据
remove()//删除list尾部数据
```

建议以后使用LinkedList时，**都采用addFist(),removeLast()等这种方法操作list。而不使用push，poll()等方法**。自己决定插入和删除的位置，更加的灵活多变，也更强大。



