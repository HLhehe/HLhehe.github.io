<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>接口自动化测试---进阶</title>
    <url>/2023/12/02/2023-12-01-%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95---%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<a href="/2023/11/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80/" title="接口自动化测试---基础">接口自动化测试---基础</a>

<h2 id="接口鉴权"><a href="#接口鉴权" class="headerlink" title="接口鉴权"></a>接口鉴权</h2><p>判断当前接口是否有访问的权限。（未登录不能访问一些接口信息等）<span id="more"></span></p>
<h3 id="Cookie鉴权"><a href="#Cookie鉴权" class="headerlink" title="Cookie鉴权"></a>Cookie鉴权</h3><p>服务端在响应客户端请求的时候，会向客户端推送一个 Cookie，这个 Cookie 记录服务端上面的一些信息，客户端在后续的请求中携带这个 Cookie，服务端可以根据这个 Cookie 判断该请求的上下文关系。</p>
<p>特点：</p>
<ul>
<li><strong>Cookie存储在客户端，使得可以跨页面访问</strong>，比较方便。但可随意篡改，不安全</li>
<li>Cookie机制实现简单，只需要服务器端向客户端发送Set-Cookie即可完成鉴权，不需要过多的复杂设置。</li>
<li>它的内容会随着 http 交互传接，影响性能，所以 Cookie 可存储的数据不能过大，最大为 4kb</li>
<li>一个浏览器对于一个网站只能存不超过 20 个 Cookie，而浏览器一般只允许存放 300 个 Cookie</li>
<li>移动端对 Cookie 支持不友好</li>
<li>一般情况下存储的是纯文本，对象需要序列化之后才可以存储，解析需要反序列化</li>
</ul>
<h3 id="Session鉴权"><a href="#Session鉴权" class="headerlink" title="Session鉴权"></a>Session鉴权</h3><p>Session机制是在Cookie的基础上实现的，服务器会生成一个唯一的Session ID，并将这个ID存储在Cookie中发送给客户端。当客户端发送请求时，服务器会验证这个Session ID是否有效，如果有效，则允许访问资源。</p>
<p>特点：</p>
<ul>
<li>安全性较高：Session机制可以避免Cookie伪造带来的安全问题，对于非法用户访问也可以做出相应的控制。</li>
<li>可靠性高: <strong>服务器端存储Session数据</strong>，保证了Session数据的可靠性，避免了Cookie被篡改带来的问题。</li>
<li>维护负担大：由于Session存储在服务器端，需要服务器端定期清理过期的Session数据，从而增加了服务器的负担。</li>
<li>扩展性差：在分布式系统中，Session机制需要额外的处理来确保多台服务器之间的Session共享，从而降低了扩展性。</li>
<li>依赖 Cookie，用户可以在浏览器端禁用 Cookie</li>
<li>不支持跨端兼容 app 等</li>
</ul>
<h3 id="Token鉴权"><a href="#Token鉴权" class="headerlink" title="Token鉴权"></a>Token鉴权</h3><p>服务端不保存 sessionId。Token机制在认证成功后，服务端会签发一个令牌(Token)，以后每次请求都要带上这个Token，服务端通过校验这个Token来判断当前的请求是否合法。</p>
<p>特点：</p>
<ul>
<li>跨平台支持：Token机制不依赖于浏览器和Cookie，支持各种客户端平台，如iOS、Android等。</li>
<li>扩展性好：Token机制实现了无状态化，避免了Session的负担，更容易扩展。</li>
<li>安全性需要考虑：Token机制需要考虑密钥的安全性，如果密钥泄露，则会导致令牌被伪造，从而导致鉴权失效。</li>
<li>兼容性差：虽然Token机制可以支持跨域访问，但是它需要额外的处理来确保在不同的请求之间传递Token，从而影响了API的易用性。详情请点击<a href="/2023/12/02/token%E9%89%B4%E6%9D%83---JWT%E4%BB%A4%E7%89%8C/" title="token鉴权---JWT令牌">token鉴权---JWT令牌</a></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>登录接口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,jsonpath</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;application&quot;</span>:<span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;applicaiton_client_type&quot;</span>:<span class="string">&quot;weixin&quot;</span> </span><br><span class="line">&#125;<span class="comment">#请求参数</span></span><br><span class="line"></span><br><span class="line">data = &#123; <span class="comment">#date数据，即请求体数据，请求方式为post</span></span><br><span class="line">    <span class="string">&quot;accounts&quot;</span>:<span class="string">&quot;huace_xm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span>:<span class="number">123456</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;username&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">rs = requests.request(url=<span class="string">&quot;http://shop-xo.hctestedu.com/index.php?s=api/user/login&quot;</span>,<span class="comment">#请求路径</span></span><br><span class="line">                 method=<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                 params=params,<span class="comment">#路径参数</span></span><br><span class="line">                 data=data) <span class="comment"># 这就是发请求 ,括号里填四要素 --怎么确定接口地址？四要素是什么？</span></span><br><span class="line"><span class="comment"># print(rs.text)</span></span><br><span class="line"><span class="comment"># 拿出来做成一个变量？</span></span><br><span class="line"><span class="built_in">print</span>(rs.json())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出，登陆成功</span></span><br><span class="line"><span class="string">&#123;&#x27;msg&#x27;: &#x27;登录成功&#x27;, &#x27;code&#x27;: 0, &#x27;data&#x27;: &#123;&#x27;id&#x27;: &#x27;19898&#x27;, &#x27;username&#x27;: &#x27;huace_xm&#x27;, &#x27;nickname&#x27;: &#x27;&#x27;, &#x27;mobile&#x27;: &#x27;&#x27;, &#x27;email&#x27;: &#x27;&#x27;, &#x27;avatar&#x27;: &#x27;http://shop-xo.hctestedu.com/static/index/default/images/default-user-avatar.jpg&#x27;, &#x27;alipay_openid&#x27;: &#x27;&#x27;, &#x27;weixin_openid&#x27;: &#x27;&#x27;, &#x27;weixin_unionid&#x27;: &#x27;&#x27;, &#x27;weixin_web_openid&#x27;: &#x27;&#x27;, &#x27;baidu_openid&#x27;: &#x27;&#x27;, &#x27;toutiao_openid&#x27;: &#x27;&#x27;, &#x27;qq_openid&#x27;: &#x27;&#x27;, &#x27;qq_unionid&#x27;: &#x27;&#x27;, &#x27;integral&#x27;: &#x27;0&#x27;, &#x27;locking_integral&#x27;: &#x27;0&#x27;, &#x27;referrer&#x27;: &#x27;0&#x27;, &#x27;add_time&#x27;: &#x27;1669790543&#x27;, &#x27;add_time_text&#x27;: &#x27;2022-11-30 14:42:23&#x27;, &#x27;mobile_security&#x27;: &#x27;&#x27;, &#x27;email_security&#x27;: &#x27;&#x27;, &#x27;user_name_view&#x27;: &#x27;huace_xm&#x27;, &#x27;is_mandatory_bind_mobile&#x27;: 0, &#x27;token&#x27;: &#x27;88c06b3b23dd615cab4a0221d69ea637&#x27;&#125;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>收藏商品：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,jsonpath</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;application&quot;</span>:<span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;applicaiton_client_type&quot;</span>:<span class="string">&quot;weixin&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line">data2 = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;12&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">rs1 = requests.request(url=<span class="string">&quot;http://shop-xo.hctestedu.com/index.php?s=api/goods/favor&quot;</span>,</span><br><span class="line">                       <span class="comment">#请求路径</span></span><br><span class="line">                 method=<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                 params=params,</span><br><span class="line">                 data=data2) <span class="comment"># 这就是发请求 ,括号里填四要素 --怎么确定接口地址？四要素是什么？</span></span><br><span class="line"><span class="built_in">print</span>(rs1.json())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">&#123;&#x27;msg&#x27;: &#x27;登录失效，请重新登录&#x27;, &#x27;code&#x27;: -400, &#x27;data&#x27;: &#x27;&#x27;&#125;</span></span><br><span class="line"><span class="string">未进行接口鉴权，导致不能收藏商品</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进行接口鉴权</span></span><br><span class="line"><span class="keyword">import</span> requests,jsonpath</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;application&quot;</span>:<span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;applicaiton_client_type&quot;</span>:<span class="string">&quot;weixin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;accounts&quot;</span>:<span class="string">&quot;huace_xm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span>:<span class="number">123456</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;username&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">rs = requests.request(url=<span class="string">&quot;http://shop-xo.hctestedu.com/index.php?s=api/user/login&quot;</span>,</span><br><span class="line">                 method=<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                 params=params,</span><br><span class="line">                 data=data) <span class="comment"># 这就是发请求 ,括号里填四要素 --怎么确定接口地址？四要素是什么？</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rs.json())</span><br><span class="line"><span class="comment">#仔细观看登录成功后。返会的结果中含有token项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(rs.json()[&quot;data&quot;][&quot;token&quot;])</span></span><br><span class="line">token = rs.json()[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;token&quot;</span>]<span class="comment">#直接准确提出出token的值</span></span><br><span class="line">token1 = jsonpath.jsonpath(rs.json(),<span class="string">&quot;$..token&quot;</span>)</span><br><span class="line"><span class="comment">#不知道token的值具体在哪时，使用$..token</span></span><br><span class="line"><span class="comment">#肯定会提取出含有token的值，结果为一个列表。</span></span><br><span class="line"></span><br><span class="line">data2 = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;12&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">rs1 = requests.request(url=<span class="string">&quot;http://shop-xo.hctestedu.com/index.php?s=api/goods/favor?token=&quot;</span>+token1[<span class="number">0</span>],<span class="comment">#传入对应的token</span></span><br><span class="line">                 method=<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                 params=params,</span><br><span class="line">                 data=data2) <span class="comment"># 这就是发请求 ,括号里填四要素 --怎么确定接口地址？四要素是什么？</span></span><br><span class="line"><span class="built_in">print</span>(rs1.json())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">&#123;&#x27;msg&#x27;: &#x27;取消成功&#x27;, &#x27;code&#x27;: 0, &#x27;data&#x27;: &#123;&#x27;text&#x27;: &#x27;收藏&#x27;, &#x27;status&#x27;: 0, &#x27;count&#x27;: 49&#125;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#说明</span></span><br><span class="line"><span class="comment">#使用jsonpath需要导入对应的包，同时还需要在虚拟环境中下载安装</span></span><br><span class="line">pip install jsonpath  <span class="comment">#安装</span></span><br><span class="line">jsonpath --version   <span class="comment">#检查</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">jsonpath语法：jsonpath只能提取json对象中的参数</span></span><br><span class="line"><span class="string">$表示最外层大括号</span></span><br><span class="line"><span class="string">.表示进一层</span></span><br><span class="line"><span class="string">提取token的准确语法为：$.data.token</span></span><br><span class="line"><span class="string">模糊语法为：$..token，注意结果为列表，需要再准确取值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#并不是所有的token都是放在路径参数里面的，这个主要由前后端开发师共同决定</span></span><br><span class="line"><span class="comment">#可以放在请求头中，路径参数中，也可放在请求体中（不能是get，delect方式，没有请求体）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正则表达式提取</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">out=<span class="string">&#x27;&#x27;&#x27;&#123;&#x27;msg&#x27;: &#x27;登录成功&#x27;,</span></span><br><span class="line"><span class="string">&#x27;code&#x27;: 0, </span></span><br><span class="line"><span class="string">&#x27;data&#x27;: &#123;&#x27;id&#x27;: &#x27;19898&#x27;,  &#x27;token&#x27;: &#x27;54e66bcb250f172f92feee1440a79277&#x27;&#125;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">path=<span class="string">r&#x27;&#x27;&#x27;&#x27;token&#x27;: &#x27;(.+?)&#x27;&#125;&#125;&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(re.findall(path,out))</span><br><span class="line"><span class="comment">#将你想提取的值用(.+?)替换即可，别的直接复制粘贴</span></span><br></pre></td></tr></table></figure>


<h2 id="接口关联"><a href="#接口关联" class="headerlink" title="接口关联"></a>接口关联</h2><p>与接口鉴权类似。一个接口的参数需要使用上一个接口的一些参数。例如上一个接口生成了对应的订单 id，下个接口查询订单时需要使用到订单 id，故需要将其提取出来再传递给下个接口使用，提取方法类似上述。或者为了满足增删改查时<strong>业务闭环</strong>，执行一圈后数据库没有产生垃圾数据，也需要接口关联。</p>
<p>还是jsonpath与re的使用，即正则表达式的提取和json提取。</p>
<h2 id="接口加密"><a href="#接口加密" class="headerlink" title="接口加密"></a>接口加密</h2><p>系统明文传输的数据会被不明身份的人用抓包工具抓取，从而威胁系统和数据的<strong>安全性</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一般是对传输的数据进行加密，加密的方式有很多，具体看实际场景。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">测试时，若采用常规的方法进行加密，则可去对应的网站找取加密的密文，再传入接口中进行测试</span></span><br><span class="line"><span class="string">或者找开发要去加密的算法代码，进行调用后再传入对应的参数</span></span><br><span class="line"><span class="string">自己懂的，就自行编写对应的加密算法，加密后再传参</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>某些接口传入的数据是文件类型，再测试时需要先读出文件的信息，再将信息作为参数进行传参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span>  <span class="comment"># 上传文件接口</span></span><br><span class="line">files = &#123;</span><br><span class="line">    <span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;../file/test.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>),  <span class="comment"># 文件路径          </span></span><br><span class="line"> &#125;  <span class="comment"># =&gt; 打开上传文件并且加入文件相关参数</span></span><br><span class="line"> <span class="comment">#file是前端指定的需要传递的参数名。</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">#即先将文件读为二进制文件再进行传参</span></span><br><span class="line"><span class="comment">#传递的参数也是</span></span><br><span class="line"> <span class="comment"># data传入请求参数dict,files传入待上传文件参数dict</span></span><br><span class="line">r = requests.post(url, data=data, files=files)</span><br><span class="line"><span class="built_in">print</span>(r.json())</span><br></pre></td></tr></table></figure>

<h2 id="cookie关联"><a href="#cookie关联" class="headerlink" title="cookie关联"></a>cookie关联</h2><p>有些接口之间是存在着cookie关联的，即需要发送某些cookie信息才能进行访问该接口，类似cookie鉴权。</p>
<p>一种方式是在请求参数的时候，直接传入对应的cookie信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_login</span>(<span class="params">username,password</span>):</span><br><span class="line">    host=<span class="string">&#x27;http://localhost&#x27;</span></span><br><span class="line">    url=<span class="string">f&#x27;<span class="subst">&#123;host&#125;</span>/api/bbb/ccc&#x27;</span></span><br><span class="line">    payload=&#123;<span class="string">&#x27;username&#x27;</span>:username,</span><br><span class="line">             <span class="string">&#x27;password&#x27;</span>:password</span><br><span class="line">             &#125;</span><br><span class="line">    reps=requests.post(url,data=payload)</span><br><span class="line">    <span class="keyword">return</span> reps.cookies</span><br><span class="line"></span><br><span class="line">user_cookie= test_login(<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;12345678&#x27;</span>) <span class="comment">#调用函数获取返回值并赋值给user_cookie</span></span><br><span class="line">reps=requests.post(api_url,data=payload,cookies=user_cookie)<span class="comment">#直接在请求中加上cookies=user_cookie</span></span><br></pre></td></tr></table></figure>

<p>另一种方式是发送请求时，直接使用session的request方法。会自动关联所有请求的cookie信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先生成对应的session对象</span></span><br><span class="line">sess=requests.session();</span><br><span class="line"><span class="comment">#操作</span></span><br><span class="line"><span class="comment">#sess.request(url,param,data,**kwargs)</span></span><br><span class="line"><span class="comment">#可以使用对应的夹具函数，完成对session的初始化，同时使用单例模式，保证session的唯一性</span></span><br></pre></td></tr></table></figure>

<h2 id="总结–简单封装"><a href="#总结–简单封装" class="headerlink" title="总结–简单封装"></a>总结–简单封装</h2><h3 id="统一方法封装"><a href="#统一方法封装" class="headerlink" title="统一方法封装"></a>统一方法封装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RequestUtil</span>:</span><br><span class="line">    sess=requests.session();</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_requests</span>(<span class="params">self,**kwargs</span>):</span><br><span class="line">        res=RequestUtil.sess.request(**kwargs)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以进行统一的日志请求处理</span></span><br><span class="line"><span class="comment">#所有的请求调用的入口信息，统一的日志管理，不用在每个方法进行日志打印</span></span><br></pre></td></tr></table></figure>

<h3 id="接口关联封装"><a href="#接口关联封装" class="headerlink" title="接口关联封装"></a>接口关联封装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将提取的参数可写入yaml文件中，方便后续的使用（写入地方由自己定，看自己具体的需求）</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#写入,追加的方式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_Yaml</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.getcwd()+<span class="string">&quot;/yaml1.yaml&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>,mode=<span class="string">&quot;a+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment">#对应的yaml文件路径 ，编码格式，打开方式：追加</span></span><br><span class="line">        yaml.dump(data,stream=f,allow_unicode=<span class="literal">True</span>) <span class="comment">#写入yaml文件，写入对象为f，允许编码（不乱码）</span></span><br><span class="line"><span class="comment">#读取yaml文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_Yaml</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.getcwd()+<span class="string">&quot;/yaml1.yaml&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>,mode=<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment">#全部读取文件</span></span><br><span class="line">        value=yaml.load(f,yaml.FullLoader)</span><br><span class="line">        <span class="keyword">return</span> value[key]<span class="comment">#返回key为key的value值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#清空， 覆盖的方式</span></span><br><span class="line"><span class="comment">#在所有用例执行之前清空yaml文件</span></span><br><span class="line"><span class="comment">#夹具函数，在一次session之前，清空yaml文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear_Yaml</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.getcwd()+<span class="string">&quot;/yaml1.yaml&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>,mode=<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.truncate();<span class="comment">#清空yaml文件，防止产生废物数据</span></span><br></pre></td></tr></table></figure>

<h3 id="yaml数据驱动"><a href="#yaml数据驱动" class="headerlink" title="yaml数据驱动"></a>yaml数据驱动</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line">	<span class="attr">feature:</span> <span class="string">模块名</span></span><br><span class="line">	<span class="attr">story:</span> <span class="string">接口</span></span><br><span class="line">	<span class="attr">title:</span> <span class="string">用例标题</span></span><br><span class="line">	<span class="attr">request:</span> </span><br><span class="line">		<span class="attr">method:</span> <span class="string">请求方式</span></span><br><span class="line">		<span class="attr">url:</span> <span class="string">请求url</span></span><br><span class="line">		<span class="attr">headers:</span> <span class="string">请求头</span></span><br><span class="line">		<span class="attr">params:</span> <span class="string">请求参数</span></span><br><span class="line">		<span class="attr">json:</span> <span class="string">json参数</span></span><br><span class="line">	<span class="comment">#extract: 提取的数据</span></span><br><span class="line">	<span class="attr">vilidate:</span> <span class="string">请求断言</span>	</span><br><span class="line"><span class="comment">#需要的参数按需求自己添加	</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取yaml文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_Yaml_Testcase</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, encoding=<span class="string">&quot;utf-8&quot;</span>, mode=<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        value = yaml.load(f, yaml.FullLoader)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>接口测试</tag>
        <tag>测试</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Faker生成测试伪数据</title>
    <url>/2023/11/26/Faker/</url>
    <content><![CDATA[<h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><p>​		1）测试数据的来源</p>
<ul>
<li>人工手动编写测试数据</li>
<li>在数据库中直接插入数据<span id="more"></span></li>
<li>csv文件</li>
<li>通过wbe ui反复点击，生成对应的数据</li>
<li>利用postman、jmeter</li>
<li>随机生成</li>
</ul>
<p>​		2）问题</p>
<p>​		虽然有各种各样的方法能生成测试数据，但核心思想大都是人为设计测试数据的生成。当数据量大的时候，该工作量复杂且繁琐。且生成的数据可能失去了它对应的意义（如地址随机生成为了一串数字）。因此，faker库就出现在了人们面前（不是大魔王啊）</p>
<h3 id="Faker库"><a href="#Faker库" class="headerlink" title="Faker库"></a>Faker库</h3><p>​		1）简介</p>
<p>​		Faker是Python的一个第三方库，用于生成虚拟数据。它支持全球各地的地名、职业、性别等数据生成。Faker库的核心功能是通过强大的生成算法，随机生成真实世界中的类似数据。Faker库广泛应用于数据测试、数据清洗和数据填充等领域。</p>
<p>​		2）安装</p>
<p>​		在python对应项目的虚拟环境中执行以下命令即可（python是真的方便）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install Faker <span class="comment">#安装</span></span><br><span class="line"></span><br><span class="line">faker --version   <span class="comment">#检查</span></span><br></pre></td></tr></table></figure>

<p>​		3）使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line">fk=Faker(locale=<span class="string">&quot;zh_Cn&quot;</span>)<span class="comment">#明人不说暗话，都是中国人</span></span><br><span class="line"><span class="comment">#使用多种语言 fk=Faker(locale=[&quot;zh_Cn&quot;,&quot;zh_TW&quot;])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fk.name())  <span class="comment">#生成名字，按找设置的地区检查</span></span><br><span class="line"><span class="built_in">print</span>(fk.name_female())  <span class="comment">#生成女性名字</span></span><br><span class="line"><span class="built_in">print</span>(fk.name_male())   <span class="comment">#生成男性名字   董冬梅  这也不太像啊，哈哈哈</span></span><br><span class="line"><span class="built_in">print</span>(fk.phone_number()) <span class="comment">#生成手机号，会按照你设定的地区，自动检查格式</span></span><br><span class="line"><span class="built_in">print</span>(fk.phonenumber_prefix()) <span class="comment">#随机生成一个手机号号段  前几位</span></span><br><span class="line"><span class="built_in">print</span>(fk.ssn())  <span class="comment">#生成一个的身份ID</span></span><br><span class="line"><span class="built_in">print</span>(fk.date_of_birth())   <span class="comment">#生成一个生日日期</span></span><br><span class="line"><span class="built_in">print</span>(fk.date_of_birth(minimum_age=<span class="number">18</span>, maximum_age=<span class="number">20</span>))  <span class="comment">#生成一个生日日期(18~20岁之间)</span></span><br><span class="line"><span class="built_in">print</span>(fk.credit_card_number())  <span class="comment">#生成一个信用卡号</span></span><br><span class="line"><span class="built_in">print</span>(fk.license_plate())  <span class="comment">#生成一个车牌号</span></span><br><span class="line"><span class="built_in">print</span>(fk.bank())  <span class="comment">#生成一个银行名称</span></span><br><span class="line"><span class="built_in">print</span>(fk.email())  <span class="comment">#生成一个邮箱</span></span><br><span class="line"><span class="built_in">print</span>(fk.company())  <span class="comment">#生成一个完整的公司名称</span></span><br><span class="line"><span class="built_in">print</span>(fk.company_suffix())   <span class="comment">#生成一个公司名</span></span><br><span class="line"><span class="built_in">print</span>(fk.job())  <span class="comment">#生成一个职位名称</span></span><br></pre></td></tr></table></figure>

<p>​		4）内置的各种函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="comment"># fake = Faker([&quot;en_US&quot;, &quot;zh_CN&quot;, &quot;ja_JP&quot;])</span></span><br><span class="line">fake = Faker([<span class="string">&quot;zh_CN&quot;</span>])</span><br><span class="line"><span class="comment"># print(fake.name())</span></span><br><span class="line"><span class="comment"># print(fake[&#x27;en-US&#x27;].name())</span></span><br><span class="line"><span class="comment"># print(fake.company())</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1、使用？#自定义规则，随机生成字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.bothify())  <span class="comment"># 默认生成字符串格式： 05 RW</span></span><br><span class="line"><span class="built_in">print</span>(fake.bothify(text=<span class="string">&quot;666????####&quot;</span>, letters=<span class="string">&#x27;我们的家&#x27;</span>))  <span class="comment"># letters的字符串随机给text的？使用，##默认数字代替，格式如： 我我的我4777</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、使用^自定义规则，随机生成16进制字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.hexify(text=<span class="string">&#x27;MAC Address: ^^:^^:^^:^^:^^:^^&#x27;</span>, upper=<span class="literal">True</span>))  <span class="comment"># MAC Address: CD:18:FC:9F:B6:49</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3、随机生成 i18n 语言的代码</span></span><br><span class="line"><span class="built_in">print</span>(fake.language_code())  <span class="comment"># yo</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4、使用？自定义规则，随机生成ASCII字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.lexify(text=<span class="string">&#x27;Random Identifier: ??????????&#x27;</span>, letters=<span class="string">&#x27;我ABCDE&#x27;</span>))  <span class="comment"># Random Identifier: CBC我DD我ABE</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 5、随机生成 i18n 区域设置</span></span><br><span class="line"><span class="built_in">print</span>(fake.locale())  <span class="comment"># zh_CH</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 6、使用#！@%自定义规则，随机生成字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.numerify(text=<span class="string">&#x27;#  @!! @ %&#x27;</span>))  <span class="comment"># 1  98  7  （#=[0,9] %=[1,9] !=随机数字或空字符 @=非0数字或空字符）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 7、随机选择对象元素，并随机生成列表</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_choices(elements=(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), length=<span class="number">10</span>))  <span class="comment"># [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_choices(elements=OrderedDict([(<span class="string">&quot;a&quot;</span>, <span class="number">0.45</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">0.35</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">0.15</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">0.05</span>), ])))  <span class="comment"># [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 8、随机生成0-9整数</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_digit())  <span class="comment"># 0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 9、随机生成1-9整数</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_digit_not_null())  <span class="comment"># 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 10、随机生成0-9整数或空值</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_digit_or_empty())  <span class="comment"># &quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 11、随机选择元素，默认可重复、长度为1</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_element(elements=(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)))  <span class="comment"># a</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_element(elements=OrderedDict([(<span class="string">&quot;a&quot;</span>, <span class="number">0.45</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">0.35</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">0.15</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">0.05</span>), ])))  <span class="comment"># a</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 12、随机选择元素，默认可重复、长度不定</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_elements(elements=(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), unique=<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.random_elements(elements=OrderedDict([(<span class="string">&quot;a&quot;</span>, <span class="number">0.45</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">0.35</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">0.15</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">0.05</span>), ]), length=<span class="number">20</span>, unique=<span class="literal">False</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 13、在指定范围内，随机生成整数</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_int(<span class="built_in">min</span>=<span class="number">0</span>, <span class="built_in">max</span>=<span class="number">15</span>, step=<span class="number">3</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 14、随机生成ASCII字符串 [a-zA-Z]</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_letter())  <span class="comment"># &#x27;y&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 15、随机生成ASCII字符串列表 [a-zA-Z]</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_letters(length=<span class="number">10</span>))  <span class="comment"># [&#x27;R&#x27;, &#x27;N&#x27;, &#x27;v&#x27;, &#x27;n&#x27;, &#x27;A&#x27;, &#x27;v&#x27;, &#x27;O&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, &#x27;E&#x27;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 16、随机生成ASCII小写字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_lowercase_letter())  <span class="comment"># c</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 17、随机生成整数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果digits为None(默认值)，则取值范围为1 ~ 9之间的随机整数。</span></span><br><span class="line"><span class="string">如果fix_len为False(默认值)，则可以生成所有不超过位数的整数。</span></span><br><span class="line"><span class="string">如果fix_len为True，则只能生成具有精确位数的整数。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_number(fix_len=<span class="literal">True</span>))  <span class="comment"># 297371</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_number(digits=<span class="number">3</span>, fix_len=<span class="literal">False</span>))  <span class="comment"># 577</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 18、随机生成元素不重复的不超出元素数量的列表</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_sample(elements=(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;f&#x27;</span>), length=<span class="number">6</span>))  <span class="comment"># 元素可相同，但length不能大于6</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 19、生成大写字母的ASCII字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_uppercase_letter())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 20、随机生成接近某个数字的整数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果le为False(默认值)，则允许生成数量的140%。如果为True，则上限生成为100%。</span></span><br><span class="line"><span class="string">如果ge为False(默认值)，则允许生成数量减少到60%。如果为True，下限生成上限为100%。</span></span><br><span class="line"><span class="string">如果提供了最小值的数值，则生成的小于最小值的值将被固定在最小值。</span></span><br><span class="line"><span class="string">如果为max提供了一个数值，则生成的大于max的值将被固定在max。</span></span><br><span class="line"><span class="string">如果le和ge都为True，则number的值将自动返回，而不管提供的min和max的值是什么。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(fake.randomize_nb_elements(number=<span class="number">100</span>))  <span class="comment"># 83</span></span><br><span class="line"><span class="built_in">print</span>(fake.randomize_nb_elements(number=<span class="number">100</span>, le=<span class="literal">True</span>, ge=<span class="literal">True</span>, <span class="built_in">min</span>=<span class="number">80</span>))  <span class="comment"># 100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 21、随机生成地址和邮政编号</span></span><br><span class="line"><span class="built_in">print</span>(fake.address())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 22、随机生成门牌号</span></span><br><span class="line"><span class="built_in">print</span>(fake.building_number())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 23、随机生成城市</span></span><br><span class="line"><span class="built_in">print</span>(fake.city())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 24、随机生成特殊市</span></span><br><span class="line"><span class="built_in">print</span>(fake.city_suffix())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 25、随机生成国家</span></span><br><span class="line"><span class="built_in">print</span>(fake.country())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 26、随机生成国家编号</span></span><br><span class="line"><span class="built_in">print</span>(fake.country_code())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 27、生成当前国家</span></span><br><span class="line"><span class="built_in">print</span>(fake.current_country())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 28、生成当前国家编号</span></span><br><span class="line"><span class="built_in">print</span>(fake.current_country_code())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 29、随机生成邮编</span></span><br><span class="line"><span class="built_in">print</span>(fake.postcode())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 30、随机生成街道地址</span></span><br><span class="line"><span class="built_in">print</span>(fake.street_address())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 31、随机生成街道名称</span></span><br><span class="line"><span class="built_in">print</span>(fake.street_name())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 32、随机生成街道名称后缀</span></span><br><span class="line"><span class="built_in">print</span>(fake.street_suffix())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 33、随机生成汽车供应商牌照</span></span><br><span class="line"><span class="built_in">print</span>(fake.license_plate())  <span class="comment"># 974-XXRA</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 34、生成ABA的路由传输号</span></span><br><span class="line"><span class="built_in">print</span>(fake.aba())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 35、生成银行提供商的ISO 3166-1 alpha-2国家代码</span></span><br><span class="line"><span class="built_in">print</span>(fake.bank_country())  <span class="comment"># GB</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 36、生成基本银行帐号(BBAN)</span></span><br><span class="line"><span class="built_in">print</span>(fake.bban())  <span class="comment"># MAAN00447407504564</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 37、生成国际银行账号(IBAN)</span></span><br><span class="line"><span class="built_in">print</span>(fake.iban())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 38、生成SWIFT代码</span></span><br><span class="line"><span class="built_in">print</span>(fake.swift(length=<span class="number">11</span>, primary=<span class="literal">True</span>, use_dataset=<span class="literal">True</span>))  <span class="comment"># SVWBGBNKXXX</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 39、生成11位的SWIFT代码</span></span><br><span class="line"><span class="built_in">print</span>(fake.swift11(use_dataset=<span class="literal">True</span>))  <span class="comment"># SVWBGBNKXXX</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 40、生成8位的SWIFT代码</span></span><br><span class="line"><span class="built_in">print</span>(fake.swift8(use_dataset=<span class="literal">True</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 41、生成EAN码</span></span><br><span class="line"><span class="built_in">print</span>(fake.ean(prefixes=(<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;49&#x27;</span>), length=<span class="number">13</span>))  <span class="comment"># 4532804944052</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 42、生成EAN13码</span></span><br><span class="line"><span class="built_in">print</span>(fake.ean13(prefixes=(<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;49&#x27;</span>)))  <span class="comment"># 4518561138095</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 43、生成EAN8码</span></span><br><span class="line"><span class="built_in">print</span>(fake.ean8(prefixes=(<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;49&#x27;</span>)))  <span class="comment"># 45877841</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 44、生成指定长度的本地化EAN条码</span></span><br><span class="line"><span class="built_in">print</span>(fake.localized_ean(length=<span class="number">8</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 45、生成指定长度的本地化EAN13条码</span></span><br><span class="line"><span class="built_in">print</span>(fake.localized_ean13())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 46、生成指定长度的本地化EAN8条码</span></span><br><span class="line"><span class="built_in">print</span>(fake.localized_ean8())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 47、生成随机颜色值</span></span><br><span class="line"><span class="built_in">print</span>(fake.color(hue=<span class="string">&#x27;red&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.color(luminosity=<span class="string">&#x27;light&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.color(hue=(<span class="number">100</span>, <span class="number">200</span>), color_format=<span class="string">&#x27;rgb&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.color(hue=<span class="string">&#x27;orange&#x27;</span>, luminosity=<span class="string">&#x27;bright&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.color(hue=<span class="number">135</span>, luminosity=<span class="string">&#x27;dark&#x27;</span>, color_format=<span class="string">&#x27;hsv&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.color(hue=(<span class="number">300</span>, <span class="number">20</span>), luminosity=<span class="string">&#x27;random&#x27;</span>, color_format=<span class="string">&#x27;hsl&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 48、随机生成颜色名称</span></span><br><span class="line"><span class="built_in">print</span>(fake.color_name())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 49、生成一个十六进制三元组格式的颜色</span></span><br><span class="line"><span class="built_in">print</span>(fake.hex_color())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 50、生成一个以逗号分隔的RGB值格式的颜色</span></span><br><span class="line"><span class="built_in">print</span>(fake.rgb_color())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 51、用CSS rgb()函数生成颜色格式</span></span><br><span class="line"><span class="built_in">print</span>(fake.rgb_css_color())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 52、生成一个网络安全的颜色名称</span></span><br><span class="line"><span class="built_in">print</span>(fake.safe_color_name())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 53、生成一个网络安全的颜色格式为十六进制三重</span></span><br><span class="line"><span class="built_in">print</span>(fake.safe_hex_color())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 54、公司相关(技术\思想\名称...)</span></span><br><span class="line"><span class="built_in">print</span>(fake.bs())  <span class="comment"># leverage plug-and-play networks</span></span><br><span class="line"><span class="built_in">print</span>(fake.catch_phrase())</span><br><span class="line"><span class="built_in">print</span>(fake.company())</span><br><span class="line"><span class="built_in">print</span>(fake.company_suffix())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 55、信用卡相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.credit_card_expire())  <span class="comment"># 09/28</span></span><br><span class="line"><span class="built_in">print</span>(fake.credit_card_full())  <span class="comment"># &#x27;Discover\nKatherine Fisher\n6587647593824218 05/26\nCVC: 892\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(fake.credit_card_number())  <span class="comment"># 6504876475938248</span></span><br><span class="line"><span class="built_in">print</span>(fake.credit_card_provider())  <span class="comment"># VISA 19 digit</span></span><br><span class="line"><span class="built_in">print</span>(fake.credit_card_security_code())  <span class="comment"># 604</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 56、货币相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.cryptocurrency())</span><br><span class="line"><span class="built_in">print</span>(fake.cryptocurrency_code())</span><br><span class="line"><span class="built_in">print</span>(fake.cryptocurrency_name())</span><br><span class="line"><span class="built_in">print</span>(fake.currency())</span><br><span class="line"><span class="built_in">print</span>(fake.currency_code())</span><br><span class="line"><span class="built_in">print</span>(fake.currency_name())</span><br><span class="line"><span class="built_in">print</span>(fake.currency_symbol())</span><br><span class="line"><span class="built_in">print</span>(fake.pricetag())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 57、时间相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.am_pm())</span><br><span class="line"><span class="built_in">print</span>(fake.century())</span><br><span class="line"><span class="built_in">print</span>(fake.date())</span><br><span class="line"><span class="built_in">print</span>(fake.date_between())</span><br><span class="line"><span class="built_in">print</span>(fake.date_between_dates())</span><br><span class="line"><span class="built_in">print</span>(fake.date_object())</span><br><span class="line"><span class="built_in">print</span>(fake.date_of_birth())</span><br><span class="line"><span class="built_in">print</span>(fake.date_this_century())</span><br><span class="line"><span class="built_in">print</span>(fake.date_this_decade())</span><br><span class="line"><span class="built_in">print</span>(fake.date_this_month())</span><br><span class="line"><span class="built_in">print</span>(fake.date_this_year())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_ad())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_between())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_between_dates())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_this_century())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_this_decade())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_this_month())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_this_year())</span><br><span class="line"><span class="built_in">print</span>(fake.day_of_month())</span><br><span class="line"><span class="built_in">print</span>(fake.day_of_week())</span><br><span class="line"><span class="built_in">print</span>(fake.future_date())</span><br><span class="line"><span class="built_in">print</span>(fake.future_datetime())</span><br><span class="line"><span class="built_in">print</span>(fake.iso8601())</span><br><span class="line"><span class="built_in">print</span>(fake.month())</span><br><span class="line"><span class="built_in">print</span>(fake.month_name())</span><br><span class="line"><span class="built_in">print</span>(fake.past_date())</span><br><span class="line"><span class="built_in">print</span>(fake.past_datetime())</span><br><span class="line"><span class="built_in">print</span>(fake.pytimezone())</span><br><span class="line"><span class="built_in">print</span>(fake.time())</span><br><span class="line"><span class="built_in">print</span>(fake.time_delta())</span><br><span class="line"><span class="built_in">print</span>(fake.time_object())</span><br><span class="line"><span class="built_in">print</span>(fake.time_series())</span><br><span class="line"><span class="built_in">print</span>(fake.timezone())</span><br><span class="line"><span class="built_in">print</span>(fake.unix_time())</span><br><span class="line"><span class="built_in">print</span>(fake.year())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 58、文件相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.file_extension())</span><br><span class="line"><span class="built_in">print</span>(fake.file_extension(category=<span class="string">&#x27;image&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_name(category=<span class="string">&#x27;audio&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_name(extension=<span class="string">&#x27;abcdef&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_name(category=<span class="string">&#x27;audio&#x27;</span>, extension=<span class="string">&#x27;abcdef&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_path(depth=<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_path(depth=<span class="number">5</span>, category=<span class="string">&#x27;video&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_path(depth=<span class="number">5</span>, category=<span class="string">&#x27;video&#x27;</span>, extension=<span class="string">&#x27;abcdef&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.mime_type())</span><br><span class="line"><span class="built_in">print</span>(fake.mime_type(category=<span class="string">&#x27;application&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.unix_device())</span><br><span class="line"><span class="built_in">print</span>(fake.unix_device(prefix=<span class="string">&#x27;mmcblk&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.unix_partition())</span><br><span class="line"><span class="built_in">print</span>(fake.unix_partition(prefix=<span class="string">&#x27;mmcblk&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 59、陆地坐标数据</span></span><br><span class="line"><span class="built_in">print</span>(fake.coordinate())</span><br><span class="line"><span class="built_in">print</span>(fake.latitude())</span><br><span class="line"><span class="built_in">print</span>(fake.latlng())</span><br><span class="line"><span class="built_in">print</span>(fake.local_latlng())</span><br><span class="line"><span class="built_in">print</span>(fake.location_on_land())</span><br><span class="line"><span class="built_in">print</span>(fake.longitude())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 60、因特网相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.ascii_company_email()) <span class="comment"># 邮箱</span></span><br><span class="line"><span class="built_in">print</span>(fake.ascii_email())  <span class="comment"># ascii邮箱</span></span><br><span class="line"><span class="built_in">print</span>(fake.ascii_free_email())</span><br><span class="line"><span class="built_in">print</span>(fake.ascii_safe_email())</span><br><span class="line"><span class="built_in">print</span>(fake.company_email())  <span class="comment"># 公司邮箱</span></span><br><span class="line"><span class="built_in">print</span>(fake.dga())  <span class="comment"># 网址</span></span><br><span class="line"><span class="built_in">print</span>(fake.domain_name())  <span class="comment"># 网址</span></span><br><span class="line"><span class="built_in">print</span>(fake.domain_word())</span><br><span class="line"><span class="built_in">print</span>(fake.email())</span><br><span class="line"><span class="built_in">print</span>(fake.free_email())</span><br><span class="line"><span class="built_in">print</span>(fake.free_email_domain())</span><br><span class="line"><span class="built_in">print</span>(fake.hostname())</span><br><span class="line"><span class="built_in">print</span>(fake.http_method())  <span class="comment"># http请求方法</span></span><br><span class="line"><span class="built_in">print</span>(fake.iana_id())  <span class="comment"># IANA注册ID</span></span><br><span class="line"><span class="built_in">print</span>(fake.ipv4())  <span class="comment"># 随机ip</span></span><br><span class="line"><span class="built_in">print</span>(fake.ipv4_network_class())  <span class="comment"># 网络类别</span></span><br><span class="line"><span class="built_in">print</span>(fake.ipv4_private())</span><br><span class="line"><span class="built_in">print</span>(fake.ipv4_public())</span><br><span class="line"><span class="built_in">print</span>(fake.ipv6())</span><br><span class="line"><span class="built_in">print</span>(fake.mac_address())  <span class="comment"># mac地址</span></span><br><span class="line"><span class="built_in">print</span>(fake.nic_handle())  <span class="comment"># 网卡处理ID</span></span><br><span class="line"><span class="built_in">print</span>(fake.nic_handles())</span><br><span class="line"><span class="built_in">print</span>(fake.port_number())  <span class="comment"># 端口号</span></span><br><span class="line"><span class="built_in">print</span>(fake.ripe_id())  <span class="comment"># 组织ID</span></span><br><span class="line"><span class="built_in">print</span>(fake.safe_domain_name()) <span class="comment"># 域名</span></span><br><span class="line"><span class="built_in">print</span>(fake.safe_email())  <span class="comment"># 邮箱</span></span><br><span class="line"><span class="built_in">print</span>(fake.slug())  <span class="comment"># Django算法</span></span><br><span class="line"><span class="built_in">print</span>(fake.tld())  <span class="comment"># 域名后缀</span></span><br><span class="line"><span class="built_in">print</span>(fake.uri())  <span class="comment"># http请求路径</span></span><br><span class="line"><span class="built_in">print</span>(fake.uri_extension())</span><br><span class="line"><span class="built_in">print</span>(fake.uri_page())  <span class="comment"># 请求页面名</span></span><br><span class="line"><span class="built_in">print</span>(fake.uri_path())  <span class="comment"># 资源路径</span></span><br><span class="line"><span class="built_in">print</span>(fake.url())  <span class="comment"># url</span></span><br><span class="line"><span class="built_in">print</span>(fake.user_name())  <span class="comment"># 用户名</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 61、isbn规则相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.isbn10())</span><br><span class="line"><span class="built_in">print</span>(fake.isbn13())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 62、工作的职位名称</span></span><br><span class="line"><span class="built_in">print</span>(fake.job())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 63、文章相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.paragraph(nb_sentences=<span class="number">5</span>)) <span class="comment"># 生成段落</span></span><br><span class="line"><span class="built_in">print</span>(fake.paragraph(nb_sentences=<span class="number">5</span>, variable_nb_sentences=<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.paragraph(nb_sentences=<span class="number">5</span>, ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.paragraph(nb_sentences=<span class="number">5</span>, variable_nb_sentences=<span class="literal">False</span>, ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.paragraphs(nb=<span class="number">5</span>))  <span class="comment"># 生成段落list</span></span><br><span class="line"><span class="built_in">print</span>(fake.sentence(nb_words=<span class="number">10</span>))  <span class="comment"># 生成一个句子</span></span><br><span class="line"><span class="built_in">print</span>(fake.sentence(nb_words=<span class="number">10</span>, variable_nb_words=<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.sentences())  <span class="comment"># 生成句子list</span></span><br><span class="line"><span class="built_in">print</span>(fake.sentences(nb=<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.text(max_nb_chars=<span class="number">20</span>))  <span class="comment"># 文本字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.text(max_nb_chars=<span class="number">80</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.text(max_nb_chars=<span class="number">160</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.text(ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.texts(nb_texts=<span class="number">5</span>))  <span class="comment"># 文本字符串列表</span></span><br><span class="line"><span class="built_in">print</span>(fake.texts(nb_texts=<span class="number">5</span>, max_nb_chars=<span class="number">50</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.texts(nb_texts=<span class="number">5</span>, max_nb_chars=<span class="number">50</span>, ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.word())  <span class="comment"># 词语字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.word(ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.words())  <span class="comment"># 词语列表</span></span><br><span class="line"><span class="built_in">print</span>(fake.words(nb=<span class="number">5</span>, ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.words(nb=<span class="number">4</span>, ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>], unique=<span class="literal">True</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 数据类型相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.binary(length=<span class="number">64</span>))  <span class="comment"># 创建字节</span></span><br><span class="line"><span class="built_in">print</span>(fake.boolean(chance_of_getting_true=<span class="number">75</span>))  <span class="comment"># 布尔类型</span></span><br><span class="line"><span class="built_in">print</span>(fake.csv(header=(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Address&#x27;</span>, <span class="string">&#x27;Favorite Color&#x27;</span>), data_columns=(<span class="string">&#x27;&#123;&#123;name&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;address&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;safe_color_name&#125;&#125;&#x27;</span>), num_rows=<span class="number">10</span>, include_row_ids=<span class="literal">True</span>))  <span class="comment"># 生成随机的逗号分隔值</span></span><br><span class="line"><span class="built_in">print</span>(fake.dsv(data_columns=(<span class="string">&#x27;&#123;&#123;name&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;address&#125;&#125;&#x27;</span>), num_rows=<span class="number">5</span>, delimiter=<span class="string">&#x27;$&#x27;</span>))  <span class="comment"># 生成随机分隔符分隔值。</span></span><br><span class="line"><span class="built_in">print</span>(fake.fixed_width(data_columns=[(<span class="number">20</span>, <span class="string">&#x27;name&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;pyint&#x27;</span>, &#123;<span class="string">&#x27;min_value&#x27;</span>:<span class="number">50</span>, <span class="string">&#x27;max_value&#x27;</span>:<span class="number">100</span>&#125;)], align=<span class="string">&#x27;right&#x27;</span>, num_rows=<span class="number">2</span>))  <span class="comment"># 生成随机固定宽度值</span></span><br><span class="line"><span class="built_in">print</span>(fake.image(size=(<span class="number">16</span>, <span class="number">16</span>), hue=[<span class="number">90</span>, <span class="number">270</span>], image_format=<span class="string">&#x27;ico&#x27;</span>))  <span class="comment"># 使用Python图像库生成一张图片并在上面绘制一个随机的多边形。如果没有安装它，这个提供程序将无法运行。以给定格式返回表示图像的字节。</span></span><br><span class="line"><span class="built_in">print</span>(fake.json(data_columns=[(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>), (<span class="string">&#x27;Points&#x27;</span>, <span class="string">&#x27;pyint&#x27;</span>, &#123;<span class="string">&#x27;min_value&#x27;</span>:<span class="number">50</span>, <span class="string">&#x27;max_value&#x27;</span>:<span class="number">100</span>&#125;)], num_rows=<span class="number">1</span>))  <span class="comment"># 生成随机的JSON结构值</span></span><br><span class="line"><span class="built_in">print</span>(fake.md5(raw_output=<span class="literal">False</span>))  <span class="comment"># 生成MD5数据</span></span><br><span class="line"><span class="built_in">print</span>(fake.null_boolean())  <span class="comment"># 生成空值或布尔值</span></span><br><span class="line"><span class="built_in">print</span>(fake.password(length=<span class="number">12</span>))  <span class="comment"># 生成密码</span></span><br><span class="line"><span class="built_in">print</span>(fake.password(length=<span class="number">40</span>, special_chars=<span class="literal">False</span>, upper_case=<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.psv(header=(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Address&#x27;</span>, <span class="string">&#x27;Favorite Color&#x27;</span>), data_columns=(<span class="string">&#x27;&#123;&#123;name&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;address&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;safe_color_name&#125;&#125;&#x27;</span>), num_rows=<span class="number">10</span>, include_row_ids=<span class="literal">True</span>))  <span class="comment"># 生成随机的管道分隔值</span></span><br><span class="line"><span class="built_in">print</span>(fake.sha1(raw_output=<span class="literal">False</span>))  <span class="comment"># 生成一个随机的SHA1哈希</span></span><br><span class="line"><span class="built_in">print</span>(fake.sha256(raw_output=<span class="literal">False</span>))  <span class="comment"># 生成一个随机的SHA256哈希</span></span><br><span class="line"><span class="built_in">print</span>(fake.tar(uncompressed_size=<span class="number">256</span>, num_files=<span class="number">32</span>, min_file_size=<span class="number">4</span>, compression=<span class="string">&#x27;bz2&#x27;</span>))  <span class="comment"># 生成包含一个随机有效tar文件的字节对象。</span></span><br><span class="line"><span class="built_in">print</span>(fake.tsv(header=(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Address&#x27;</span>, <span class="string">&#x27;Favorite Color&#x27;</span>), data_columns=(<span class="string">&#x27;&#123;&#123;name&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;address&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;safe_color_name&#125;&#125;&#x27;</span>), num_rows=<span class="number">10</span>, include_row_ids=<span class="literal">True</span>))  <span class="comment"># 生成随机的制表符分隔值</span></span><br><span class="line"><span class="built_in">print</span>(fake.uuid4())  <span class="comment"># 如果使用可调用对象指定，则生成一个随机UUID4对象并将其转换为另一种类型</span></span><br><span class="line"><span class="built_in">print</span>(fake.uuid4(cast_to=<span class="literal">None</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.<span class="built_in">zip</span>(uncompressed_size=<span class="number">256</span>, num_files=<span class="number">32</span>, min_file_size=<span class="number">4</span>, compression=<span class="string">&#x27;bz2&#x27;</span>))  <span class="comment"># 生成包含一个随机有效的zip归档文件的bytes对象。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 人相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.first_name())  <span class="comment"># 人名</span></span><br><span class="line"><span class="built_in">print</span>(fake.first_name_female())  <span class="comment"># 女名</span></span><br><span class="line"><span class="built_in">print</span>(fake.first_name_male())  <span class="comment"># 男名</span></span><br><span class="line"><span class="built_in">print</span>(fake.first_name_nonbinary())</span><br><span class="line"><span class="built_in">print</span>(fake.language_name())</span><br><span class="line"><span class="built_in">print</span>(fake.last_name())</span><br><span class="line"><span class="built_in">print</span>(fake.last_name_female())</span><br><span class="line"><span class="built_in">print</span>(fake.last_name_male())</span><br><span class="line"><span class="built_in">print</span>(fake.last_name_nonbinary())</span><br><span class="line"><span class="built_in">print</span>(fake.name())</span><br><span class="line"><span class="built_in">print</span>(fake.name_female())</span><br><span class="line"><span class="built_in">print</span>(fake.name_male())</span><br><span class="line"><span class="built_in">print</span>(fake.name_nonbinary())</span><br><span class="line"><span class="built_in">print</span>(fake.prefix())</span><br><span class="line"><span class="built_in">print</span>(fake.prefix_female())</span><br><span class="line"><span class="built_in">print</span>(fake.prefix_male())</span><br><span class="line"><span class="built_in">print</span>(fake.prefix_nonbinary())</span><br><span class="line"><span class="built_in">print</span>(fake.suffix())</span><br><span class="line"><span class="built_in">print</span>(fake.suffix_female())</span><br><span class="line"><span class="built_in">print</span>(fake.suffix_male())</span><br><span class="line"><span class="built_in">print</span>(fake.suffix_nonbinary())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 电话号码相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.country_calling_code())  <span class="comment"># 区号</span></span><br><span class="line"><span class="built_in">print</span>(fake.msisdn())</span><br><span class="line"><span class="built_in">print</span>(fake.phone_number())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 个人信息相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.profile())</span><br><span class="line"><span class="built_in">print</span>(fake.simple_profile())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># python相关（python数据类型）</span></span><br><span class="line"><span class="built_in">print</span>(fake.pybool())</span><br><span class="line"><span class="built_in">print</span>(fake.pydecimal())</span><br><span class="line"><span class="built_in">print</span>(fake.pydict())</span><br><span class="line"><span class="built_in">print</span>(fake.pyfloat())</span><br><span class="line"><span class="built_in">print</span>(fake.pyint())</span><br><span class="line"><span class="built_in">print</span>(fake.pyiterable())</span><br><span class="line"><span class="built_in">print</span>(fake.pylist())</span><br><span class="line"><span class="built_in">print</span>(fake.pyset())</span><br><span class="line"><span class="built_in">print</span>(fake.pystr())</span><br><span class="line"><span class="built_in">print</span>(fake.pystr_format())</span><br><span class="line"><span class="built_in">print</span>(fake.pystruct())</span><br><span class="line"><span class="built_in">print</span>(fake.pytuple())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># ssn</span></span><br><span class="line"><span class="built_in">print</span>(fake.ssn())  <span class="comment"># 865-50-6891</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 默认用户代理相关、认证信息相关、通行证相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.android_platform_token())</span><br><span class="line"><span class="built_in">print</span>(fake.chrome())</span><br><span class="line"><span class="built_in">print</span>(fake.firefox())</span><br><span class="line"><span class="built_in">print</span>(fake.internet_explorer())</span><br><span class="line"><span class="built_in">print</span>(fake.ios_platform_token())</span><br><span class="line"><span class="built_in">print</span>(fake.linux_platform_token())</span><br><span class="line"><span class="built_in">print</span>(fake.linux_processor())</span><br><span class="line"><span class="built_in">print</span>(fake.mac_platform_token())</span><br><span class="line"><span class="built_in">print</span>(fake.mac_processor())</span><br><span class="line"><span class="built_in">print</span>(fake.opera())</span><br><span class="line"><span class="built_in">print</span>(fake.safari())</span><br><span class="line"><span class="built_in">print</span>(fake.user_agent())</span><br><span class="line"><span class="built_in">print</span>(fake.windows_platform_token())</span><br></pre></td></tr></table></figure>

<h3 id="Faker-测试"><a href="#Faker-测试" class="headerlink" title="Faker 测试"></a>Faker 测试</h3><p>​		1）faker将数据导入数据库中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql.cursors</span><br><span class="line"><span class="comment">#pip install pymysql</span></span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line">fk = Faker(locale=<span class="string">&quot;zh_CN&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQLFaker</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>://可能连接失败，放入<span class="keyword">try</span> <span class="keyword">except</span>中处理异常</span><br><span class="line">            self.db = pymysql.connect(		<span class="comment"># 连接数据库信息</span></span><br><span class="line">                host=<span class="string">&quot;**.**.**.**&quot;</span>,</span><br><span class="line">                port=<span class="number">3306</span>,</span><br><span class="line">                user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">                password=<span class="string">&quot;password&quot;</span>,</span><br><span class="line">                database=<span class="string">&quot;test&quot;</span>,</span><br><span class="line">                charset=<span class="string">&quot;utf8mb4&quot;</span>)  <span class="comment">#在mysql中，utf8默认指的是utf8mb3，即使用1-3个字节表示一个字符；正常来说utf8也就是最大使用3个字节的utf8mb3已经够用了，但是为了存储4个字节场景下的字符如emoji表情，就需要用到4个字节编码的utf8，也就是utf8mb4。其中mb4的含义为：most bytes 4，也就是最大4字节。</span></span><br><span class="line">        <span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;连接数据库失败！<span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.cursor = self.db.cursor()  	<span class="comment"># 使用cursor()方法创建一个游标对象，用于操作数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createDabate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sql = <span class="string">&quot;&quot;&quot;CREATE TABLE `employees` (  </span></span><br><span class="line"><span class="string">                    `userid` varchar(50) UNIQUE COMMENT &#x27;员工id&#x27;,</span></span><br><span class="line"><span class="string">                    `ename` VARCHAR (50) NOT NULL COMMENT &#x27;姓名&#x27;,</span></span><br><span class="line"><span class="string">                    `username` VARCHAR (20) NOT NULL COMMENT &#x27;用户名&#x27;,</span></span><br><span class="line"><span class="string">                    `password` VARCHAR (50) NOT NULL COMMENT &#x27;登录密码&#x27;,</span></span><br><span class="line"><span class="string">                    `gender` VARCHAR (50) DEFAULT &#x27;-1&#x27; COMMENT &#x27;1表示男，0表示女，-1表示未知&#x27;,</span></span><br><span class="line"><span class="string">                    `IDNum` VARCHAR (50) NOT NULL UNIQUE COMMENT &#x27;身份ID&#x27;,</span></span><br><span class="line"><span class="string">                    `phoneNum` VARCHAR (50) NOT NULL COMMENT &#x27;手机号码&#x27;,</span></span><br><span class="line"><span class="string">                    `email` VARCHAR (50) COMMENT &#x27;邮箱&#x27;,</span></span><br><span class="line"><span class="string">                    `birthday` DATE COMMENT &#x27;生日&#x27;,</span></span><br><span class="line"><span class="string">                    `createtime` DATETIME COMMENT &#x27;创建时间&#x27;</span></span><br><span class="line"><span class="string">                    ) DEFAULT CHARSET = utf8mb4 COMMENT = &#x27;员工信息表&#x27;&quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment">#多行字符串，常用于注释</span></span><br><span class="line">            <span class="comment">#写啥都行，不会报错</span></span><br><span class="line">            self.cursor.execute(sql)  			 <span class="comment"># 执行SQL语句，创建数据表</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;employees表创建成功！&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(e).split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>] == <span class="string">&quot;(1050&quot;</span>:  //提取错误码</span><br><span class="line">            //可根据对应的报错信息自己自定义</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;employees表已存在，将尝试直接插入数据！&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;创建数据表失败！<span class="subst">&#123;e&#125;</span>&#x27;</span>)  		<span class="comment"># 否则抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertFakedata</span>(<span class="params">self, num</span>):  //插入数据</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">                sql = <span class="string">&quot;&quot;&quot;INSERT INTO `employees` VALUES(&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;&quot;&quot;</span> % (  //字符串的拼接</span><br><span class="line">                    fk.uuid4(),                     <span class="comment"># 用户id</span></span><br><span class="line">                    fk.name(),                      <span class="comment"># 用户姓名</span></span><br><span class="line">                    fk.user_name(),                 <span class="comment"># 用户名</span></span><br><span class="line">                    fk.password(),                  <span class="comment"># 密码</span></span><br><span class="line">                    fk.random_int(<span class="built_in">min</span>=-<span class="number">1</span>, <span class="built_in">max</span>=<span class="number">1</span>),   <span class="comment"># 性别  //用对应的数字表示男女</span></span><br><span class="line">                    fk.ssn(),                       <span class="comment"># 身份ID</span></span><br><span class="line">                    fk.phone_number(),              <span class="comment"># 手机号码</span></span><br><span class="line">                    fk.free_email(),                <span class="comment"># 邮箱</span></span><br><span class="line">                    fk.date_of_birth(minimum_age=<span class="number">20</span>, maximum_age=<span class="number">30</span>)    <span class="comment"># 生日，20~30岁之间</span></span><br><span class="line">                    fk.date_time_between_dates()	<span class="comment"># 创建时间</span></span><br><span class="line">                )</span><br><span class="line">                self.cursor.execute(sql)	<span class="comment"># 执行SQL语句，插入数据</span></span><br><span class="line">                self.db.commit()  			<span class="comment"># 提交插入的数据，若缺少即使执行成功，数据库也不会显示数据</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;成功插入<span class="subst">&#123;num&#125;</span>条数据！&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;插入数据失败！<span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.cursor.close()  				<span class="comment"># 关闭游标对象</span></span><br><span class="line">        self.db.close()  					<span class="comment"># 关闭数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    SQLFaker().createDabate()  				<span class="comment"># 执行创建数据库</span></span><br><span class="line">    SQLFaker().insertFakedata(<span class="number">500</span>)			<span class="comment"># 执行插入500条数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		2）faker将数据导入excel中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建test4.py</span></span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> Font, PatternFill</span><br><span class="line"><span class="keyword">from</span> openpyxl.utils <span class="keyword">import</span> get_column_letter</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles.alignment <span class="keyword">import</span> Alignment</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles.borders <span class="keyword">import</span> Border, Side</span><br><span class="line"></span><br><span class="line">fk = Faker(<span class="string">&quot;zh_CN&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_to_excel</span>():</span><br><span class="line">    wb = load_workbook(<span class="string">&quot;E:/Fakerdata.xlsx&quot;</span>)  	<span class="comment"># 打开Excel文件</span></span><br><span class="line">    sheet = wb[wb.sheetnames[<span class="number">0</span>]]  				<span class="comment"># 选择表1</span></span><br><span class="line">    <span class="comment"># 随机生成1000条数据，同时设置单元格样式</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(excel_header)):</span><br><span class="line">            <span class="built_in">id</span> = fk.random_number(digits=<span class="number">5</span>)  <span class="comment"># 随机生成5位数</span></span><br><span class="line">            name = fk.name()  				 <span class="comment"># 随机生成姓名</span></span><br><span class="line">            ssn = fk.ssn()  				 <span class="comment"># 随机生成身份ID</span></span><br><span class="line">            phone = fk.phone_number()  		 <span class="comment"># 随机生成手机号</span></span><br><span class="line">            email = fk.email()  			 <span class="comment"># 随机生成邮箱</span></span><br><span class="line">            company = fk.company()  		 <span class="comment"># 随机生成公司名称</span></span><br><span class="line">            status = fk.words(ext_word_list=[<span class="string">&quot;在职&quot;</span>, <span class="string">&quot;已离职&quot;</span>], nb=<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># 在指定两个字中随机选择一个</span></span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">1</span>, value=<span class="built_in">id</span>)</span><br><span class="line">            <span class="comment">#第几行，第几列，对应的值</span></span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">2</span>, value=name)</span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">3</span>, value=ssn)</span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">4</span>, value=phone)</span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">5</span>, value=email)</span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">6</span>, value=company)</span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">7</span>, value=status)</span><br><span class="line">    wb.save(<span class="string">&quot;E:/Fakerdata.xlsx&quot;</span>)  <span class="comment"># 保存Excel文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    save_to_excel()</span><br><span class="line"><span class="comment">#可优先设置好格式信息，直接插入数据即可</span></span><br></pre></td></tr></table></figure>

<p>​		3）faker作数据驱动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将数据先封装成对应的列表list，然后使用装饰器传入即可</span></span><br><span class="line"><span class="comment">#或者直接将对应的值改成faker生成的数据</span></span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line">out=[]</span><br><span class="line">faker=Faker(locale=<span class="string">&quot;zh_Cn&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">list</span>=[]</span><br><span class="line">    <span class="built_in">list</span>.append(faker.name())</span><br><span class="line">    <span class="built_in">list</span>.append(faker.random_int(<span class="built_in">min</span>=<span class="number">0</span>,<span class="built_in">max</span>=<span class="number">100</span>))</span><br><span class="line">    out.append(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestDDT</span>:</span><br><span class="line"><span class="meta">    @pytest.mark.parametrize(<span class="params"><span class="string">&#x27;name,age&#x27;</span>,out</span>) //数据驱动</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testFaker</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="built_in">print</span>(name,age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>测试</tag>
        <tag>faker</tag>
        <tag>测试数据</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest单元测试框架（基础篇）</title>
    <url>/2023/11/21/pytest%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h2><p>​		1）什么是单元测试框架</p>
<p>​		单元测试框架是指在软件开发的过程种，针对软件的最小单位（函数、方法）进行正确性测试</p>
<span id="more"></span>

<p>​		2）常见的单元测试框架</p>
<p>​		基于java的：junit和testng</p>
<p>​		基于python的：unittest和<strong>pytest</strong></p>
<p>​		3）单元测试流程</p>
<p>​		1.测试发现：从多个文件中找到需要被测试的测试用例</p>
<p>​		2.测试执行：按照一定的顺序执行测试用例，并生成结果</p>
<p>​		3.测试判断：通过assert断言来自动判断结果与预期是否相符</p>
<p>​		4.测试报告：生成这次测试的测试报告，包括耗时、通过率等</p>
<h2 id="pytest"><a href="#pytest" class="headerlink" title="pytest"></a>pytest</h2><p>​		1）简介</p>
<p>​		pytest是python的一种单元测试框架，与python自带的测试框架unittest类似，但比其更易上手，也更加的灵活。因此使用面也广于unittest。</p>
<ul>
<li><p>pytest比unittest更加成熟，同时支持unittest编写的测试用例</p>
</li>
<li><p>pytest可以和selenium，request，appium等测试框架相结合，实现web ui自动化，web 接口自动化，app ui自动化</p>
</li>
<li><p>pytest可以实现测试用例的跳过以及失败用例重试</p>
</li>
<li><p>pytest支持参数化数据驱动方式</p>
</li>
<li><p>pytest可以和Jenkins持续集成</p>
</li>
<li><p>pytest具有很多第三方插件，且支持自定义扩展</p>
<ul>
<li><p>pytest：单元测试框架</p>
<p>pytest-xdist： 测试用例的分布式执行，即并发执行。可缩短总的用例的执行时间</p>
<p>pytest-ordering： 可以指定测试用例的执行顺序，默认是从上到下依次执行</p>
<p>pytest-rerunfailures： 用例失败后进行再次执行（多用于ui测试）</p>
<p>pytest-html： 生成html格式的测试报告（不够美观）</p>
<p>allure-pytest： 生成比上面美观的测试报告，且可进行测试报告的自定义</p>
</li>
</ul>
</li>
</ul>
<p>​		2）安装</p>
<p>​		新建python项目———在本地虚拟终端中执行以下命令即可。（注意：使用以上插件也需要安装到本地环境中，语法类似）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pytest   <span class="comment">#安装命令</span></span><br><span class="line"></span><br><span class="line">pytest --version     <span class="comment">#检查命令</span></span><br></pre></td></tr></table></figure>

<p>​		3）使用pytest</p>
<p>​		pytest的默认测试用例发现规则</p>
<ul>
<li><p>模块名（简单理解为一个py文件）以test_ 开头或 _test结尾</p>
</li>
<li><p>测试类以Test开头，并且不包含init()方法</p>
</li>
<li><p>测试方法以test开头</p>
<p>4）运行pytest</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">TestName</span>():</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">testName</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;hello,pytest&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     pytest.main()</span><br></pre></td></tr></table></figure>

<h2 id="pytest运行方式"><a href="#pytest运行方式" class="headerlink" title="pytest运行方式"></a>pytest运行方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参数详解:</span><br><span class="line">-s:输出调试信心，包括<span class="built_in">print</span>打印的信息</span><br><span class="line">-v:显示更详细的信息</span><br><span class="line">-vs:两个连用，效用就是两个相加</span><br><span class="line">-n NUM: 支持多线程或分布式运行测试用例，使用NUM个线程。需要导入pytest-xdist插件</span><br><span class="line">--<span class="built_in">return</span> NUM:失败用例重跑NUM次，失败用例总共运行NUM+1次</span><br><span class="line">-x:有一个用例失败报错，则停止测试，默认是不停止测试</span><br><span class="line">--maxfail=NUM:出现NUM个失败用例就停止测试</span><br><span class="line">-k String:根据String字符串匹配对应的测试用例</span><br><span class="line">--html 文件路径/文件名：生成html格式的测试报告</span><br></pre></td></tr></table></figure>

<p>​		1）主函数方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件夹与python package的区别：python package下包含一个_init_.py文件</span></span><br><span class="line"><span class="comment"># ./  :表示当前文件路径下</span></span><br><span class="line"><span class="comment"># ../  :表示当前文件路径的父路径，即向上一层</span></span><br><span class="line">pytest.main()    <span class="comment">#运行所有的按条件写的测试用例</span></span><br><span class="line">pytest.main(<span class="string">&#x27;-vs&#x27;</span>,<span class="string">&#x27;./tasecase&#x27;</span>)   <span class="comment">#运行tasecase文件夹下的测试用例</span></span><br><span class="line">pytest.main(<span class="string">&#x27;-x&#x27;</span>,<span class="string">&#x27;test01.py&#x27;</span>)    <span class="comment">#运行test01模块下的测试用例,且出现错误就停止测试</span></span><br><span class="line">pytest.mian(<span class="string">&#x27;-n 2&#x27;</span>,<span class="string">&#x27;./tesecase/test01.py::TestName::testName&#x27;</span>)   <span class="comment">#运行testcase文件夹下test01模块里TsetName类里的testName方法,且使用两个线程</span></span><br></pre></td></tr></table></figure>

<p>​		2）命令行模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#即在安装pytest的本地虚拟环境中运行</span></span><br><span class="line">pytest     <span class="comment">#运行所有满足条件的测试用例</span></span><br><span class="line">pytest -vs ./testcase   <span class="comment">#运行tasecase文件夹下的测试用例</span></span><br><span class="line">pytest -x ./testcase/test01.py    <span class="comment">#运行test01模块下的测试用例,且出现错误就停止测试</span></span><br><span class="line">pytest -n 2 ./tesecase/test01.py::TestName::testName    <span class="comment">#运行testcase文件夹下test01模块里TsetName类里的testName方法,且使用两个线程</span></span><br></pre></td></tr></table></figure>

<p>​		3）全局配置模式</p>
<p>​		通过读取pytest.ini文件得到对应的配置信息，最后在命令行输入pytest即可运行（名字不可变，只能为pytest.ini）</p>
<ul>
<li>文件位置：放在项目的根目录，即最外层即可</li>
<li>编码格式：必须为ANSI格式，可使用notpad++修改格式</li>
<li>运行规则：不论是主函数方式还是命令行方式，都会优先读取该配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#模板，前面的参数是不可变的，后面根据实际情况填写</span></span><br><span class="line"></span><br><span class="line">[<span class="string">pytest</span>]</span><br><span class="line"><span class="string">addopts</span> <span class="string">=</span> <span class="string">-vs</span> <span class="comment">#命令行的参数，用空格分隔</span></span><br><span class="line"><span class="string">testpaths</span> <span class="string">=</span> <span class="string">./testcase</span> <span class="comment">#测试用例的路径</span></span><br><span class="line"><span class="string">python_files</span> <span class="string">=</span> <span class="string">test_*.py</span> <span class="comment">#模块名的规则，可以更改默认规则</span></span><br><span class="line"><span class="string">python_classes</span> <span class="string">=</span> <span class="string">Test*</span> <span class="comment">#类名的规则</span></span><br><span class="line"><span class="string">python_functions</span> <span class="string">=</span> <span class="string">test</span> <span class="comment">#方法名的规则</span></span><br><span class="line"><span class="string">markers</span> <span class="string">=</span></span><br><span class="line">  <span class="string">smoke:冒烟用例</span>          <span class="comment">#设置独有的标记</span></span><br><span class="line">  <span class="string">usermanage:用户管理模块</span></span><br><span class="line">  <span class="string">productmanage:商品管理模块</span></span><br></pre></td></tr></table></figure>

<p>​		4）改变执行顺序</p>
<p>​		pytest默认的执行顺序是从上到下，改变默认执行顺序，使用mark标记。（需要引入pytest-ordering插件）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestName</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello,pytest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">99</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAge</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myage&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">100</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAddr</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myaddr&quot;</span>)</span><br><span class="line">        </span><br><span class="line">   <span class="comment">#优先执行带注释的用例，且order值越小，优先执行</span></span><br></pre></td></tr></table></figure>

<p>​		5）分组执行</p>
<p>​		在实际的测试场景中，需要对一类的用例进行优先测试，如，冒烟测试、用户管理模块测试、商品管理模块测试等。（还记得上面pytest.ini文件中得makers标记吗？就是用来自定自己的分组的）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.somke</span></span><br><span class="line"><span class="comment">#在对应的方法上添加注解即可</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行</span></span><br><span class="line">pytest -m <span class="string">&quot;smoke&quot;</span> <span class="comment">#执行smoke模块测试用例</span></span><br><span class="line">pytest -m <span class="string">&quot;smoke or usermanage or productmanage&quot;</span>  <span class="comment">#执行这三个模块的测试用例</span></span><br></pre></td></tr></table></figure>

<p>​		6）跳过测试用例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestName</span>():</span><br><span class="line"></span><br><span class="line">    age=<span class="number">18</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello,pytest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">99</span></span>)</span></span><br><span class="line"><span class="meta">    @pytest.mark.skipif(<span class="params">age&gt;<span class="number">18</span>,reason=<span class="string">&quot;年龄已经大于18，不用测啦&quot;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAge</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myage&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.skip(<span class="params">reas=<span class="string">&quot;不想测试这个啦&quot;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAddr</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myaddr&quot;</span>)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  输出</span></span><br><span class="line"><span class="string">testcase/test_01.py::TestName::testAge myage PASSED testcase/test_01.py::TestName::testName hello,pytest PASSED testcase/test_01.py::TestName::testAddr SKIPPED (不想测试这个啦)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 当age=19时，输出</span></span><br><span class="line"><span class="string">testcase/test_01.py::TestName::testAge SKIPPED (年龄已经大于18，不用测啦) testcase/test_01.py::TestName::testName hello,pytest PASSED testcase/test_01.py::TestName::testAddr SKIPPED (不想测试这个啦)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<a href="/2023/11/27/pytest%E8%BF%9B%E9%98%B6/" title="pytest单元测试框架（进阶篇）">pytest单元测试框架（进阶篇）</a>





]]></content>
      <tags>
        <tag>测试</tag>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>Fidder抓包</title>
    <url>/2023/11/28/Fidder/</url>
    <content><![CDATA[<h3 id="Fidder"><a href="#Fidder" class="headerlink" title="Fidder"></a>Fidder</h3><p>Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一 。 它能够记录客户端和服务器之间的所有 HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据<span id="more"></span></p>
<p>注意：使用Fiddler的话，需要先设置浏览器的代理地址，才可以抓取到浏览器的数据包。<strong>而很方便的是在你启动该工具后，它就已经自动帮你设置好了浏览器的代理了</strong>，当关闭后，它又将浏览器代理还原了。当然如果发现没有自动设置浏览器代理的话，那就得自己动手去浏览器进行设置代理操作了。（可自行百度每个浏览器是如何设置代理的）</p>
<h3 id="Fidder设置"><a href="#Fidder设置" class="headerlink" title="Fidder设置"></a>Fidder设置</h3><h4 id="https设置"><a href="#https设置" class="headerlink" title="https设置"></a>https设置</h4><p>首先点击Tools—&gt;Options,之后在出现的页面选择HTTSPS，将其全部勾选。如下图所示。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128144508010.png" alt="image-20231128144508010" style="zoom: 67%;" />

<p>之后，浏览器访问<a href="http://localhost:8888，点击download">http://localhost:8888，点击download</a> the FidderRoot certificate，安装对应证书。之后打开下载的内容，一直next即可。再次进入上图页面，点击Actions，选择reset all certificate，，先删除所有证书，再安装你下载的证书（按照提示来即可）点击yes，点击是，之后ok关闭即可。完成上述步骤就可以进行https请求的抓取了。</p>
<h4 id="远程连接设置"><a href="#远程连接设置" class="headerlink" title="远程连接设置"></a>远程连接设置</h4><p>首先点击Tools—&gt;Options,然后点击Connections，勾选Allow remote computers to connect即可。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128150943183.png" alt="image-20231128150943183" style="zoom: 67%;" />

<p>同时，此界面还可以更改fidder的默认端口8888。</p>
<h3 id="Fidder请求"><a href="#Fidder请求" class="headerlink" title="Fidder请求"></a>Fidder请求</h3><p>1）各图标含义</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128151748732.png" alt="image-20231128151748732" style="zoom:67%;" />

<p>2）工具栏</p>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128152053892.png" alt="image-20231128152053892"></p>
<p>从左到右表示的意义分别是：</p>
<ul>
<li>WinConfig：windows 使用了一种叫做“AppContainer”的隔离技术，使得一些流量无法正常捕获，在 fiddler中点击 WinConfig 按钮可以解除这个诅咒，这个与菜单栏 Tools→Win8 Loopback Exemptions 功能是一致的</li>
<li>气泡：给请求添加备注说明。选中一条请求，点击气泡，即可添加对应的备注说明</li>
<li>Replay：对请求进行回放。选择一条请求，点击replay，即再次发送该请求</li>
<li>X：删除某些请求会话，可下拉选择。常用remove all</li>
<li>Go：debug断点调试时，继续执行该请求</li>
<li>Stream：流模式，实时通信模式，有请求就有返回。一般用不到</li>
<li>Decode：将请求的东西解压出来，方便查阅</li>
<li>Keep all Sessions：保存所有会话。注意，保存越多，占用内存越大。fidder默认保存所有，可下拉选择更改</li>
<li>Any Process：过滤请求。将其按住拖到edge浏览器上即可屏蔽该浏览器发出的请求。只能屏蔽对应的进程，应用发出的会话请求</li>
<li>Find：查找会话，使用黄色标记该会话。</li>
<li>Save：保存选择的会话。保存为 .saz文件</li>
<li>照相机&#x2F;截图：保存截图，5秒后将截图保存下来</li>
<li>计时器：左击开始计时，再左击停止。右击清0</li>
<li>Browse：快速启动浏览器，可下拉选择</li>
<li>Clear cache：清除缓存</li>
<li>TextWizard：编&#x2F;解码字符串</li>
<li>Tearoff：将请求和响应单独独立为一个新窗口，方便查看</li>
<li>MSDN：搜索功能</li>
<li>？：fidder在线帮助网站</li>
</ul>
<p>3）选项卡</p>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128154847828.png" alt="image-20231128154847828"></p>
<p>下面将只介绍一些常用的选项卡。</p>
<h4 id="Inspectors"><a href="#Inspectors" class="headerlink" title="Inspectors"></a>Inspectors</h4><p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128155446293.png" alt="image-20231128155446293"></p>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128155505246.png" alt="image-20231128155505246"></p>
<p>包含请求和响应的一些信息。主要是对这些信息的多种格式展示。主要查看请求头，响应头重要信息。</p>
<h4 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h4><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128155952719.png" alt="image-20231128155952719" style="zoom:67%;" />

<p>设置完成后，点击Actions执行定义的过滤规则。</p>
<p>1）Hosts过滤</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">No Zone Filter：不设置过滤；指定只显示内网（Intranet）或互联网（Internet）的内容(不常用)</span><br><span class="line">Show only Intranet Hosts：指定只显示内网（Intranet）的内容</span><br><span class="line">Show only Internet Hosts：指定只显示互联网（Internet）的内容</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No Host Filter：不过滤</span><br><span class="line">Hide the following Hosts ： 隐藏文本框中的相关主机请求</span><br><span class="line">Show only the following Hosts ：显示文本框中相关的主机请求（多个用分号分开）</span><br><span class="line">Flag the following Hosts ：标记（高亮）显示文本框中的主机请求</span><br></pre></td></tr></table></figure>

<p>2）Client Process过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Show only traffic from：你可以指定只捕获哪个Windows进程中的请求；</span><br><span class="line">Show only Internet Explorer traffic：只显示IE发出的请求；</span><br><span class="line">Hide traffic from Service Host：隐藏来自Host发出的请求；</span><br></pre></td></tr></table></figure>

<p>3）RequestHeader过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show only if URL contains: 只显示URL包含的，多个时空格分开</span><br><span class="line">Hide if URL contains: 隐藏URL包含的，多个时空格分开</span><br><span class="line">Flag requests with headers: 加粗显示HTTP请求头包含指定的HTTP请求头的类型名称</span><br><span class="line">Delete request headers: 删除HTTP请求头包含指定的HTTP请求头的类型名称</span><br><span class="line">Set request header : 创建一个指定名称和值的HTTP请求头,或更新HTTP请求头为指定值。</span><br><span class="line">Break request on POST: POST请求设置断点</span><br><span class="line">Break request on GET with query string: GET方法且URL中包含查询条件的请求设置断点（URL中包含参数params）</span><br><span class="line">Break on XMLHttpRequest: 通过 XMLHttpRequest对象发送的请求设置断点。通过查找请求头中是否含有X-Request-With 和X-Download-Initiator</span><br><span class="line">Break response on Content-Type: 响应头Content-Type 中包含了指定的文本设置断点</span><br></pre></td></tr></table></figure>

<p>5）Response Status Code过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hide success(2XX): 隐藏状态码在200至299的响应</span><br><span class="line">Hide non-2xx: 隐藏非200至299的响应</span><br><span class="line">Hide Authentication demands(401,407): 隐藏状态码为401,407的响应.需要用户进一步确认证书的请求</span><br><span class="line">Hide redirects(300,301,302,303,307): 藏状态码为300,301,302,303,307重定向的响应</span><br><span class="line">Hide Not Modified(304):藏状态码为304的响应.缓存实体有效返回304</span><br></pre></td></tr></table></figure>

<p>6）Response Type and Size过滤</p>
<p>7）Response Headers过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flag responses that set cookies: 粗体显示和响应头包含Set-Cookie的响应</span><br><span class="line">Flag responses with headers: 粗体显示指定HTTP响应头。同Flag requests with headers</span><br><span class="line">Delete responses headers: 删除特定的HTTP响应头。只是从响应头中删除，不删除session</span><br><span class="line">Set response header；创建更新响应头。同Set Request header 用法一样</span><br></pre></td></tr></table></figure>

<h4 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h4><p>Composer选项卡支持手动构建和发请求；也可以在session列表中拖拽Session放到Composer中，会直接把该session的请求复制到用户界面；</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128163002061.png" alt="image-20231128163002061" style="zoom:67%;" />

<p>上面填写对应的请求路径，请求头信息等。下面填写请求体中对应的内容。即请求的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	Options标签：</span><br><span class="line">Inspect Session: 执行请求后，会自动打开Inspectors选项卡；</span><br><span class="line">Fix Content-Length header:控制Composer是否会自动添加或修改Content-Length请求头，表示请求体的大小；</span><br><span class="line">Follow Redirects:是否会自动使用响应的Location头；</span><br><span class="line">Automatically Authenticate: 是否会自动响应服务器的认证需求；</span><br><span class="line">Tear off 按钮：使Composer选项卡以独立的窗口悬浮；</span><br></pre></td></tr></table></figure>

<h3 id="Fidder应用"><a href="#Fidder应用" class="headerlink" title="Fidder应用"></a>Fidder应用</h3><h4 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h4><p>根据对应的请求头，响应头信息，判断是前端错误还是后端错误。若请求有问题，则前端错误，若响应的数据有问题，则后端服务错误，若响应数据没问题，则前端渲染错误。（同时还要结合数据库数据进行判断）</p>
<h4 id="Mock测试—查看页面布局"><a href="#Mock测试—查看页面布局" class="headerlink" title="Mock测试—查看页面布局"></a>Mock测试—查看页面布局</h4><p><strong>断点改数据：</strong></p>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128170848085.png" alt="image-20231128170848085"></p>
<p>点击第一下是请求前断点，可以修改对应的请求数据；点击第二下是响应后断点，可以修改对应的响应数据，点击第三下是取消断点。断点设置之后点击Run to completion执行断点后的操作，观察结果。</p>
<p><strong>改数据库：</strong>优点，可以同时测多种环境下页面显示问题，如web页面，app页面，h5等。缺点：信息千人前面，每个人的推荐信息是不同的。</p>
<p><strong>mock测试：</strong>先save对应的响应体数据，然后修改保存。后点击AutoResponder选项卡，拖动对应请求到其中，而后选择find a file替换响应结果，而后再次发送该请求去查看结果即可。如下图所示</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128165733545.png" alt="image-20231128165733545" style="zoom:67%;" />

<h4 id="弱网测试"><a href="#弱网测试" class="headerlink" title="弱网测试"></a>弱网测试</h4><p>Rules-&gt;Performance -&gt; Simulate Modem Speeds</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128172259066.png" alt="image-20231128172259066" style="zoom:67%;" />

<p>同时，可以点击Rules—&gt;Cutomize Rules，即</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128172415152.png" alt="image-20231128172415152" style="zoom:67%;" />

<p>进去弱网设置代码里，找到m_SimulateModem，修改oSession[“request-trickle-delay”] &#x3D; “300”;（表示上传1kb需要300ms）和oSession[“response-trickle-delay”] &#x3D; “150”;，自定义弱网的网络条件。</p>
<h4 id="app抓包"><a href="#app抓包" class="headerlink" title="app抓包"></a>app抓包</h4><p>首先打开fidder的远程连接，见上。其次，进行手机上的设置，保证手机网络和fidder所在电脑网络处于同一局域网下。然后设置手机的代理网络为fidder的服务地址。</p>
<p>此外，手机上也需要下载安装fidder安全证书。访问http:&#x2F;&#x2F;电脑IP:8888，一路下载安装，按照提示干就完了。（不要干坏事哇）</p>
]]></content>
      <tags>
        <tag>测试</tag>
        <tag>抓包</tag>
        <tag>Fidder</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest单元测试框架（进阶篇）</title>
    <url>/2023/11/27/pytest%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<a href="/2023/11/21/pytest%E5%9F%BA%E7%A1%80/" title="pytest单元测试框架（基础篇）">pytest单元测试框架（基础篇）</a>

<h2 id="测试夹具"><a href="#测试夹具" class="headerlink" title="测试夹具"></a>测试夹具</h2><p>​		1）什么是夹具？</p>
<p>​		在自动化测试过程中，为测试用例提前准备的一个运行环境，这个测试环境被称为测试夹具。测试夹具的本质是一个函数，在测试用例方法执行之前的称为前置条件，测试用例方法执行之后的称为后置条件。</p>
<span id="more"></span>

<p>​		2）为什么需要夹具</p>
<p>​		比如在进行web ui测试时，需要打开浏览器（前置条件），关闭浏览器（后置条件）；比如在进行接口自动化测试时，接口关联的参数值写入yaml文件，测试之前需要清空yaml文件（前置条件）；比如测试时需要记录日志，日志对象的生成（前置条件），日志对象的销毁（后置条件）。</p>
<p>​		2）常用的pytest夹具</p>
<ul>
<li>setup&#x2F;teardown，setup_class&#x2F;teardown_class</li>
<li>@pytest.fixture()</li>
<li>conftest.py和@pytest.fixture()结合</li>
</ul>
<h3 id="setup-teardown，setup-class-teardown-class"><a href="#setup-teardown，setup-class-teardown-class" class="headerlink" title="setup&#x2F;teardown，setup_class&#x2F;teardown_class"></a>setup&#x2F;teardown，setup_class&#x2F;teardown_class</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestName</span>():</span><br><span class="line"></span><br><span class="line">    age=<span class="number">19</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello,pytest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">99</span></span>)</span></span><br><span class="line">   <span class="comment"># @pytest.mark.skipif(age&gt;18,reason=&quot;年龄已经大于18，不用测啦&quot;)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAge</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myage&quot;</span>)</span><br><span class="line">        </span><br><span class="line">   <span class="comment"># @pytest.mark.skip(reason=&quot;不想测试这个啦&quot;)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAddr</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myaddr&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始进行测试用例---作用范围为单个方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;测试用例结束---作用范围单个方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup_class</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始进行测试用例，对TestName类&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown_class</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;结束对TestName类的测试&quot;</span>)</span><br><span class="line">        </span><br><span class="line">  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">testcase/test_01.py:: TestName : :testAge开始进行测试用例，对TestName类</span></span><br><span class="line"><span class="string">开始进行测试用例---作用范围为单个方法</span></span><br><span class="line"><span class="string">myage</span></span><br><span class="line"><span class="string">PASSED测试用例结束---作用范围单个方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">testcase/test_01.py : :TestName : :testName 开始进行测试用例---作用范围为单个方法</span></span><br><span class="line"><span class="string">hello , pytest</span></span><br><span class="line"><span class="string">PASSED测试用例结束---作用范围单个方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">testcase/test_01.py : :TestName : :testAddr开始进行测试用例---作用范围为单个方法</span></span><br><span class="line"><span class="string">myaddr</span></span><br><span class="line"><span class="string">PASSED测试用例结束---作用范围单个方法</span></span><br><span class="line"><span class="string">结束对TestName类的测试</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#不建议使用此方法，抛出了警告信息（已过时），且此方法针对所有的测试用例都必须执行该方法，不能选择一部分执行。</span></span><br><span class="line"><span class="comment">#@pytest.fixture()装饰器模式可以对部分方法的前后置方法</span></span><br></pre></td></tr></table></figure>

<h3 id="pytest-fixture"><a href="#pytest-fixture" class="headerlink" title="@pytest.fixture()"></a>@pytest.fixture()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上代码</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&#x27;function&#x27;</span>, params=[<span class="string">&#x27;成龙&#x27;</span>, <span class="string">&#x27;甄子丹&#x27;</span>, <span class="string">&#x27;菜10&#x27;</span>]</span>)</span></span><br><span class="line"><span class="comment">#这参数有什么作用呢？引出后面的数据驱动DDT</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_fixture</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;前置函数&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> request.param</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;后置函数&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestPytest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_Pytest</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test01&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_02</span>(<span class="params">self,my_fixture</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test02&quot;</span>)</span><br><span class="line">        <span class="comment">#print(my_fixture)  //返回成龙，甄子丹，菜10</span></span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;&quot;&quot;输出</span></span><br><span class="line"><span class="string">test_Pytest.py::TestPytest::test_Pytest test01 PASSED test_Pytest.py::TestPytest::test_02[成龙] 前置函数</span></span><br><span class="line"><span class="string">test02 PASSED后置函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test_Pytest.py::TestPytest::test_02[甄子丹] 前置函数</span></span><br><span class="line"><span class="string">test02 PASSED后置函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test_Pytest.py::TestPytest::test_02[菜10] 前置函数</span></span><br><span class="line"><span class="string">test02 PASSED后置函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;&quot;</span>,params=<span class="string">&quot;&quot;</span>,autouse=<span class="string">&quot;&quot;</span>,ids=<span class="string">&quot;&quot;</span>,name=<span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(1)scope表示的是被@pytest.fixture标记的方法的作用域。function(默认)，class，module，package/session.</span></span><br><span class="line"><span class="string">		session 会话级别：每个session只运行一次，session级别的fixture需要定义到conftest.py中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		module 模块级别：模块里所有的用例执行前执行一次module级别的fixture，即单个py文件执行一次模块级别</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		class 类级别 ：每个类执行前都会执行一次class级别的fixture</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		function ：此模式是默认的模式，函数级别的，每个测试用例执行前都会执行一次function级别的fixture</span></span><br><span class="line"><span class="string">(2)params：参数化（支持，列表[]，元祖()，字典列表[&#123;&#125;,&#123;&#125;,&#123;&#125;]，字典元祖(&#123;&#125;,&#123;&#125;,&#123;&#125;)，循环执行，每次取下一个</span></span><br><span class="line"><span class="string">(3)autouse=True：自动使用，默认False</span></span><br><span class="line"><span class="string">(4)ids：当使用params参数化时，给每一个值设置一个变量名。意义不大。</span></span><br><span class="line"><span class="string">(5)name：给表示的是被@pytest.fixture标记的方法取一个别名。意义不大</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">yield前面是前置函数，yield后面是后置函数，且yield能将后面的结果return给对应的用例函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">问题：使用时，每个类或者模块里都需要定义对应的函数，才能被调用执行。代码复用性不强</span></span><br><span class="line"><span class="string">如何在一个地方定义夹具函数，所有的用例函数都能调用到呢？</span></span><br><span class="line"><span class="string">有请我们的conftest.py文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="conftest-py结合-pytest-fixture"><a href="#conftest-py结合-pytest-fixture" class="headerlink" title="conftest.py结合@pytest.fixture()"></a>conftest.py结合@pytest.fixture()</h3><p>​		通过使用conftest.py文件和@pytest.fixture结合，实现全局的夹具配置</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">conftest.py文件是单独存放的一个夹具配置文件，名称是不能更改。</span></span><br><span class="line"><span class="string">可以在不同的py文件中使用同一个fixture函数。</span></span><br><span class="line"><span class="string">原则上conftest.py需要和运行的用例放到统一层(一般放在根目录下即可）。并且不需要做任何的imprt导入的操作。</span></span><br><span class="line"><span class="string">写法与@pytest.fiuture无异，只不过将定义的函数都放在conftest.py文件中</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>setup&#x2F;teardown，setup_class&#x2F;teardown_class 它是作用于所有用例或者所有的类 </p>
<p>@pytest.fixtrue() 它的作用是既可以部分也可以全部前后置。 </p>
<p>conftest.py和@pytest.fixtrue()结合使用，作用于全局的前后置。</p>
<h2 id="allure报告"><a href="#allure报告" class="headerlink" title="allure报告"></a>allure报告</h2><p>​		1）下载</p>
<p>​		<a href="https://github.com/allure-framework/allure2/releases">Releases · allure-framework&#x2F;allure2 (github.com)</a></p>
<p>​		2）配置bin</p>
<p>​		找到安装的allure文件夹的bin路径，将其加入path中即可。</p>
<p>​		3）使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pytest [测试文件] --alluredir=./result <span class="comment">#--alluredir用于指定存储测试结果的路径</span></span><br><span class="line">allure serve ./result  <span class="comment">#生成页面报告</span></span><br></pre></td></tr></table></figure>

<h2 id="数据驱动DDT"><a href="#数据驱动DDT" class="headerlink" title="数据驱动DDT"></a>数据驱动DDT</h2><p>​		DDT即data-driver test，数据驱动测试。 以数据来驱动整个测试用例的执行（即测试数据决定测试结果）,核心使用@pytest.mark.parametrize</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test_Demo</span>():</span><br><span class="line">    <span class="comment">#前面可以为String，list，元组，逗号分隔</span></span><br><span class="line">    <span class="comment"># @pytest.mark.parametrize(&quot;a, b, result&quot;, [(1, 1, 2), (2, 8, 10)])</span></span><br><span class="line">    <span class="comment"># @pytest.mark.parametrize((&quot;a, b, result&quot;), data)</span></span><br><span class="line"><span class="meta">    @pytest.mark.parametrize(<span class="params">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;result&quot;</span>],yaml.safe_load(<span class="params"><span class="built_in">open</span>(<span class="params"><span class="string">&quot;./data.yaml&quot;</span></span>)</span>)</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_case1</span>(<span class="params">self, a, b, result</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n开始执行测试用例1&quot;</span>)</span><br><span class="line">        <span class="keyword">assert</span> a + b == result</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>测试</tag>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>token鉴权---JWT令牌</title>
    <url>/2023/12/02/token%E9%89%B4%E6%9D%83---JWT%E4%BB%A4%E7%89%8C/</url>
    <content><![CDATA[<h2 id="token鉴权"><a href="#token鉴权" class="headerlink" title="token鉴权"></a>token鉴权</h2><p>Token也称为动态密钥，是在加入频道时用于校验用户权限的一组字符串；鉴权是指在用户访问你的系统前，对其进行身份校验。用户在使用声网服务，如加入通话或登录信令系统时，声网会使用 Token 对其鉴权<span id="more"></span></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>客户端向服务端发送用户名和密码等凭据，请求访问某个资源。</li>
<li>服务端收到凭据后，进行身份验证，验证通过后生成一个Token。</li>
<li>服务端将生成的Token返回给客户端。</li>
<li>客户端在之后的每个请求中都携带这个Token。</li>
<li>服务端接收到请求后，从请求中获取Token。</li>
<li>服务端对Token进行验证，验证通过后允许客户端访问相应资源。</li>
</ol>
<h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p><strong>在 Cookie中存储 Token</strong><br>将 Token 存储到 Cookie中，是一种常见的方式。相较于其他方式，这种方式<strong>比较简单，易于实现</strong>。通常情况下， 服务器将Token作为响应的一部分发送给客户端浏览器，浏览器接收到响应之后，将其存储到Cookie中，并在后续的请求中自动将其发送给服务器端。Token 存储在Cookie中的好处是，<strong>这样可以使 Token 跨越不同的页面和路径，同时也可以让 Token 的过期时间变得更加灵活</strong>。但是，使用 Cookie 和 Token 会<strong>带来相应的安全问题</strong>。由于Token是明文存储在浏览器中， 因此可以通过 XSS 攻击或者窃取浏览器中的Cookie等方式直接获取Handle。因此，如果使用 Cookie 存储 Token，则需要谨慎对待。</p>
<p><strong>在 localStorage 中存储 Token</strong><br>相较于 Cookie，localStorage 本身就是一种用于存储数据的方案。 将 Token 存储到 localStorage 中的好处是，<strong>使其更加稳定，即使浏览器被关闭也不会丢失，同时也不会被传入请求中。</strong>使用 localStorage 存储数据的优点是：通过JavaScript编写，使用简单方便，<strong>需要在客户端进行存储，也减少了服务器的压力</strong>，同时也<strong>保证了数据的安全性。</strong>不过需要注意的是，虽然localStorage是将数据保存在浏览器中，但也需要注意浏览器的兼容性问题。</p>
<p><strong>在 sessionStorage 中存储 Token</strong><br>sessionStorage是一种基于键值对存储的机制。将Token存储到sessionStorage中与localStorage类似，都将数据<strong>存储在浏览器中</strong>。它的<strong>存储时间只在一个会话期内有效；如果客户关闭了浏览器或者打开了一个新的浏览器窗口，则会话期将结束，数据也将被删除，避免了因为Token漏洞导致的信息泄露问题。</strong></p>
<p><strong>在服务器端进行存储</strong><br>将Token存储在服务器端，则可以<strong>实现更高的安全性</strong>，因为所有的数据都存储在服务器端，即使数据泄露，攻击者也无法直接访问数据。但是，这种方法也有一定的缺点，<strong>因为将数据存储在服务器上会增加服务器的负载和存储成本，同时也会影响Token的访问速度。</strong></p>
<p><strong>在数据库中存储 Token</strong><br>将Token存储在数据库中的好处是，可以通过对数据库进行<strong>相应的加密措施，来实现更高的数据安全性</strong>。同时，还可以借助<strong>数据库的备份和恢复功能，提供更好的数据可用性，使服务器不会因Token认证中断而崩溃</strong>。</p>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>Token的传递方式通常有以下四种：</p>
<ul>
<li>HTTP header：Token以HTTP header的形式传递，可以避免安全风险。</li>
<li>查询参数：Token以查询参数的形式传递，存在安全风险。</li>
<li>请求体：Token以请求体的形式传递，可以避免安全风险。</li>
<li>HTTPS协议：HTTPS协议会使用SSL进行身份验证和数据传输加密，避免了Token传递中的安全风险。</li>
</ul>
<p>为了避免Token泄漏和被盗用，需要选择最安全的传递方式，并在传递过程中对Token进行加密传输。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><strong>支持跨域访问</strong>：cookie 是不支持跨域的，而 Token 可以放在请求头中传输</li>
<li><strong>无状态</strong>：Token 自身包含了用户登录的信息，无需在服务器端存储 session</li>
<li><strong>移动端支持更好</strong>：当客户端不是浏览器时，cookie 不被支持，采用 Token 无疑更好</li>
<li><strong>无需考虑 CRSF</strong>：不使用 cookie，也就无需考虑 CRSF 的防御</li>
</ul>
<hr>
<ul>
<li><strong>占带宽</strong>：正常情况下要比 session_id 更大，需要消耗更多流量，挤占更多带宽，假如你的网站每月有 10 万次的浏览器，就意味着要多开销几十兆的流量。听起来并不多，但日积月累也是不小一笔开销。实际上，许多人会在 JWT 中存储的信息会更多。</li>
<li>无法在服务端注销，那么就很难解决劫持问题</li>
<li><strong>安全性</strong>：Token中保存了用户的身份验证信息，如果Token被获取，那么持有者就可以使用Token来访问受保护的资源。因此，在Token的传输、存储以及使用过程中需要注意安全问题。</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>常见的Token分为基于session的token和基于jwt令牌的Token。基于session的token类似于session id。下面重点讲述jwt令牌。</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT（JSON Web Token）是一种用于在网络应用间传递信息的开放标准（RFC 7519）。它以 JSON 格式存储被加密后的信息，通常用于验证和身份认证。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>JWT令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz</p>
<ol>
<li>Header</li>
</ol>
<p>头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#例如</span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Payload</li>
</ol>
<p>第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的现成字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。大多存放用户的账号信息，只存储账号，不存储密码。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#例如 </span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;荷包蛋&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> HL</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Signature</li>
</ol>
<p>此部分用于防止jwt内容被篡改。这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明签名算法进行签名。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + &quot;.&quot; +           #第一部分</span><br><span class="line">base64UrlEncode(payload),                 #第二部分</span><br><span class="line">secret)                                   #使用的签名密钥</span><br></pre></td></tr></table></figure>

<h3 id="jwt-生成"><a href="#jwt-生成" class="headerlink" title="jwt 生成"></a>jwt 生成</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入maven依赖   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTcreat</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECRET</span> <span class="operator">=</span> <span class="string">&quot;3113390285&quot;</span>;<span class="comment">//使用的密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRATION_TIME</span> <span class="operator">=</span> <span class="number">3600000</span>;<span class="comment">//秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJwtToken</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        claims.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;荷包蛋HL&quot;</span>);</span><br><span class="line">        claims.put(<span class="string">&quot;root&quot;</span>,<span class="string">&quot;HL&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expirationDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(timeMillis + EXPIRATION_TIME);</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setClaims(claims)<span class="comment">//设置数据</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())<span class="comment">//创建时间</span></span><br><span class="line">                .setExpiration(expirationDate)<span class="comment">//过期时间</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, SECRET)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println( JWTcreat.createJwtToken());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//eyJhbGciOiJIUzUxMiJ9.eyJyb290IjoiSEwiLCJuYW1lIjoi6I235YyF6JuLSEwiLCJleHAiOjE3MDE1MTY2MzIsImlhdCI6MTcwMTUxMzAzMn0.1jRKb3cyoQTcdUdHJpJ7i7payam1H039_e6dSJvwekJTwphZXO45nfRvqb-HmsURB5rbgxVKQ8RfDcGF-hk9Gw</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Jwts.builder()                                      创建一个 JwtBuilder 对象</li>
<li>JwtBuilder.setClaims()                      设置 JWT 的声明（claims）</li>
<li>JwtBuilder.setIssuer()                       设置 JWT 的发行者（issuer）</li>
<li>JwtBuilder.setSubject()                     设置 JWT 的主题（subject）</li>
<li>JwtBuilder.setAudience()                 设置 JWT 的受众（audience）</li>
<li>JwtBuilder.setIssuedAt()                   设置 JWT 的签发时间（issuedAt）</li>
<li>JwtBuilder.setExpiration()                设置 JWT 的过期时间（expiration）</li>
<li>JwtBuilder.signWith()                        设置 JWT 的签名算法和密钥</li>
<li>JwtBuilder.compact()                        生成 JWT 字符串</li>
<li>compact()                                           用于将 JWT 编码为紧凑的字符串形式。即将 JWT 编码为没有空格、没有等号、没有加号、没有斜杠的紧凑字符串形式，以便在 URL 中传输</li>
</ul>
<h3 id="jwt解析"><a href="#jwt解析" class="headerlink" title="jwt解析"></a>jwt解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">               .setSigningKey(SECRET)<span class="comment">//上面设置的密钥</span></span><br><span class="line">               .parseClaimsJws(token)</span><br><span class="line">               .getBody();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Jwts.parser()                            创建一个 JwtParser 对象</li>
<li>JwtParser.setSigningKey()     设置 JWT 的签名密钥</li>
<li>JwtParser.parseClaimsJws()  解析 JWT 字符串并返回一个 Claims 对象，包含了 JWT 中所有的声明（claims）</li>
<li>getBody():                                用于从 JWT 中获取载荷（payload）信息。调用此方法将返回一个 Claims 对象，其中包含了 JWT 载荷中的所有声明信息，可以通过 get 方法获取对应的声明值</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signWith 方法接受两个参数，分别是签名算法和密钥</span><br><span class="line">签名算法的类型必须要和 JWT 头部中的 “alg” 字段一致，否则验证时会提示签名无效,因此，在使用JWT进行签名时，必须要明确指定签名算法</span><br><span class="line">签名算法是由 SignatureAlgorithm 枚举类提供的，它定义了一系列的签名算法，包括 HMAC 和 RSA</span><br><span class="line"></span><br><span class="line">在 signWith 方法中: 如果为对称算法，则密钥应该是一个 byte[] 数组或 String 类型的字符串;</span><br><span class="line">如果为非对称算法，则密钥应该是一个 Key 类型的对象，例如 RSAPrivateKey 或 RSAPublicKey</span><br><span class="line"></span><br><span class="line">SignatureAlgorithm.HS512 算法，属于 HMAC-SHA512 对称加密算法</span><br><span class="line">SignatureAlgorithm.HS256 算法，属于 HMAC-SHA256 对称加密算法</span><br><span class="line">SignatureAlgorithm.RS256 算法，属于 RSA-SHA256 非对称加密算法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CSRF全称为Cross Site Request Forgery，跨域请求伪造。这是一种很常见的Web攻击方式，如下为一个简单的攻击流程。</span><br><span class="line">1）用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</span><br><span class="line">2）在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</span><br><span class="line">3）用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</span><br><span class="line">4）网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</span><br><span class="line">5）浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>开发</tag>
        <tag>java</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣--394</title>
    <url>/2023/11/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98--394%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="力扣每日一题–394字符串解码"><a href="#力扣每日一题–394字符串解码" class="headerlink" title="力扣每日一题–394字符串解码"></a>力扣每日一题–394字符串解码</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。<span id="more"></span></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>首先分析，出现的数字倍数可能不只是小于10的，完全可能是成百上千的，于是对于数字需要一直遍历，才能得出对应的数字意义。</p>
<p>其次，可能[ ]里面还包含有[ ]，故对[ ]的结果，应当存储起来，后续可能会再用到。</p>
<p>最后，经过分析，采用栈解答此问题。对于数字，一直遍历出对应得数字，得到值后放入栈中。对于字母和 [ ，直接放入栈中。当遍历到 ] 时，直接将其出栈到 [ 。之后再出栈，得到对应的倍数（ [ 之后出栈的数必定是对应的倍数）。将其按照倍数进行填充，结果再次入栈。直到原字符串遍历完毕。最后遍历栈，得出最后结果。（若使用传统的栈，则最后将整个栈翻转再遍历得出最后的结果）</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//数字需要重复判断，才能确定是数字啦</span></span><br><span class="line">        <span class="comment">//数字和左括号直接入栈，遇见右括号的时候，出栈</span></span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">LinkedList</span>();<span class="comment">//栈</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(index)))</span><br><span class="line">          &#123;</span><br><span class="line">              String s1=getDigit(s);</span><br><span class="line">              <span class="comment">//list.addLast(s1);</span></span><br><span class="line">              list.push(s1);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(index)==<span class="string">&#x27;[&#x27;</span>||Character.isLetter(s.charAt(index)))</span><br><span class="line">          <span class="comment">//list.addLast(s.charAt(index++)+&quot;&quot;);</span></span><br><span class="line">          list.push(s.charAt(index++)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">else</span>  <span class="comment">//出栈</span></span><br><span class="line">          &#123;</span><br><span class="line">              StringBuilder out=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">             LinkedList&lt;String&gt; temp=<span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">          <span class="comment">//  while(list.peekLast()!=&quot;[&quot;)</span></span><br><span class="line">         <span class="comment">//  while( !&quot;[&quot;.equals(list.peekLast()))</span></span><br><span class="line">         <span class="keyword">while</span>(!<span class="string">&quot;[&quot;</span>.equals(list.peek()))</span><br><span class="line">           <span class="comment">//String不是重写==了吗？不就是调用</span></span><br><span class="line">           <span class="comment">//好像搞反了，别人重写的是equals，，==始终就是比的地址，对象的话，歪日</span></span><br><span class="line">           <span class="comment">//垃圾了垃圾了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//temp.addLast(list.pop());</span></span><br><span class="line">                temp.push(list.pop());</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// list.removeLast();</span></span><br><span class="line">           list.pop();</span><br><span class="line">            <span class="type">int</span> f=Integer.parseInt(list.pop());</span><br><span class="line">           <span class="comment">// Collections.reverse(temp);</span></span><br><span class="line">            String k=toString(temp);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;f;i++)</span><br><span class="line">            out.append(k);</span><br><span class="line">            <span class="comment">//list.addLast(out.toString());</span></span><br><span class="line">            list.push(out.toString());</span><br><span class="line">            index++;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> toString(list);  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">(LinkedList&lt;String&gt; temp)</span></span><br><span class="line">    &#123;</span><br><span class="line">      StringBuilder out=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(String c:temp)</span><br><span class="line">      out.append(c);</span><br><span class="line">      <span class="keyword">return</span> out.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDigit</span><span class="params">(String t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder out=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(Character.isDigit(t.charAt(index)))</span><br><span class="line">           out.append(t.charAt(index++));</span><br><span class="line">        <span class="keyword">return</span> out.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>为什么写这道题呢？是因为自己中间犯了些小错误。也对LinkedList有了些新的认识。</p>
<h3 id="LInkedList"><a href="#LInkedList" class="headerlink" title="LInkedList"></a>LInkedList</h3><p>​		采用双向链表结构，使用效率高于ArrayList。常用于栈和队列的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用作栈</span></span><br><span class="line">push()<span class="comment">//向list的首部插入数据，对应addFirst()方法</span></span><br><span class="line">pop()<span class="comment">//删除list的首部的数据，并将它返回，对应removeFirst()方法</span></span><br><span class="line">peek()<span class="comment">//得到list的首部数据，但是不删除它，对应peekFirst()方法</span></span><br><span class="line"><span class="comment">/*使用这三个函数也可以得到一个栈的操作</span></span><br><span class="line"><span class="comment">addLast()</span></span><br><span class="line"><span class="comment">removeLast()</span></span><br><span class="line"><span class="comment">peekLast()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//用作队列</span></span><br><span class="line">offer()<span class="comment">//向list的尾部插入数据，对应addLast()方法</span></span><br><span class="line">poll()<span class="comment">//删除list的首部数据，并将其返回，对应removeFirst()方法</span></span><br><span class="line">peek()<span class="comment">//得到list的首部数据，但是不删除它，对应peekFirst()方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比较：这么一看，栈和队列的删除方法其实是一个东西对吧。不是指删除的内容是一样的，但是对应的操作都是删除list首部的元素。</span></span><br><span class="line"><span class="comment">ps:我之前一直以为栈的操作对应的就是addFirst()和removeFirst(),队列的操作就是addLast()和removeLast(),丢，这么一看，被自己蠢哭了。addLast()和removeLast()对应的还是栈的操作了，先进后出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">//用作List</span></span><br><span class="line">add()<span class="comment">//向list尾部插入数据</span></span><br><span class="line">remove()<span class="comment">//删除list尾部数据</span></span><br></pre></td></tr></table></figure>

<p>建议以后使用LinkedList时，<strong>都采用addFist(),removeLast()等这种方法操作list。而不使用push，poll()等方法</strong>。自己决定插入和删除的位置，更加的灵活多变，也更强大。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>性能测试</title>
    <url>/2023/11/20/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="为什么进行性能测试"><a href="#为什么进行性能测试" class="headerlink" title="为什么进行性能测试"></a>为什么进行性能测试</h3><p>​		满足真实的业务场景（活动场景），支持大量的用户，满足商用需求。</p>
<span id="more"></span>

<h3 id="什么是性能"><a href="#什么是性能" class="headerlink" title="什么是性能"></a>什么是性能</h3><p>​		软件质量属性中的”效率“体现，指时特性与资源特性</p>
<h3 id="什么是性能测试"><a href="#什么是性能测试" class="headerlink" title="什么是性能测试"></a>什么是性能测试</h3><p>​		使用<strong>自动化工具</strong>，模拟不同的场景，对软件各项性能指标进行测试和评估的过程。（ps:网络也是性能评估的一部分，且只能由工具测试，不能像功能测试一样手动执行）</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ol>
<li>评估当前系统的能力</li>
<li>寻找性能瓶颈，优化性能</li>
<li>评估软件是否能满足未来的需要</li>
</ol>
<h3 id="功能测试与性能测试"><a href="#功能测试与性能测试" class="headerlink" title="功能测试与性能测试"></a>功能测试与性能测试</h3><p>​		功能测试：验证软件系统操作功能是否符合产品功能需求规格，主要聚焦在功能（正向、逆向）；</p>
<p>​		性能测试：验证软件系统是否满足业务需求场景，主要聚焦业务场景的满足（时间、资源）；</p>
<p>​		一般项目中，先通过功能测试，后进行性能测试。</p>
<h2 id="性能测试策略"><a href="#性能测试策略" class="headerlink" title="性能测试策略"></a>性能测试策略</h2><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>​		狭义：<strong>单用户测试</strong>。测试环境确定后，对业务中的重要业务做单独的测试，获取单用户运行的各项性能指标。（不是指单次测试）</p>
<p>​		广义：在某时刻建立一个已知性能的性能基准线，当<strong>系统软硬件环境</strong>发生变化之后再进行一次基准测试以确定变化对性能的影响。（类似控制变量法）</p>
<p>​		作用：基准测试不会单独存在，为多用户并发测试和综合测试场景提供参考依据，且为系统环境配置，优化前后的性能变化提供参考。</p>
<h3 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h3><p>​		通过<strong>逐步增加系统负载</strong>，确定在<strong>满足系统的性能指标</strong>（如响应时间等）的情况下，找出系统所能承受的<strong>最大负载量</strong>的测试。一般时长为1—2小时。</p>
<p>​		作用：找出系统的最大负载量（也可得到极限负载量），当最大负载量达到需求时，系统才能上线使用。</p>
<h3 id="稳定性测试"><a href="#稳定性测试" class="headerlink" title="稳定性测试"></a>稳定性测试</h3><p>​		在应用程序<strong>稳定运行</strong>（用户在正常的业务负载下）的情况下进行<strong>长时间测试</strong>（1天—1周），保证<strong>系统长时间稳定运行</strong>。</p>
<p>​		作用：系统在用户要求的业务负载下运行达到相应的时间，才能正式上线使用。</p>
<p>​		注意：只有用户在<strong>正常的业务负载</strong>下才能进行稳定性测试，若用户要求的负载量<strong>大于系统最大负载量</strong>，不能进行稳定性测试。应当进行负载测试，找出性能瓶颈，提升系统最大负载量后再进行稳定性测试。</p>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>​		在<strong>强负载下</strong>的测试，查看系统在<strong>峰值情况</strong>下是否具有<strong>功能隐患</strong>，是否具有良好的<strong>容错能力与可恢复能力</strong>。常用的测试场景有：极限负载情况下导致系统崩溃的<strong>破坏性压力测试</strong>和高负载下的长时间<strong>稳定性压力测试</strong>。</p>
<p>​		注意：破坏性压力测试的负载量为系统的<strong>极限负载量</strong>，即系统即将崩溃。稳定性压力测试的负载量应当<strong>大于系统的最大负载量，小于系统的极限负载量</strong>。</p>
<h3 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h3><p>​		并发测试（绝对并发）：指在<strong>极短的时间</strong>内，发送<strong>多个请求</strong>，验证系统对<strong>并发</strong>的处理能力。与负载测试（相对并发）相区别。特定活动场景如：抢红包、双11秒杀等。</p>
<h2 id="性能测试指标"><a href="#性能测试指标" class="headerlink" title="性能测试指标"></a>性能测试指标</h2><p>​		一些经过运算得出的结果，来量化衡量某种操作的性能好坏；如：响应时间（RT）。</p>
<h3 id="响应时间（RT）"><a href="#响应时间（RT）" class="headerlink" title="响应时间（RT）"></a>响应时间（RT）</h3><p>​		指用户从客户端发起一个请求开始，到客户端接收到从服务器端返回的结果，整个过程耗费的时间。即<strong>服务器的处理时间</strong>加<strong>请求&#x2F;结果的网络传输时间</strong>。</p>
<p>​		注意：不包括发消息时前端页面的处理时间和收到消息后前端页面的渲染显示时间。</p>
<h3 id="并发（用户）数"><a href="#并发（用户）数" class="headerlink" title="并发（用户）数"></a>并发（用户）数</h3><p>​		某一时刻<strong>同时</strong>向服务器<strong>发起请求</strong>的用户数（请求数）。</p>
<h3 id="吞吐量（Throughput"><a href="#吞吐量（Throughput" class="headerlink" title="吞吐量（Throughput)"></a>吞吐量（Throughput)</h3><p>​		指<strong>单位时间内</strong>处理客户端请求的数量，<strong>直接</strong>体现系统的性能承载能力。</p>
<p>​		QPS：Query Per Second。<strong>每秒查询数</strong>，即服务器每秒处理的指定请求（查询请求）的数量。</p>
<p>​		TPS：Transactions Per Second。<strong>每秒事务数</strong>，即服务器每秒处理的事务请求的数量。 事务：即对应的一次业务操作，可能包含多个请求。一般由测试人员定义事务的大小。当一个事务对应一个请求时，TPS&#x3D;QPS。</p>
<h3 id="点击数"><a href="#点击数" class="headerlink" title="点击数"></a>点击数</h3><p>​		指客户端向服务端发送请求时，<strong>所有的页面资源元素</strong>（图片，链接，css，js等）的请求总量。</p>
<p>​		注意：只有web项目才有此指标；且点击数不是页面上的一次点击，而是这次点击所发出的总的请求数。</p>
<h3 id="错误率"><a href="#错误率" class="headerlink" title="错误率"></a>错误率</h3><p>​		指系统在<strong>负载情况</strong>下，失败业务的概率。即错误率&#x3D;（失败业务&#x2F;业务总数）*100%。大多数系统都会要求错误率无限接近于0；错误率是一个性能指标，不是功能上的随机bug。先解决随机功能bug才能进行性能测试。</p>
<p>​		注意：只有在负载情况下的失败才是性能上的问题，才能统计错误率，否则只能是功能上的随机bug。</p>
<p>​		例如，一个用户发起10次请求，成功8次，错误2次，这只能说明出现了随机功能bug。因为没有具体的负载业务场景。</p>
<h3 id="资源使用率"><a href="#资源使用率" class="headerlink" title="资源使用率"></a>资源使用率</h3><p>​		系统各种资源的使用情况，<strong>一般</strong>资源使用率&#x3D;（资源使用量&#x2F;资源总量）*100%。对于cpu与内存，指代的是使用的cpu与内存的百分比；而对于磁盘IO与网络，指的是读取写入速度的百分比与网络传输速度的百分比。</p>
<h2 id="性能测试的流程"><a href="#性能测试的流程" class="headerlink" title="性能测试的流程"></a>性能测试的流程</h2><h3 id="性能测试需求分析"><a href="#性能测试需求分析" class="headerlink" title="性能测试需求分析"></a>性能测试需求分析</h3><p>​		熟悉需求，获取性能需求指标。</p>
<p>​		明确被测系统（业务功能、架构）—明确测试内容（高频业务&#x2F;逻辑复杂业务、数据量大业务）—明确测试策略（负载、稳定…)—明确测试指标（预期指标对比&#x2F;预估指标）</p>
<h3 id="性能测试的计划和方案"><a href="#性能测试的计划和方案" class="headerlink" title="性能测试的计划和方案"></a>性能测试的计划和方案</h3><p>​		WWW方案。What、Who、How。</p>
<h3 id="性能测试用例"><a href="#性能测试用例" class="headerlink" title="性能测试用例"></a>性能测试用例</h3><p>​		用例名称、用例编号、用例描述、前置条件、用例步骤、期望性能结果、实际结果。</p>
<h3 id="性能测试执行"><a href="#性能测试执行" class="headerlink" title="性能测试执行"></a>性能测试执行</h3><p>​		建立测试环境—编写测试脚本—性能测试监控—执行测试脚本。</p>
<h3 id="性能分析与调优"><a href="#性能分析与调优" class="headerlink" title="性能分析与调优"></a>性能分析与调优</h3><p>​		性能测试分析人员根据对结果的分析，如果不符合性能需求，则提出性能bug，由开发人员进行后续的调优。而后继续进行性能验证，直到满足性能需求为止。</p>
<h3 id="性能测试报告总结"><a href="#性能测试报告总结" class="headerlink" title="性能测试报告总结"></a>性能测试报告总结</h3><ul>
<li>测试工作的回顾</li>
<li>缺陷分析和调优</li>
<li>风险评估</li>
<li>性能测试结果</li>
<li>总结与该进</li>
</ul>
<p>​		关于性能测试需求分析，描述正确的是:（ACD）<br>A、性能测试需求分析时，需要对系统的业务功能非常熟悉</p>
<p>B、性能测试需求分析时，可以不用关心系统的技术实现</p>
<p>C、有明确需求指标时，性能测试的指标完全根据需求来确定</p>
<p>D、没有明确的需求指标时，性能测试的指标根据经验来确定</p>
<p>ps：需要关心系统的技术实现，不同的环境、操作系统、资源对系统的性能影响。</p>
<p>​		关于性能测试环境，描述正确的是: （AD）</p>
<p>A、性能测试环境和功能测试环境一样，需要使用指定的软件及版本</p>
<p>B、性能测试环境和功能测试环境一样，可以多个测试人员一起使用</p>
<p>C、性能测试环境和功能测试环境一样，可以把软件都安装在一台服务器上，只需要保证环境可以正常访问即可</p>
<p>D、性能测试环境可以找运维和开发协助搭建</p>
<p>ps：多个测试人员一起使用就瓜分了系统资源了，判断不出具体的系统时间，空间特性；要保证测试环境与真实环境一致，测试才有意义。</p>
<p>​		关于性能测试执行，描述正确的是: （ABC）</p>
<p>A、性能测试脚本执行前，必须保证所有的脚本都调试通过了</p>
<p>B、性能测试脚本执行前，还需要设置脚本运行的场景〔并发数、运行时间、启动方式等等)</p>
<p>C、性能测试脚本执行时，需要同步监控服务器的各项性能指标</p>
<p>D、服务器的各项性能指标，可以在性能测试结束后再统一收集</p>
<p>ps：性能指标需要同步收集，最后只能收集到状态或小部分指标，不够全面准确。</p>
<p>​		关于性能测试分析和调优，描述正确的是:（AD）<br>A、测试人员需要对性能测试结果进行分析，如果有问题则提交bug</p>
<p>B、测试人员需要对性能测试的问题进行调优，找到问题的原因，并给出解决建议</p>
<p>C、经验丰富的性能调优人员，通常能准确的定位出性能的根本原因，一次就能修改成功</p>
<p>D、性能调优后，需要测试对比是否有性能提升;通常性能调优要经过很多轮的优化才能最终达成性能指标</p>
<p>ps：调优是开发的工作。</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>接口自动化测试---基础</title>
    <url>/2023/11/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="接口测试基础"><a href="#接口测试基础" class="headerlink" title="接口测试基础"></a>接口测试基础</h2><p>接口：系统之间数据交互的通道。</p>
<p>接口测试：基于不同的输入参数，校验接口响应数据与预期数据是否一致。<span id="more"></span></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>接口文档解析——一般都有对应得接口信息。如没有，则自行获取。对于web接口，可以采用开发者模式F12得到相应的接口信息。对于app接口，则采用抓包的方式获取接口信息，如Fidder</li>
<li>设计测试用例</li>
<li>脚本开发</li>
<li>执行脚本</li>
<li>缺陷跟踪</li>
<li>测试报告</li>
</ul>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL：是互联网上标准资源得地址，一般称为统一资源定位符</p>
<p>组成：协议::&#x2F;&#x2F;hostname[:port]&#x2F;path&#x2F;[?查询参数1&amp;查询参数2]，即协议，服务器地址，端口号，资源路径，参数</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP：超文本传输协议，基于请求与响应的应用层协议</p>
<ul>
<li>HTTP请求（请求行，请求头，请求体）</li>
<li>HTTP响应（响应行，响应头，响应体）</li>
</ul>
<h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li><p>请求行：<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231130192119149.png" alt="image-20231130192119149"></p>
<ul>
<li><p>位置：第一行</p>
</li>
<li><p>作用：说明请求方法、访问的资源、协议版本</p>
</li>
<li><p>常用方法</p>
<ul>
<li>Get</li>
<li>Post</li>
<li>Put</li>
<li>Delect</li>
</ul>
</li>
</ul>
</li>
<li><p>请求头</p>
<ul>
<li>位置：第二行到空白行之间</li>
<li>作用：通知服务端请求信息</li>
<li>特点：由键值对组成，每行一对</li>
<li>Content-Type：请求体数据类型<ul>
<li>text&#x2F;html：HTML格式</li>
<li>image&#x2F;jpeg：jpg图片格式</li>
<li><strong>application&#x2F;json</strong>：JSON数据格式</li>
<li><strong>application&#x2F;x-www-form-urlencoded</strong>：表单默认的提交数据格式</li>
<li>multipart&#x2F;form-data：表单中进行文件上传</li>
</ul>
</li>
</ul>
</li>
<li><p>请求体：<strong>（可以没有对应的请求体内容）</strong></p>
<ul>
<li>位置：空白行之后的内容</li>
<li>作用：传输数据实体 </li>
<li>注意：请求体常在<strong>POST、PUT</strong>方法中使用 </li>
<li>常配合的请求头：<strong>Content-Type</strong>和<strong>Content-Length</strong></li>
</ul>
</li>
</ul>
<h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h4><ul>
<li>状态行 <img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231130193147639.png" alt="image-20231130193147639" style="zoom:67%;" /><ul>
<li>位置：响应数据第一行 </li>
<li>作用：描述服务器处理结果 </li>
<li>内容: 状态行由协议版本号、<strong>状态码</strong>、状态消息组成</li>
<li>状态码：表示此次请求的响应状态，详细见最后的状态码表。<ul>
<li>1XX：指示信息</li>
<li><strong>2XX</strong>：成功 </li>
<li>3XX：重定向 </li>
<li><strong>4XX</strong>：客户端错误 </li>
<li><strong>5XX</strong>：服务端错误</li>
</ul>
</li>
</ul>
</li>
<li>响应头<ul>
<li>位置：第二行开始到空白行之间 </li>
<li>作用：描述客户端端要使用的一些附加信息 </li>
<li>特点: 响应头由键值对组成，每行一对</li>
<li>也有Content-Type与Content-Length，表明返回的数据类型与长度</li>
</ul>
</li>
<li>响应体<ul>
<li>位置：响应数据空白行之后</li>
<li>作用：服务器返回的数据实体 </li>
<li>特点：有图片、json、xml、html等多种类型</li>
</ul>
</li>
</ul>
<p>使用工具进行接口自动化测试将使用新的文章记录。</p>
<h2 id="接口自动化测试"><a href="#接口自动化测试" class="headerlink" title="接口自动化测试"></a>接口自动化测试</h2><ul>
<li>选取自动化测试用例 </li>
<li>搭建自动化测试环境 </li>
<li>搭建自动化测试框架 </li>
<li>代码实现自动化 </li>
<li>输出测试报告 </li>
<li>实现持续集成</li>
</ul>
<h3 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install requests  <span class="comment">#安装</span></span><br><span class="line">request --version 	<span class="comment">#验证</span></span><br></pre></td></tr></table></figure>

<h4 id="Requests发送请求"><a href="#Requests发送请求" class="headerlink" title="Requests发送请求"></a>Requests发送请求</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.请求方法（url，params=<span class="literal">None</span>，data=<span class="literal">None</span>，json=<span class="literal">None</span>，headers=<span class="literal">None</span>，files=<span class="literal">None</span>）<span class="comment">#必须传入对应的url地址，其余参数非必须</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;说明：</span></span><br><span class="line"><span class="string">常见的请求方法： get/post/put/delete</span></span><br><span class="line"><span class="string">url：请求的url地址</span></span><br><span class="line"><span class="string">params：请求查询参数</span></span><br><span class="line"><span class="string">data：请求体为form表单参数</span></span><br><span class="line"><span class="string">json：请求体为json参数</span></span><br><span class="line"><span class="string">headers：请求头参数</span></span><br><span class="line"><span class="string">Files：文件参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Response响应"><a href="#Response响应" class="headerlink" title="Response响应"></a>Response响应</h4><ul>
<li>response.status_code ：状态码 </li>
<li>response.json() ：JSON形式的响应内容</li>
<li>response.text ：文本形式的响应内容 </li>
<li>response.url ：请求url </li>
<li>response.encoding：查看响应头部字符编码 </li>
<li>response.headers ：头信息 </li>
<li>response.cookies ：cookie信息</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;application&quot;</span>:<span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;applicaiton_client_type&quot;</span>:<span class="string">&quot;weixin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;accounts&quot;</span>:<span class="string">&quot;huace_xm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span>:<span class="number">123456</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;username&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs5 = requests.request(url=<span class="string">&quot;http://shop-xo.hctestedu.com/index.php?s=api/region/index&quot;</span>,</span><br><span class="line">                 method=<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                 params=params,</span><br><span class="line">                 data=data)</span><br><span class="line"><span class="built_in">print</span>(rs5.json())</span><br><span class="line"><span class="comment">#使用对应的方法，参数，调用对应的方法或者request方法，得到响应结果</span></span><br></pre></td></tr></table></figure>

<h2 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h2><ul>
<li>200 OK 服务器成功返回用户请求的数据 </li>
<li>201 CREATED 用户新建或修改数据成功 </li>
<li>204 NO CONTENT 用户删除数据成功 </li>
<li>301 Moved Permanently 被请求的资源已永久移动到新位置 </li>
<li>302 Move Temporarily 被请求的资源临时性移动到新位置 </li>
<li>400 Bad Request 客户端请求有语法错误，不能被服务器所理解 </li>
<li>401 Unauthorized 未授权的（未登录） </li>
<li>403 Forbidden 表示用户得到授权，但是访问是被禁止的 </li>
<li>404 Not Found 请求资源不存在 </li>
<li>500 INTERNAL SERVER ERROR 服务器发生错误，用户将无法判断发出的请求是否成功 </li>
<li>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<a href="/2023/12/02/2023-12-01-%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95---%E8%BF%9B%E9%98%B6/" title="接口自动化测试---进阶">接口自动化测试---进阶</a>
]]></content>
      <tags>
        <tag>接口测试</tag>
        <tag>测试</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>日志logger</title>
    <url>/2023/11/25/%E6%97%A5%E5%BF%97logger/</url>
    <content><![CDATA[<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>​		1）什么是日志</p>
<p>​		日志（Log）是指记录程序运行状态的信息。在程序运行过程中，它可以记录代码中变量的变化情况，跟踪代码运行时的轨迹，向文件或控制台输出代码的调试信息等。</p>
<span id="more"></span>

<p>​		2）特点</p>
<ol>
<li>调试程序</li>
<li>定位跟踪bug</li>
<li>根据日志，查看系统运行是否出错</li>
<li>分析用户行为，与数据统计</li>
</ol>
<p>​		3）日志级别	</p>
<ul>
<li>DEBUG 调试级别：打印非常详细的日志信息，通常用于对代码的调试</li>
<li>INFO 信息级别：打印一般的日志信息，突出强调程序的运行过程</li>
<li>WARNING 警告级别：打印警告日志信息，表明会出现潜在错误的情形，一般不影响软件的正常使用</li>
<li>ERROR 错误级别：打印错误异常信息，该级别的错误可能会导致系统的一些功能无法正常使用</li>
<li>CRITICAL 严重错误级别：一个严重的错误，这表明系统可能无法继续运</li>
</ul>
<p>​		4）说明</p>
<ul>
<li><p>上面的日志级别是从上到下依次升高的，即：DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</p>
</li>
<li><p>当为程序指定一个日志级别后，程序会记录所有日志级别大于或等于指定日志级别的日志信息，而不是仅仅记录指定级别的日志信息</p>
</li>
<li><p>开发常用级别DEBUG、INFO、WARNING、ERROR ；测试常用级别：INFO、ERROR</p>
</li>
</ul>
<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>​		Python中有一个标准库模块logging可以直接记录日志</p>
<p>​		1）基本用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&quot;这是一条调试信息&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;这是一条普通信息&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;这是一条警告信息&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;这是一条错误信息&quot;</span>)</span><br><span class="line">logging.critical(<span class="string">&quot;这是一条严重错误信息&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">WARNING:root:这是一条警告信息</span></span><br><span class="line"><span class="string">ERROR:root:这是一条错误信息</span></span><br><span class="line"><span class="string">CRITICAL:root:这是一条严重错误信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;why</span></span><br><span class="line"><span class="string">默认的日志级别为warning，故只输出warning和高级别日志</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​		2）更改日志级别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"><span class="comment">#这样就会输出debug以上的日志信息，即所有日志信息</span></span><br><span class="line"><span class="comment">#注意要再使用日志之前就更改日志级别，否则还是默认的warning级别</span></span><br></pre></td></tr></table></figure>

<p>​		注意：</p>
<ul>
<li><p>在开发环境和测试环境中，为了尽可能详细的查看程序的运行状态来保证上线后的稳定性，可以使用DEBUG或INFO级别的日志获取</p>
<p>详细的日志信息，这是非常耗费机器性能的。</p>
</li>
<li><p>在生产环境中，通常只记录程序的异常信息、错误信息等（设置成WARNING或ERROR级别），这样既可以减小服务器的I&#x2F;O压力，也</p>
<p>可以提高获取错误日志信息的效率和方便问题的排查。</p>
</li>
</ul>
<p>​		3）日志格式</p>
<p>​		默认的日志的格式为：日志级别:Logger名称:日志内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义日志格式</span></span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&quot;%(levelname)s:%(name)s:%(message)s&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​		format中用到的占位符字符串格式</p>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%(name)s</td>
<td align="center">Logger的名字</td>
</tr>
<tr>
<td align="center">%(levelno)s</td>
<td align="center">数字形式的日志级别</td>
</tr>
<tr>
<td align="center"><strong>%(levelname)s</strong></td>
<td align="center">文本形式的日志级别</td>
</tr>
<tr>
<td align="center">%(pathname)s</td>
<td align="center">调用日志输出函数的模块的完整路径名，可能没有</td>
</tr>
<tr>
<td align="center"><strong>%(filename)s</strong></td>
<td align="center">调用日志输出函数的模块的文件名</td>
</tr>
<tr>
<td align="center">%(module)s</td>
<td align="center">调用日志输出函数的模块名</td>
</tr>
<tr>
<td align="center">%(funcName)s</td>
<td align="center">调用日志输出函数的函数名</td>
</tr>
<tr>
<td align="center"><strong>%(lineno)d</strong></td>
<td align="center">调用日志输出函数的语句所在的代码行</td>
</tr>
<tr>
<td align="center">%(created)f</td>
<td align="center">当前时间，用UNIX标准的表示时间的浮 点数表示</td>
</tr>
<tr>
<td align="center">%(relativeCreated)d</td>
<td align="center">输出日志信息时的，自Logger创建以来的毫秒数</td>
</tr>
<tr>
<td align="center"><strong>%(asctime)s</strong></td>
<td align="center">字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”</td>
</tr>
<tr>
<td align="center">%(thread)d</td>
<td align="center">线程ID。可能没有</td>
</tr>
<tr>
<td align="center">%(threadName)s</td>
<td align="center">线程名。可能没有</td>
</tr>
<tr>
<td align="center">%(process)d</td>
<td align="center">进程ID。可能没有</td>
</tr>
<tr>
<td align="center"><strong>%(message)s</strong></td>
<td align="center">用户输出的消息</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment">#常用格式</span></span><br><span class="line">fmt = <span class="string">&#x27;%(asctime)s %(levelname)s [%(name)s] [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&#x27;</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=fmt)</span><br><span class="line"><span class="comment">#注意，若写多条basicConfig只生效一条</span></span><br><span class="line"><span class="comment">#故将日志级别，格式，输出写在一条语句中</span></span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&quot;调试&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;信息&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;警告&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​		4）日志输出</p>
<p>​		默认情况下Python的logging模块将日志打印到了标准输出中（控制台）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将日志输出到文件中</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">fmt = <span class="string">&#x27;%(asctime)s %(levelname)s [%(name)s] [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&#x27;</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">&quot;a.log&quot;</span>, level=logging.INFO, <span class="built_in">format</span>=fmt)</span><br><span class="line"><span class="comment">#同时指定日志级别，日志格式，日志输出</span></span><br><span class="line"><span class="comment">#这种方式写入文件，中文乱码</span></span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&quot;调试&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;信息&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;警告&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​		注意：通过以上操作，可以进行基本的日志操作。但是如何将日志文件同时输出到文件和控制台呢？将警告日志输出到控制台，错误日志输出到文件中该如何操作呢？日志文件过大如何处理呢？</p>
<h3 id="logger-高阶"><a href="#logger-高阶" class="headerlink" title="logger 高阶"></a>logger 高阶</h3><p>​		1）logger 4大模块</p>
<ul>
<li>日志器———Logger———使用日志的入口</li>
<li>处理器———Handler———日志的输出，即输出到控制台还是文件中</li>
<li>格式器 ———Formatter ———决定日志记录的最终输出格式</li>
<li>过滤器 ———Filter——— 提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</li>
</ul>
<p>​		2）模块间的关系</p>
<ul>
<li>日志器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等</li>
<li>不同的处理器（handler）可以将日志输出到不同的位置</li>
<li>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置</li>
<li>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</li>
<li>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志</li>
</ul>
<p>​		简单点说就是：日志器（logger）是入口，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。</p>
<h4 id="Logger-类"><a href="#Logger-类" class="headerlink" title="Logger 类"></a>Logger 类</h4><p>​		1）使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger = logging.getLogger()</span><br><span class="line">logger = logging.getLogger(<span class="string">&quot;myLogger&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​		logging.getLogger()方法有一个可选参数name，该参数表示将要返回的日志器的名称标识，如果不提供该参数，则返回root日志器</p>
<p>对象。 若以相同的name参数值多次调用getLogger()方法，将会返回指向同一个logger对象的引用（类似单例的感觉，<strong>就是采用相同的名字多次调用返回的是同一个对象</strong>）。</p>
<p>​		2）方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.debug()</span><br><span class="line">logger.info()</span><br><span class="line">logger.warning()    <span class="comment">#输出日志</span></span><br><span class="line">logger.error()</span><br><span class="line">logger.critical()</span><br><span class="line"></span><br><span class="line">logger.setLevel()   <span class="comment">#设置日志器将会处理的日志消息的最低级别</span></span><br><span class="line">logger.addHandler() <span class="comment">#为该logger对象添加一个handler对象</span></span><br><span class="line">logger.addFilter()  <span class="comment">#为该logger对象添加一个filter对象</span></span><br></pre></td></tr></table></figure>

<h4 id="Handler-类"><a href="#Handler-类" class="headerlink" title="Handler 类"></a>Handler 类</h4><p>​	Handler对象的作用是将消息分发到handler指定的位置，比如：<strong>控制台、文件、网络、邮件</strong>等。 Logger对象可以通过addHandler()方</p>
<p>法为自己添加<strong>多个</strong>handler对象。</p>
<p>​		1）使用</p>
<p>​	在程序中不应该直接实例化和使用Handler实例，因为Handler是一个基类，它只定义了Handler应该有的接口。 应该使用Handler实</p>
<p>现类来创建对象，logging中内置的常用的Handler包括：</p>
<ul>
<li><strong>logging.StreamHandler</strong>       		  将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象,控制台输出。</li>
<li>logging.FileHandler              		    将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</li>
<li><strong>logging.handlers.RotatingFileHandler</strong> 			  将日志消息发送到磁盘文件，并支持日志文件按大小切割</li>
<li><strong>logging.hanlders.TimedRotatingFileHandler</strong>   将日志消息发送到磁盘文件，并支持日志文件按时间切割</li>
<li>logging.handlers.HTTPHandler 							   将日志消息以GET或POST的方式发送给一个HTTP服务器</li>
<li>logging.handlers.SMTPHandler						 	   将日志消息发送给一个指定的email地址</li>
</ul>
<p>​		2）方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler.setLevel() <span class="comment">#设置handler将会处理的日志消息的最低严重级别</span></span><br><span class="line">handler.setFormatter() <span class="comment">#为handler设置一个格式器对象</span></span><br><span class="line">handler.addFilter() <span class="comment">#为handler添加一个过滤器对象</span></span><br></pre></td></tr></table></figure>

<h4 id="Formatter-类"><a href="#Formatter-类" class="headerlink" title="Formatter 类"></a>Formatter 类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用</span></span><br><span class="line">formatter = logging.Formatter(fmt=<span class="literal">None</span>, datefmt=<span class="literal">None</span>, style=<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line"><span class="comment">#fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值</span></span><br><span class="line"><span class="comment">#datefmt：指定日期格式字符串，如果不指定该参数则默认使用&quot;%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line"><span class="comment">#style：Python 3.2新增的参数，可取值为 &#x27;%&#x27;, &#x27;&#123;&#x27;和 &#x27;$&#x27;，如果不指定该参数则默认使用&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​		Filter 类使用较少，可自行查阅</p>
<h3 id="logger-应用"><a href="#logger-应用" class="headerlink" title="logger 应用"></a>logger 应用</h3><p>​		1）将日志同时输出到控制台和文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()  <span class="comment">#初始化日志文件</span></span><br><span class="line"><span class="comment">#自定义格式</span></span><br><span class="line">fmt = <span class="string">&#x27;%(asctime)s %(levelname)s [%(name)s] [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&#x27;</span></span><br><span class="line">formatter = logging.Formatter(fmt) <span class="comment">#定义格式器</span></span><br><span class="line"></span><br><span class="line">sh = logging.StreamHandler() <span class="comment">#指定输出的handler，输出到控制台</span></span><br><span class="line">sh.setFormatter(formatter) <span class="comment">#将格式器加入到控制器中</span></span><br><span class="line">logger.addHandler(sh)  <span class="comment">#添加控制器</span></span><br><span class="line"></span><br><span class="line">fh = logging.FileHandler(<span class="string">&quot;./b.log&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment">#输出到文件的控制器,设置utf-8格式，中文不乱码</span></span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">logger.addHandler(fh)</span><br></pre></td></tr></table></figure>

<p>​		2）每日生成一个文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fh = logging.handlers.TimedRotatingFileHandler(filename, when=<span class="string">&#x27;h&#x27;</span>, interval=<span class="number">1</span>, backupCount=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#使用按找时间片分隔文件的控制器实现类</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">将日志信息记录到文件中，以特定的时间间隔切换日志文件。</span></span><br><span class="line"><span class="string">filename: 日志文件名</span></span><br><span class="line"><span class="string">when: 时间单位，可选参数</span></span><br><span class="line"><span class="string">	S - Seconds</span></span><br><span class="line"><span class="string">	M - Minutes</span></span><br><span class="line"><span class="string">	H - Hours</span></span><br><span class="line"><span class="string">	D - Days，按照日期</span></span><br><span class="line"><span class="string">	midnight - 每晚12点，天</span></span><br><span class="line"><span class="string">	W&#123;0-6&#125; -  0 - Monday，周几</span></span><br><span class="line"><span class="string">interval: 时间间隔，就代表几个when</span></span><br><span class="line"><span class="string">backupCount: 日志文件备份数量。如果backupCount大于0，那么当生成新的日志文件时，将只保留backupCount个文件，删除最老的文件。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.handlers <span class="comment">#使用高级的处理器必须导这个包，不然报错</span></span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line">logger.setLevel(logging.DEBUG)<span class="comment">#总的日志级别</span></span><br><span class="line"><span class="comment"># 日志格式</span></span><br><span class="line">fmt = <span class="string">&quot;%(asctime)s %(levelname)s [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&quot;</span></span><br><span class="line">formatter = logging.Formatter(fmt)</span><br><span class="line"><span class="comment"># 输出到文件，每日一个文件</span></span><br><span class="line">fh = logging.handlers.TimedRotatingFileHandler(<span class="string">&quot;./a.log&quot;</span>, when=<span class="string">&#x27;MIDNIGHT&#x27;</span>, interval=<span class="number">1</span>, backupCount=<span class="number">31</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="comment">#注意都设置utf-8格式</span></span><br><span class="line"><span class="comment">#每天分隔一个文件，保留31个</span></span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line">fh.setLevel(logging.INFO)<span class="comment">#可以文件中记录的日志级别</span></span><br><span class="line"><span class="comment">#控制器的级别应该大于等于日志器的级别，否则为日志器的级别</span></span><br><span class="line"><span class="comment">#日志器默认为warning</span></span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;我真帅&quot;</span>)</span><br><span class="line">logger.info(<span class="string">&quot;我真棒&quot;</span>)</span><br><span class="line"><span class="comment">#文件中只会存储我真棒</span></span><br></pre></td></tr></table></figure>

<p>​		3）单例模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.handlers <span class="comment">#使用高级的处理器必须导这个包，不然报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetLogger</span>:</span><br><span class="line">    logger=<span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLogger</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">if</span> cls.logger <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.logger = logging.getLogger()</span><br><span class="line">            cls.logger.setLevel(logging.DEBUG)</span><br><span class="line">			<span class="comment"># 日志格式</span></span><br><span class="line">            fmt = <span class="string">&quot;%(asctime)s %(levelname)s [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&quot;</span></span><br><span class="line">            formatter = logging.Formatter(fmt)</span><br><span class="line">   			 <span class="comment"># 输出到文件，每日一个文件</span></span><br><span class="line">            fh = logging.handlers.TimedRotatingFileHandler(<span class="string">&quot;./a.log&quot;</span>, when=<span class="string">&#x27;MIDNIGHT&#x27;</span>, interval=<span class="number">1</span>, backupCount=<span class="number">31</span>)   <span class="comment">#每天分隔一个文件，保留31个</span></span><br><span class="line">            fh.setFormatter(formatter)</span><br><span class="line">            fh.setLevel(logging.INFO)<span class="comment">#可以设置记录的日志级别</span></span><br><span class="line">            cls.logger.addHandler(fh)</span><br><span class="line">            sh = logging.StreamHandler() <span class="comment">#指定输出的handler，输出到控制台</span></span><br><span class="line">			sh.setFormatter(formatter) <span class="comment">#将格式器加入到控制器中</span></span><br><span class="line">			cls.logger.addHandler(sh)  <span class="comment">#添加控制器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls.logger</span><br><span class="line">    </span><br><span class="line"><span class="comment">#单例很重要，奥里给</span></span><br></pre></td></tr></table></figure>

<p>​		4）yml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">disable_existing_loggers:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">formatters:</span></span><br><span class="line">  <span class="attr">simpleFormatter:</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">&#x27;%(asctime)s %(levelname)s [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&#x27;</span></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line">  <span class="attr">consoleHandler:</span></span><br><span class="line">    <span class="attr">class:</span> <span class="string">logging.StreamHandler</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">formatter:</span> <span class="string">simpleFormatter</span></span><br><span class="line">    <span class="attr">stream:</span> <span class="string">ext://sys.stdout</span></span><br><span class="line">  <span class="attr">fileHandler:</span></span><br><span class="line">    <span class="attr">class:</span> <span class="string">logging.handlers.RotatingFileHandler</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">formatter:</span> <span class="string">simpleFormatter</span></span><br><span class="line">    <span class="attr">filename:</span> <span class="string">sample.log</span></span><br><span class="line">    <span class="attr">maxBytes:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">backupCount:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">loggers:</span></span><br><span class="line">  <span class="attr">sampleLogger:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">handlers:</span> [<span class="string">fileHandler</span>, <span class="string">consoleHandler</span>]</span><br><span class="line">    <span class="attr">propagate:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">root:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">INFO</span></span><br><span class="line">  <span class="attr">handlers:</span> [<span class="string">consoleHandler</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./logconf/log.yaml&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    config = yaml.safe_load(f.read())</span><br><span class="line">    logging.config.dictConfig(config)</span><br><span class="line"></span><br><span class="line">logger_r = logging.getLogger()  <span class="comment">#使用root日志</span></span><br><span class="line">logger_s = logging.getLogger(<span class="string">&#x27;sampleLogger&#x27;</span>) <span class="comment">#使用指定的日志，sampleLogger</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>日志</tag>
        <tag>logger</tag>
      </tags>
  </entry>
</search>
