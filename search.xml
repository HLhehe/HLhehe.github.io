<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Faker生成测试伪数据</title>
    <url>/2023/11/26/Faker/</url>
    <content><![CDATA[<h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><p>​		1）测试数据的来源</p>
<ul>
<li>人工手动编写测试数据</li>
<li>在数据库中直接插入数据<span id="more"></span></li>
<li>csv文件</li>
<li>通过wbe ui反复点击，生成对应的数据</li>
<li>利用postman、jmeter</li>
<li>随机生成</li>
</ul>
<p>​		2）问题</p>
<p>​		虽然有各种各样的方法能生成测试数据，但核心思想大都是人为设计测试数据的生成。当数据量大的时候，该工作量复杂且繁琐。且生成的数据可能失去了它对应的意义（如地址随机生成为了一串数字）。因此，faker库就出现在了人们面前（不是大魔王啊）</p>
<h3 id="Faker库"><a href="#Faker库" class="headerlink" title="Faker库"></a>Faker库</h3><p>​		1）简介</p>
<p>​		Faker是Python的一个第三方库，用于生成虚拟数据。它支持全球各地的地名、职业、性别等数据生成。Faker库的核心功能是通过强大的生成算法，随机生成真实世界中的类似数据。Faker库广泛应用于数据测试、数据清洗和数据填充等领域。</p>
<p>​		2）安装</p>
<p>​		在python对应项目的虚拟环境中执行以下命令即可（python是真的方便）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install Faker <span class="comment">#安装</span></span><br><span class="line"></span><br><span class="line">faker --version   <span class="comment">#检查</span></span><br></pre></td></tr></table></figure>

<p>​		3）使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line">fk=Faker(locale=<span class="string">&quot;zh_Cn&quot;</span>)<span class="comment">#明人不说暗话，都是中国人</span></span><br><span class="line"><span class="comment">#使用多种语言 fk=Faker(locale=[&quot;zh_Cn&quot;,&quot;zh_TW&quot;])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fk.name())  <span class="comment">#生成名字，按找设置的地区检查</span></span><br><span class="line"><span class="built_in">print</span>(fk.name_female())  <span class="comment">#生成女性名字</span></span><br><span class="line"><span class="built_in">print</span>(fk.name_male())   <span class="comment">#生成男性名字   董冬梅  这也不太像啊，哈哈哈</span></span><br><span class="line"><span class="built_in">print</span>(fk.phone_number()) <span class="comment">#生成手机号，会按照你设定的地区，自动检查格式</span></span><br><span class="line"><span class="built_in">print</span>(fk.phonenumber_prefix()) <span class="comment">#随机生成一个手机号号段  前几位</span></span><br><span class="line"><span class="built_in">print</span>(fk.ssn())  <span class="comment">#生成一个的身份ID</span></span><br><span class="line"><span class="built_in">print</span>(fk.date_of_birth())   <span class="comment">#生成一个生日日期</span></span><br><span class="line"><span class="built_in">print</span>(fk.date_of_birth(minimum_age=<span class="number">18</span>, maximum_age=<span class="number">20</span>))  <span class="comment">#生成一个生日日期(18~20岁之间)</span></span><br><span class="line"><span class="built_in">print</span>(fk.credit_card_number())  <span class="comment">#生成一个信用卡号</span></span><br><span class="line"><span class="built_in">print</span>(fk.license_plate())  <span class="comment">#生成一个车牌号</span></span><br><span class="line"><span class="built_in">print</span>(fk.bank())  <span class="comment">#生成一个银行名称</span></span><br><span class="line"><span class="built_in">print</span>(fk.email())  <span class="comment">#生成一个邮箱</span></span><br><span class="line"><span class="built_in">print</span>(fk.company())  <span class="comment">#生成一个完整的公司名称</span></span><br><span class="line"><span class="built_in">print</span>(fk.company_suffix())   <span class="comment">#生成一个公司名</span></span><br><span class="line"><span class="built_in">print</span>(fk.job())  <span class="comment">#生成一个职位名称</span></span><br></pre></td></tr></table></figure>

<p>​		4）内置的各种函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="comment"># fake = Faker([&quot;en_US&quot;, &quot;zh_CN&quot;, &quot;ja_JP&quot;])</span></span><br><span class="line">fake = Faker([<span class="string">&quot;zh_CN&quot;</span>])</span><br><span class="line"><span class="comment"># print(fake.name())</span></span><br><span class="line"><span class="comment"># print(fake[&#x27;en-US&#x27;].name())</span></span><br><span class="line"><span class="comment"># print(fake.company())</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1、使用？#自定义规则，随机生成字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.bothify())  <span class="comment"># 默认生成字符串格式： 05 RW</span></span><br><span class="line"><span class="built_in">print</span>(fake.bothify(text=<span class="string">&quot;666????####&quot;</span>, letters=<span class="string">&#x27;我们的家&#x27;</span>))  <span class="comment"># letters的字符串随机给text的？使用，##默认数字代替，格式如： 我我的我4777</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、使用^自定义规则，随机生成16进制字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.hexify(text=<span class="string">&#x27;MAC Address: ^^:^^:^^:^^:^^:^^&#x27;</span>, upper=<span class="literal">True</span>))  <span class="comment"># MAC Address: CD:18:FC:9F:B6:49</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3、随机生成 i18n 语言的代码</span></span><br><span class="line"><span class="built_in">print</span>(fake.language_code())  <span class="comment"># yo</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4、使用？自定义规则，随机生成ASCII字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.lexify(text=<span class="string">&#x27;Random Identifier: ??????????&#x27;</span>, letters=<span class="string">&#x27;我ABCDE&#x27;</span>))  <span class="comment"># Random Identifier: CBC我DD我ABE</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 5、随机生成 i18n 区域设置</span></span><br><span class="line"><span class="built_in">print</span>(fake.locale())  <span class="comment"># zh_CH</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 6、使用#！@%自定义规则，随机生成字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.numerify(text=<span class="string">&#x27;#  @!! @ %&#x27;</span>))  <span class="comment"># 1  98  7  （#=[0,9] %=[1,9] !=随机数字或空字符 @=非0数字或空字符）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 7、随机选择对象元素，并随机生成列表</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_choices(elements=(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), length=<span class="number">10</span>))  <span class="comment"># [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_choices(elements=OrderedDict([(<span class="string">&quot;a&quot;</span>, <span class="number">0.45</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">0.35</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">0.15</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">0.05</span>), ])))  <span class="comment"># [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 8、随机生成0-9整数</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_digit())  <span class="comment"># 0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 9、随机生成1-9整数</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_digit_not_null())  <span class="comment"># 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 10、随机生成0-9整数或空值</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_digit_or_empty())  <span class="comment"># &quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 11、随机选择元素，默认可重复、长度为1</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_element(elements=(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)))  <span class="comment"># a</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_element(elements=OrderedDict([(<span class="string">&quot;a&quot;</span>, <span class="number">0.45</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">0.35</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">0.15</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">0.05</span>), ])))  <span class="comment"># a</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 12、随机选择元素，默认可重复、长度不定</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_elements(elements=(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), unique=<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.random_elements(elements=OrderedDict([(<span class="string">&quot;a&quot;</span>, <span class="number">0.45</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">0.35</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">0.15</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">0.05</span>), ]), length=<span class="number">20</span>, unique=<span class="literal">False</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 13、在指定范围内，随机生成整数</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_int(<span class="built_in">min</span>=<span class="number">0</span>, <span class="built_in">max</span>=<span class="number">15</span>, step=<span class="number">3</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 14、随机生成ASCII字符串 [a-zA-Z]</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_letter())  <span class="comment"># &#x27;y&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 15、随机生成ASCII字符串列表 [a-zA-Z]</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_letters(length=<span class="number">10</span>))  <span class="comment"># [&#x27;R&#x27;, &#x27;N&#x27;, &#x27;v&#x27;, &#x27;n&#x27;, &#x27;A&#x27;, &#x27;v&#x27;, &#x27;O&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, &#x27;E&#x27;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 16、随机生成ASCII小写字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_lowercase_letter())  <span class="comment"># c</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 17、随机生成整数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果digits为None(默认值)，则取值范围为1 ~ 9之间的随机整数。</span></span><br><span class="line"><span class="string">如果fix_len为False(默认值)，则可以生成所有不超过位数的整数。</span></span><br><span class="line"><span class="string">如果fix_len为True，则只能生成具有精确位数的整数。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_number(fix_len=<span class="literal">True</span>))  <span class="comment"># 297371</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_number(digits=<span class="number">3</span>, fix_len=<span class="literal">False</span>))  <span class="comment"># 577</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 18、随机生成元素不重复的不超出元素数量的列表</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_sample(elements=(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;f&#x27;</span>), length=<span class="number">6</span>))  <span class="comment"># 元素可相同，但length不能大于6</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 19、生成大写字母的ASCII字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.random_uppercase_letter())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 20、随机生成接近某个数字的整数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果le为False(默认值)，则允许生成数量的140%。如果为True，则上限生成为100%。</span></span><br><span class="line"><span class="string">如果ge为False(默认值)，则允许生成数量减少到60%。如果为True，下限生成上限为100%。</span></span><br><span class="line"><span class="string">如果提供了最小值的数值，则生成的小于最小值的值将被固定在最小值。</span></span><br><span class="line"><span class="string">如果为max提供了一个数值，则生成的大于max的值将被固定在max。</span></span><br><span class="line"><span class="string">如果le和ge都为True，则number的值将自动返回，而不管提供的min和max的值是什么。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(fake.randomize_nb_elements(number=<span class="number">100</span>))  <span class="comment"># 83</span></span><br><span class="line"><span class="built_in">print</span>(fake.randomize_nb_elements(number=<span class="number">100</span>, le=<span class="literal">True</span>, ge=<span class="literal">True</span>, <span class="built_in">min</span>=<span class="number">80</span>))  <span class="comment"># 100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 21、随机生成地址和邮政编号</span></span><br><span class="line"><span class="built_in">print</span>(fake.address())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 22、随机生成门牌号</span></span><br><span class="line"><span class="built_in">print</span>(fake.building_number())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 23、随机生成城市</span></span><br><span class="line"><span class="built_in">print</span>(fake.city())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 24、随机生成特殊市</span></span><br><span class="line"><span class="built_in">print</span>(fake.city_suffix())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 25、随机生成国家</span></span><br><span class="line"><span class="built_in">print</span>(fake.country())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 26、随机生成国家编号</span></span><br><span class="line"><span class="built_in">print</span>(fake.country_code())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 27、生成当前国家</span></span><br><span class="line"><span class="built_in">print</span>(fake.current_country())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 28、生成当前国家编号</span></span><br><span class="line"><span class="built_in">print</span>(fake.current_country_code())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 29、随机生成邮编</span></span><br><span class="line"><span class="built_in">print</span>(fake.postcode())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 30、随机生成街道地址</span></span><br><span class="line"><span class="built_in">print</span>(fake.street_address())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 31、随机生成街道名称</span></span><br><span class="line"><span class="built_in">print</span>(fake.street_name())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 32、随机生成街道名称后缀</span></span><br><span class="line"><span class="built_in">print</span>(fake.street_suffix())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 33、随机生成汽车供应商牌照</span></span><br><span class="line"><span class="built_in">print</span>(fake.license_plate())  <span class="comment"># 974-XXRA</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 34、生成ABA的路由传输号</span></span><br><span class="line"><span class="built_in">print</span>(fake.aba())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 35、生成银行提供商的ISO 3166-1 alpha-2国家代码</span></span><br><span class="line"><span class="built_in">print</span>(fake.bank_country())  <span class="comment"># GB</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 36、生成基本银行帐号(BBAN)</span></span><br><span class="line"><span class="built_in">print</span>(fake.bban())  <span class="comment"># MAAN00447407504564</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 37、生成国际银行账号(IBAN)</span></span><br><span class="line"><span class="built_in">print</span>(fake.iban())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 38、生成SWIFT代码</span></span><br><span class="line"><span class="built_in">print</span>(fake.swift(length=<span class="number">11</span>, primary=<span class="literal">True</span>, use_dataset=<span class="literal">True</span>))  <span class="comment"># SVWBGBNKXXX</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 39、生成11位的SWIFT代码</span></span><br><span class="line"><span class="built_in">print</span>(fake.swift11(use_dataset=<span class="literal">True</span>))  <span class="comment"># SVWBGBNKXXX</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 40、生成8位的SWIFT代码</span></span><br><span class="line"><span class="built_in">print</span>(fake.swift8(use_dataset=<span class="literal">True</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 41、生成EAN码</span></span><br><span class="line"><span class="built_in">print</span>(fake.ean(prefixes=(<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;49&#x27;</span>), length=<span class="number">13</span>))  <span class="comment"># 4532804944052</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 42、生成EAN13码</span></span><br><span class="line"><span class="built_in">print</span>(fake.ean13(prefixes=(<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;49&#x27;</span>)))  <span class="comment"># 4518561138095</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 43、生成EAN8码</span></span><br><span class="line"><span class="built_in">print</span>(fake.ean8(prefixes=(<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;49&#x27;</span>)))  <span class="comment"># 45877841</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 44、生成指定长度的本地化EAN条码</span></span><br><span class="line"><span class="built_in">print</span>(fake.localized_ean(length=<span class="number">8</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 45、生成指定长度的本地化EAN13条码</span></span><br><span class="line"><span class="built_in">print</span>(fake.localized_ean13())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 46、生成指定长度的本地化EAN8条码</span></span><br><span class="line"><span class="built_in">print</span>(fake.localized_ean8())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 47、生成随机颜色值</span></span><br><span class="line"><span class="built_in">print</span>(fake.color(hue=<span class="string">&#x27;red&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.color(luminosity=<span class="string">&#x27;light&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.color(hue=(<span class="number">100</span>, <span class="number">200</span>), color_format=<span class="string">&#x27;rgb&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.color(hue=<span class="string">&#x27;orange&#x27;</span>, luminosity=<span class="string">&#x27;bright&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.color(hue=<span class="number">135</span>, luminosity=<span class="string">&#x27;dark&#x27;</span>, color_format=<span class="string">&#x27;hsv&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.color(hue=(<span class="number">300</span>, <span class="number">20</span>), luminosity=<span class="string">&#x27;random&#x27;</span>, color_format=<span class="string">&#x27;hsl&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 48、随机生成颜色名称</span></span><br><span class="line"><span class="built_in">print</span>(fake.color_name())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 49、生成一个十六进制三元组格式的颜色</span></span><br><span class="line"><span class="built_in">print</span>(fake.hex_color())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 50、生成一个以逗号分隔的RGB值格式的颜色</span></span><br><span class="line"><span class="built_in">print</span>(fake.rgb_color())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 51、用CSS rgb()函数生成颜色格式</span></span><br><span class="line"><span class="built_in">print</span>(fake.rgb_css_color())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 52、生成一个网络安全的颜色名称</span></span><br><span class="line"><span class="built_in">print</span>(fake.safe_color_name())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 53、生成一个网络安全的颜色格式为十六进制三重</span></span><br><span class="line"><span class="built_in">print</span>(fake.safe_hex_color())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 54、公司相关(技术\思想\名称...)</span></span><br><span class="line"><span class="built_in">print</span>(fake.bs())  <span class="comment"># leverage plug-and-play networks</span></span><br><span class="line"><span class="built_in">print</span>(fake.catch_phrase())</span><br><span class="line"><span class="built_in">print</span>(fake.company())</span><br><span class="line"><span class="built_in">print</span>(fake.company_suffix())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 55、信用卡相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.credit_card_expire())  <span class="comment"># 09/28</span></span><br><span class="line"><span class="built_in">print</span>(fake.credit_card_full())  <span class="comment"># &#x27;Discover\nKatherine Fisher\n6587647593824218 05/26\nCVC: 892\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(fake.credit_card_number())  <span class="comment"># 6504876475938248</span></span><br><span class="line"><span class="built_in">print</span>(fake.credit_card_provider())  <span class="comment"># VISA 19 digit</span></span><br><span class="line"><span class="built_in">print</span>(fake.credit_card_security_code())  <span class="comment"># 604</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 56、货币相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.cryptocurrency())</span><br><span class="line"><span class="built_in">print</span>(fake.cryptocurrency_code())</span><br><span class="line"><span class="built_in">print</span>(fake.cryptocurrency_name())</span><br><span class="line"><span class="built_in">print</span>(fake.currency())</span><br><span class="line"><span class="built_in">print</span>(fake.currency_code())</span><br><span class="line"><span class="built_in">print</span>(fake.currency_name())</span><br><span class="line"><span class="built_in">print</span>(fake.currency_symbol())</span><br><span class="line"><span class="built_in">print</span>(fake.pricetag())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 57、时间相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.am_pm())</span><br><span class="line"><span class="built_in">print</span>(fake.century())</span><br><span class="line"><span class="built_in">print</span>(fake.date())</span><br><span class="line"><span class="built_in">print</span>(fake.date_between())</span><br><span class="line"><span class="built_in">print</span>(fake.date_between_dates())</span><br><span class="line"><span class="built_in">print</span>(fake.date_object())</span><br><span class="line"><span class="built_in">print</span>(fake.date_of_birth())</span><br><span class="line"><span class="built_in">print</span>(fake.date_this_century())</span><br><span class="line"><span class="built_in">print</span>(fake.date_this_decade())</span><br><span class="line"><span class="built_in">print</span>(fake.date_this_month())</span><br><span class="line"><span class="built_in">print</span>(fake.date_this_year())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_ad())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_between())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_between_dates())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_this_century())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_this_decade())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_this_month())</span><br><span class="line"><span class="built_in">print</span>(fake.date_time_this_year())</span><br><span class="line"><span class="built_in">print</span>(fake.day_of_month())</span><br><span class="line"><span class="built_in">print</span>(fake.day_of_week())</span><br><span class="line"><span class="built_in">print</span>(fake.future_date())</span><br><span class="line"><span class="built_in">print</span>(fake.future_datetime())</span><br><span class="line"><span class="built_in">print</span>(fake.iso8601())</span><br><span class="line"><span class="built_in">print</span>(fake.month())</span><br><span class="line"><span class="built_in">print</span>(fake.month_name())</span><br><span class="line"><span class="built_in">print</span>(fake.past_date())</span><br><span class="line"><span class="built_in">print</span>(fake.past_datetime())</span><br><span class="line"><span class="built_in">print</span>(fake.pytimezone())</span><br><span class="line"><span class="built_in">print</span>(fake.time())</span><br><span class="line"><span class="built_in">print</span>(fake.time_delta())</span><br><span class="line"><span class="built_in">print</span>(fake.time_object())</span><br><span class="line"><span class="built_in">print</span>(fake.time_series())</span><br><span class="line"><span class="built_in">print</span>(fake.timezone())</span><br><span class="line"><span class="built_in">print</span>(fake.unix_time())</span><br><span class="line"><span class="built_in">print</span>(fake.year())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 58、文件相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.file_extension())</span><br><span class="line"><span class="built_in">print</span>(fake.file_extension(category=<span class="string">&#x27;image&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_name(category=<span class="string">&#x27;audio&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_name(extension=<span class="string">&#x27;abcdef&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_name(category=<span class="string">&#x27;audio&#x27;</span>, extension=<span class="string">&#x27;abcdef&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_path(depth=<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_path(depth=<span class="number">5</span>, category=<span class="string">&#x27;video&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.file_path(depth=<span class="number">5</span>, category=<span class="string">&#x27;video&#x27;</span>, extension=<span class="string">&#x27;abcdef&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.mime_type())</span><br><span class="line"><span class="built_in">print</span>(fake.mime_type(category=<span class="string">&#x27;application&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.unix_device())</span><br><span class="line"><span class="built_in">print</span>(fake.unix_device(prefix=<span class="string">&#x27;mmcblk&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.unix_partition())</span><br><span class="line"><span class="built_in">print</span>(fake.unix_partition(prefix=<span class="string">&#x27;mmcblk&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 59、陆地坐标数据</span></span><br><span class="line"><span class="built_in">print</span>(fake.coordinate())</span><br><span class="line"><span class="built_in">print</span>(fake.latitude())</span><br><span class="line"><span class="built_in">print</span>(fake.latlng())</span><br><span class="line"><span class="built_in">print</span>(fake.local_latlng())</span><br><span class="line"><span class="built_in">print</span>(fake.location_on_land())</span><br><span class="line"><span class="built_in">print</span>(fake.longitude())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 60、因特网相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.ascii_company_email()) <span class="comment"># 邮箱</span></span><br><span class="line"><span class="built_in">print</span>(fake.ascii_email())  <span class="comment"># ascii邮箱</span></span><br><span class="line"><span class="built_in">print</span>(fake.ascii_free_email())</span><br><span class="line"><span class="built_in">print</span>(fake.ascii_safe_email())</span><br><span class="line"><span class="built_in">print</span>(fake.company_email())  <span class="comment"># 公司邮箱</span></span><br><span class="line"><span class="built_in">print</span>(fake.dga())  <span class="comment"># 网址</span></span><br><span class="line"><span class="built_in">print</span>(fake.domain_name())  <span class="comment"># 网址</span></span><br><span class="line"><span class="built_in">print</span>(fake.domain_word())</span><br><span class="line"><span class="built_in">print</span>(fake.email())</span><br><span class="line"><span class="built_in">print</span>(fake.free_email())</span><br><span class="line"><span class="built_in">print</span>(fake.free_email_domain())</span><br><span class="line"><span class="built_in">print</span>(fake.hostname())</span><br><span class="line"><span class="built_in">print</span>(fake.http_method())  <span class="comment"># http请求方法</span></span><br><span class="line"><span class="built_in">print</span>(fake.iana_id())  <span class="comment"># IANA注册ID</span></span><br><span class="line"><span class="built_in">print</span>(fake.ipv4())  <span class="comment"># 随机ip</span></span><br><span class="line"><span class="built_in">print</span>(fake.ipv4_network_class())  <span class="comment"># 网络类别</span></span><br><span class="line"><span class="built_in">print</span>(fake.ipv4_private())</span><br><span class="line"><span class="built_in">print</span>(fake.ipv4_public())</span><br><span class="line"><span class="built_in">print</span>(fake.ipv6())</span><br><span class="line"><span class="built_in">print</span>(fake.mac_address())  <span class="comment"># mac地址</span></span><br><span class="line"><span class="built_in">print</span>(fake.nic_handle())  <span class="comment"># 网卡处理ID</span></span><br><span class="line"><span class="built_in">print</span>(fake.nic_handles())</span><br><span class="line"><span class="built_in">print</span>(fake.port_number())  <span class="comment"># 端口号</span></span><br><span class="line"><span class="built_in">print</span>(fake.ripe_id())  <span class="comment"># 组织ID</span></span><br><span class="line"><span class="built_in">print</span>(fake.safe_domain_name()) <span class="comment"># 域名</span></span><br><span class="line"><span class="built_in">print</span>(fake.safe_email())  <span class="comment"># 邮箱</span></span><br><span class="line"><span class="built_in">print</span>(fake.slug())  <span class="comment"># Django算法</span></span><br><span class="line"><span class="built_in">print</span>(fake.tld())  <span class="comment"># 域名后缀</span></span><br><span class="line"><span class="built_in">print</span>(fake.uri())  <span class="comment"># http请求路径</span></span><br><span class="line"><span class="built_in">print</span>(fake.uri_extension())</span><br><span class="line"><span class="built_in">print</span>(fake.uri_page())  <span class="comment"># 请求页面名</span></span><br><span class="line"><span class="built_in">print</span>(fake.uri_path())  <span class="comment"># 资源路径</span></span><br><span class="line"><span class="built_in">print</span>(fake.url())  <span class="comment"># url</span></span><br><span class="line"><span class="built_in">print</span>(fake.user_name())  <span class="comment"># 用户名</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 61、isbn规则相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.isbn10())</span><br><span class="line"><span class="built_in">print</span>(fake.isbn13())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 62、工作的职位名称</span></span><br><span class="line"><span class="built_in">print</span>(fake.job())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 63、文章相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.paragraph(nb_sentences=<span class="number">5</span>)) <span class="comment"># 生成段落</span></span><br><span class="line"><span class="built_in">print</span>(fake.paragraph(nb_sentences=<span class="number">5</span>, variable_nb_sentences=<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.paragraph(nb_sentences=<span class="number">5</span>, ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.paragraph(nb_sentences=<span class="number">5</span>, variable_nb_sentences=<span class="literal">False</span>, ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.paragraphs(nb=<span class="number">5</span>))  <span class="comment"># 生成段落list</span></span><br><span class="line"><span class="built_in">print</span>(fake.sentence(nb_words=<span class="number">10</span>))  <span class="comment"># 生成一个句子</span></span><br><span class="line"><span class="built_in">print</span>(fake.sentence(nb_words=<span class="number">10</span>, variable_nb_words=<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.sentences())  <span class="comment"># 生成句子list</span></span><br><span class="line"><span class="built_in">print</span>(fake.sentences(nb=<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.text(max_nb_chars=<span class="number">20</span>))  <span class="comment"># 文本字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.text(max_nb_chars=<span class="number">80</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.text(max_nb_chars=<span class="number">160</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.text(ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.texts(nb_texts=<span class="number">5</span>))  <span class="comment"># 文本字符串列表</span></span><br><span class="line"><span class="built_in">print</span>(fake.texts(nb_texts=<span class="number">5</span>, max_nb_chars=<span class="number">50</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.texts(nb_texts=<span class="number">5</span>, max_nb_chars=<span class="number">50</span>, ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.word())  <span class="comment"># 词语字符串</span></span><br><span class="line"><span class="built_in">print</span>(fake.word(ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.words())  <span class="comment"># 词语列表</span></span><br><span class="line"><span class="built_in">print</span>(fake.words(nb=<span class="number">5</span>, ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(fake.words(nb=<span class="number">4</span>, ext_word_list=[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>], unique=<span class="literal">True</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 数据类型相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.binary(length=<span class="number">64</span>))  <span class="comment"># 创建字节</span></span><br><span class="line"><span class="built_in">print</span>(fake.boolean(chance_of_getting_true=<span class="number">75</span>))  <span class="comment"># 布尔类型</span></span><br><span class="line"><span class="built_in">print</span>(fake.csv(header=(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Address&#x27;</span>, <span class="string">&#x27;Favorite Color&#x27;</span>), data_columns=(<span class="string">&#x27;&#123;&#123;name&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;address&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;safe_color_name&#125;&#125;&#x27;</span>), num_rows=<span class="number">10</span>, include_row_ids=<span class="literal">True</span>))  <span class="comment"># 生成随机的逗号分隔值</span></span><br><span class="line"><span class="built_in">print</span>(fake.dsv(data_columns=(<span class="string">&#x27;&#123;&#123;name&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;address&#125;&#125;&#x27;</span>), num_rows=<span class="number">5</span>, delimiter=<span class="string">&#x27;$&#x27;</span>))  <span class="comment"># 生成随机分隔符分隔值。</span></span><br><span class="line"><span class="built_in">print</span>(fake.fixed_width(data_columns=[(<span class="number">20</span>, <span class="string">&#x27;name&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;pyint&#x27;</span>, &#123;<span class="string">&#x27;min_value&#x27;</span>:<span class="number">50</span>, <span class="string">&#x27;max_value&#x27;</span>:<span class="number">100</span>&#125;)], align=<span class="string">&#x27;right&#x27;</span>, num_rows=<span class="number">2</span>))  <span class="comment"># 生成随机固定宽度值</span></span><br><span class="line"><span class="built_in">print</span>(fake.image(size=(<span class="number">16</span>, <span class="number">16</span>), hue=[<span class="number">90</span>, <span class="number">270</span>], image_format=<span class="string">&#x27;ico&#x27;</span>))  <span class="comment"># 使用Python图像库生成一张图片并在上面绘制一个随机的多边形。如果没有安装它，这个提供程序将无法运行。以给定格式返回表示图像的字节。</span></span><br><span class="line"><span class="built_in">print</span>(fake.json(data_columns=[(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>), (<span class="string">&#x27;Points&#x27;</span>, <span class="string">&#x27;pyint&#x27;</span>, &#123;<span class="string">&#x27;min_value&#x27;</span>:<span class="number">50</span>, <span class="string">&#x27;max_value&#x27;</span>:<span class="number">100</span>&#125;)], num_rows=<span class="number">1</span>))  <span class="comment"># 生成随机的JSON结构值</span></span><br><span class="line"><span class="built_in">print</span>(fake.md5(raw_output=<span class="literal">False</span>))  <span class="comment"># 生成MD5数据</span></span><br><span class="line"><span class="built_in">print</span>(fake.null_boolean())  <span class="comment"># 生成空值或布尔值</span></span><br><span class="line"><span class="built_in">print</span>(fake.password(length=<span class="number">12</span>))  <span class="comment"># 生成密码</span></span><br><span class="line"><span class="built_in">print</span>(fake.password(length=<span class="number">40</span>, special_chars=<span class="literal">False</span>, upper_case=<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.psv(header=(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Address&#x27;</span>, <span class="string">&#x27;Favorite Color&#x27;</span>), data_columns=(<span class="string">&#x27;&#123;&#123;name&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;address&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;safe_color_name&#125;&#125;&#x27;</span>), num_rows=<span class="number">10</span>, include_row_ids=<span class="literal">True</span>))  <span class="comment"># 生成随机的管道分隔值</span></span><br><span class="line"><span class="built_in">print</span>(fake.sha1(raw_output=<span class="literal">False</span>))  <span class="comment"># 生成一个随机的SHA1哈希</span></span><br><span class="line"><span class="built_in">print</span>(fake.sha256(raw_output=<span class="literal">False</span>))  <span class="comment"># 生成一个随机的SHA256哈希</span></span><br><span class="line"><span class="built_in">print</span>(fake.tar(uncompressed_size=<span class="number">256</span>, num_files=<span class="number">32</span>, min_file_size=<span class="number">4</span>, compression=<span class="string">&#x27;bz2&#x27;</span>))  <span class="comment"># 生成包含一个随机有效tar文件的字节对象。</span></span><br><span class="line"><span class="built_in">print</span>(fake.tsv(header=(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Address&#x27;</span>, <span class="string">&#x27;Favorite Color&#x27;</span>), data_columns=(<span class="string">&#x27;&#123;&#123;name&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;address&#125;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#123;safe_color_name&#125;&#125;&#x27;</span>), num_rows=<span class="number">10</span>, include_row_ids=<span class="literal">True</span>))  <span class="comment"># 生成随机的制表符分隔值</span></span><br><span class="line"><span class="built_in">print</span>(fake.uuid4())  <span class="comment"># 如果使用可调用对象指定，则生成一个随机UUID4对象并将其转换为另一种类型</span></span><br><span class="line"><span class="built_in">print</span>(fake.uuid4(cast_to=<span class="literal">None</span>))</span><br><span class="line"><span class="built_in">print</span>(fake.<span class="built_in">zip</span>(uncompressed_size=<span class="number">256</span>, num_files=<span class="number">32</span>, min_file_size=<span class="number">4</span>, compression=<span class="string">&#x27;bz2&#x27;</span>))  <span class="comment"># 生成包含一个随机有效的zip归档文件的bytes对象。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 人相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.first_name())  <span class="comment"># 人名</span></span><br><span class="line"><span class="built_in">print</span>(fake.first_name_female())  <span class="comment"># 女名</span></span><br><span class="line"><span class="built_in">print</span>(fake.first_name_male())  <span class="comment"># 男名</span></span><br><span class="line"><span class="built_in">print</span>(fake.first_name_nonbinary())</span><br><span class="line"><span class="built_in">print</span>(fake.language_name())</span><br><span class="line"><span class="built_in">print</span>(fake.last_name())</span><br><span class="line"><span class="built_in">print</span>(fake.last_name_female())</span><br><span class="line"><span class="built_in">print</span>(fake.last_name_male())</span><br><span class="line"><span class="built_in">print</span>(fake.last_name_nonbinary())</span><br><span class="line"><span class="built_in">print</span>(fake.name())</span><br><span class="line"><span class="built_in">print</span>(fake.name_female())</span><br><span class="line"><span class="built_in">print</span>(fake.name_male())</span><br><span class="line"><span class="built_in">print</span>(fake.name_nonbinary())</span><br><span class="line"><span class="built_in">print</span>(fake.prefix())</span><br><span class="line"><span class="built_in">print</span>(fake.prefix_female())</span><br><span class="line"><span class="built_in">print</span>(fake.prefix_male())</span><br><span class="line"><span class="built_in">print</span>(fake.prefix_nonbinary())</span><br><span class="line"><span class="built_in">print</span>(fake.suffix())</span><br><span class="line"><span class="built_in">print</span>(fake.suffix_female())</span><br><span class="line"><span class="built_in">print</span>(fake.suffix_male())</span><br><span class="line"><span class="built_in">print</span>(fake.suffix_nonbinary())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 电话号码相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.country_calling_code())  <span class="comment"># 区号</span></span><br><span class="line"><span class="built_in">print</span>(fake.msisdn())</span><br><span class="line"><span class="built_in">print</span>(fake.phone_number())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 个人信息相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.profile())</span><br><span class="line"><span class="built_in">print</span>(fake.simple_profile())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># python相关（python数据类型）</span></span><br><span class="line"><span class="built_in">print</span>(fake.pybool())</span><br><span class="line"><span class="built_in">print</span>(fake.pydecimal())</span><br><span class="line"><span class="built_in">print</span>(fake.pydict())</span><br><span class="line"><span class="built_in">print</span>(fake.pyfloat())</span><br><span class="line"><span class="built_in">print</span>(fake.pyint())</span><br><span class="line"><span class="built_in">print</span>(fake.pyiterable())</span><br><span class="line"><span class="built_in">print</span>(fake.pylist())</span><br><span class="line"><span class="built_in">print</span>(fake.pyset())</span><br><span class="line"><span class="built_in">print</span>(fake.pystr())</span><br><span class="line"><span class="built_in">print</span>(fake.pystr_format())</span><br><span class="line"><span class="built_in">print</span>(fake.pystruct())</span><br><span class="line"><span class="built_in">print</span>(fake.pytuple())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># ssn</span></span><br><span class="line"><span class="built_in">print</span>(fake.ssn())  <span class="comment"># 865-50-6891</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 默认用户代理相关、认证信息相关、通行证相关</span></span><br><span class="line"><span class="built_in">print</span>(fake.android_platform_token())</span><br><span class="line"><span class="built_in">print</span>(fake.chrome())</span><br><span class="line"><span class="built_in">print</span>(fake.firefox())</span><br><span class="line"><span class="built_in">print</span>(fake.internet_explorer())</span><br><span class="line"><span class="built_in">print</span>(fake.ios_platform_token())</span><br><span class="line"><span class="built_in">print</span>(fake.linux_platform_token())</span><br><span class="line"><span class="built_in">print</span>(fake.linux_processor())</span><br><span class="line"><span class="built_in">print</span>(fake.mac_platform_token())</span><br><span class="line"><span class="built_in">print</span>(fake.mac_processor())</span><br><span class="line"><span class="built_in">print</span>(fake.opera())</span><br><span class="line"><span class="built_in">print</span>(fake.safari())</span><br><span class="line"><span class="built_in">print</span>(fake.user_agent())</span><br><span class="line"><span class="built_in">print</span>(fake.windows_platform_token())</span><br></pre></td></tr></table></figure>

<h3 id="Faker-测试"><a href="#Faker-测试" class="headerlink" title="Faker 测试"></a>Faker 测试</h3><p>​		1）faker将数据导入数据库中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql.cursors</span><br><span class="line"><span class="comment">#pip install pymysql</span></span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line">fk = Faker(locale=<span class="string">&quot;zh_CN&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQLFaker</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>://可能连接失败，放入<span class="keyword">try</span> <span class="keyword">except</span>中处理异常</span><br><span class="line">            self.db = pymysql.connect(		<span class="comment"># 连接数据库信息</span></span><br><span class="line">                host=<span class="string">&quot;**.**.**.**&quot;</span>,</span><br><span class="line">                port=<span class="number">3306</span>,</span><br><span class="line">                user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">                password=<span class="string">&quot;password&quot;</span>,</span><br><span class="line">                database=<span class="string">&quot;test&quot;</span>,</span><br><span class="line">                charset=<span class="string">&quot;utf8mb4&quot;</span>)  <span class="comment">#在mysql中，utf8默认指的是utf8mb3，即使用1-3个字节表示一个字符；正常来说utf8也就是最大使用3个字节的utf8mb3已经够用了，但是为了存储4个字节场景下的字符如emoji表情，就需要用到4个字节编码的utf8，也就是utf8mb4。其中mb4的含义为：most bytes 4，也就是最大4字节。</span></span><br><span class="line">        <span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;连接数据库失败！<span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.cursor = self.db.cursor()  	<span class="comment"># 使用cursor()方法创建一个游标对象，用于操作数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createDabate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sql = <span class="string">&quot;&quot;&quot;CREATE TABLE `employees` (  </span></span><br><span class="line"><span class="string">                    `userid` varchar(50) UNIQUE COMMENT &#x27;员工id&#x27;,</span></span><br><span class="line"><span class="string">                    `ename` VARCHAR (50) NOT NULL COMMENT &#x27;姓名&#x27;,</span></span><br><span class="line"><span class="string">                    `username` VARCHAR (20) NOT NULL COMMENT &#x27;用户名&#x27;,</span></span><br><span class="line"><span class="string">                    `password` VARCHAR (50) NOT NULL COMMENT &#x27;登录密码&#x27;,</span></span><br><span class="line"><span class="string">                    `gender` VARCHAR (50) DEFAULT &#x27;-1&#x27; COMMENT &#x27;1表示男，0表示女，-1表示未知&#x27;,</span></span><br><span class="line"><span class="string">                    `IDNum` VARCHAR (50) NOT NULL UNIQUE COMMENT &#x27;身份ID&#x27;,</span></span><br><span class="line"><span class="string">                    `phoneNum` VARCHAR (50) NOT NULL COMMENT &#x27;手机号码&#x27;,</span></span><br><span class="line"><span class="string">                    `email` VARCHAR (50) COMMENT &#x27;邮箱&#x27;,</span></span><br><span class="line"><span class="string">                    `birthday` DATE COMMENT &#x27;生日&#x27;,</span></span><br><span class="line"><span class="string">                    `createtime` DATETIME COMMENT &#x27;创建时间&#x27;</span></span><br><span class="line"><span class="string">                    ) DEFAULT CHARSET = utf8mb4 COMMENT = &#x27;员工信息表&#x27;&quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment">#多行字符串，常用于注释</span></span><br><span class="line">            <span class="comment">#写啥都行，不会报错</span></span><br><span class="line">            self.cursor.execute(sql)  			 <span class="comment"># 执行SQL语句，创建数据表</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;employees表创建成功！&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(e).split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>] == <span class="string">&quot;(1050&quot;</span>:  //提取错误码</span><br><span class="line">            //可根据对应的报错信息自己自定义</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;employees表已存在，将尝试直接插入数据！&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;创建数据表失败！<span class="subst">&#123;e&#125;</span>&#x27;</span>)  		<span class="comment"># 否则抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertFakedata</span>(<span class="params">self, num</span>):  //插入数据</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">                sql = <span class="string">&quot;&quot;&quot;INSERT INTO `employees` VALUES(&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;&quot;&quot;</span> % (  //字符串的拼接</span><br><span class="line">                    fk.uuid4(),                     <span class="comment"># 用户id</span></span><br><span class="line">                    fk.name(),                      <span class="comment"># 用户姓名</span></span><br><span class="line">                    fk.user_name(),                 <span class="comment"># 用户名</span></span><br><span class="line">                    fk.password(),                  <span class="comment"># 密码</span></span><br><span class="line">                    fk.random_int(<span class="built_in">min</span>=-<span class="number">1</span>, <span class="built_in">max</span>=<span class="number">1</span>),   <span class="comment"># 性别  //用对应的数字表示男女</span></span><br><span class="line">                    fk.ssn(),                       <span class="comment"># 身份ID</span></span><br><span class="line">                    fk.phone_number(),              <span class="comment"># 手机号码</span></span><br><span class="line">                    fk.free_email(),                <span class="comment"># 邮箱</span></span><br><span class="line">                    fk.date_of_birth(minimum_age=<span class="number">20</span>, maximum_age=<span class="number">30</span>)    <span class="comment"># 生日，20~30岁之间</span></span><br><span class="line">                    fk.date_time_between_dates()	<span class="comment"># 创建时间</span></span><br><span class="line">                )</span><br><span class="line">                self.cursor.execute(sql)	<span class="comment"># 执行SQL语句，插入数据</span></span><br><span class="line">                self.db.commit()  			<span class="comment"># 提交插入的数据，若缺少即使执行成功，数据库也不会显示数据</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;成功插入<span class="subst">&#123;num&#125;</span>条数据！&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;插入数据失败！<span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.cursor.close()  				<span class="comment"># 关闭游标对象</span></span><br><span class="line">        self.db.close()  					<span class="comment"># 关闭数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    SQLFaker().createDabate()  				<span class="comment"># 执行创建数据库</span></span><br><span class="line">    SQLFaker().insertFakedata(<span class="number">500</span>)			<span class="comment"># 执行插入500条数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		2）faker将数据导入excel中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建test4.py</span></span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> Font, PatternFill</span><br><span class="line"><span class="keyword">from</span> openpyxl.utils <span class="keyword">import</span> get_column_letter</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles.alignment <span class="keyword">import</span> Alignment</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles.borders <span class="keyword">import</span> Border, Side</span><br><span class="line"></span><br><span class="line">fk = Faker(<span class="string">&quot;zh_CN&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_to_excel</span>():</span><br><span class="line">    wb = load_workbook(<span class="string">&quot;E:/Fakerdata.xlsx&quot;</span>)  	<span class="comment"># 打开Excel文件</span></span><br><span class="line">    sheet = wb[wb.sheetnames[<span class="number">0</span>]]  				<span class="comment"># 选择表1</span></span><br><span class="line">    <span class="comment"># 随机生成1000条数据，同时设置单元格样式</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(excel_header)):</span><br><span class="line">            <span class="built_in">id</span> = fk.random_number(digits=<span class="number">5</span>)  <span class="comment"># 随机生成5位数</span></span><br><span class="line">            name = fk.name()  				 <span class="comment"># 随机生成姓名</span></span><br><span class="line">            ssn = fk.ssn()  				 <span class="comment"># 随机生成身份ID</span></span><br><span class="line">            phone = fk.phone_number()  		 <span class="comment"># 随机生成手机号</span></span><br><span class="line">            email = fk.email()  			 <span class="comment"># 随机生成邮箱</span></span><br><span class="line">            company = fk.company()  		 <span class="comment"># 随机生成公司名称</span></span><br><span class="line">            status = fk.words(ext_word_list=[<span class="string">&quot;在职&quot;</span>, <span class="string">&quot;已离职&quot;</span>], nb=<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># 在指定两个字中随机选择一个</span></span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">1</span>, value=<span class="built_in">id</span>)</span><br><span class="line">            <span class="comment">#第几行，第几列，对应的值</span></span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">2</span>, value=name)</span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">3</span>, value=ssn)</span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">4</span>, value=phone)</span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">5</span>, value=email)</span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">6</span>, value=company)</span><br><span class="line">            sheet.cell(row=i + <span class="number">2</span>, column=<span class="number">7</span>, value=status)</span><br><span class="line">    wb.save(<span class="string">&quot;E:/Fakerdata.xlsx&quot;</span>)  <span class="comment"># 保存Excel文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    save_to_excel()</span><br><span class="line"><span class="comment">#可优先设置好格式信息，直接插入数据即可</span></span><br></pre></td></tr></table></figure>

<p>​		3）faker作数据驱动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将数据先封装成对应的列表list，然后使用装饰器传入即可</span></span><br><span class="line"><span class="comment">#或者直接将对应的值改成faker生成的数据</span></span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line">out=[]</span><br><span class="line">faker=Faker(locale=<span class="string">&quot;zh_Cn&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">list</span>=[]</span><br><span class="line">    <span class="built_in">list</span>.append(faker.name())</span><br><span class="line">    <span class="built_in">list</span>.append(faker.random_int(<span class="built_in">min</span>=<span class="number">0</span>,<span class="built_in">max</span>=<span class="number">100</span>))</span><br><span class="line">    out.append(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestDDT</span>:</span><br><span class="line"><span class="meta">    @pytest.mark.parametrize(<span class="params"><span class="string">&#x27;name,age&#x27;</span>,out</span>) //数据驱动</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testFaker</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="built_in">print</span>(name,age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>faker</tag>
        <tag>测试</tag>
        <tag>测试数据</tag>
      </tags>
  </entry>
  <entry>
    <title>接口自动化测试---进阶</title>
    <url>/2023/12/02/2023-12-01-%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95---%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<a href="/2023/11/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80/" title="接口自动化测试---基础">接口自动化测试---基础</a>中讲解了接口自动化测试的基础，现在简单了解下接口测试中的一些复杂测试问题。

<h2 id="接口鉴权"><a href="#接口鉴权" class="headerlink" title="接口鉴权"></a>接口鉴权</h2><p>判断当前接口是否有访问的权限。（未登录不能访问一些接口信息等）<span id="more"></span></p>
<h3 id="Cookie鉴权"><a href="#Cookie鉴权" class="headerlink" title="Cookie鉴权"></a>Cookie鉴权</h3><p>服务端在响应客户端请求的时候，会向客户端推送一个 Cookie，这个 Cookie 记录服务端上面的一些信息，客户端在后续的请求中携带这个 Cookie，服务端可以根据这个 Cookie 判断该请求的上下文关系。</p>
<p>特点：</p>
<ul>
<li><strong>Cookie存储在客户端，使得可以跨页面访问</strong>，比较方便。但可随意篡改，不安全</li>
<li>Cookie机制实现简单，只需要服务器端向客户端发送Set-Cookie即可完成鉴权，不需要过多的复杂设置。</li>
<li>它的内容会随着 http 交互传接，影响性能，所以 Cookie 可存储的数据不能过大，最大为 4kb</li>
<li>一个浏览器对于一个网站只能存不超过 20 个 Cookie，而浏览器一般只允许存放 300 个 Cookie</li>
<li>移动端对 Cookie 支持不友好</li>
<li>一般情况下存储的是纯文本，对象需要序列化之后才可以存储，解析需要反序列化</li>
</ul>
<h3 id="Session鉴权"><a href="#Session鉴权" class="headerlink" title="Session鉴权"></a>Session鉴权</h3><p>Session机制是在Cookie的基础上实现的，服务器会生成一个唯一的Session ID，并将这个ID存储在Cookie中发送给客户端。当客户端发送请求时，服务器会验证这个Session ID是否有效，如果有效，则允许访问资源。</p>
<p>特点：</p>
<ul>
<li>安全性较高：Session机制可以避免Cookie伪造带来的安全问题，对于非法用户访问也可以做出相应的控制。</li>
<li>可靠性高: <strong>服务器端存储Session数据</strong>，保证了Session数据的可靠性，避免了Cookie被篡改带来的问题。</li>
<li>维护负担大：由于Session存储在服务器端，需要服务器端定期清理过期的Session数据，从而增加了服务器的负担。</li>
<li>扩展性差：在分布式系统中，Session机制需要额外的处理来确保多台服务器之间的Session共享，从而降低了扩展性。</li>
<li>依赖 Cookie，用户可以在浏览器端禁用 Cookie</li>
<li>不支持跨端兼容 app 等</li>
</ul>
<h3 id="Token鉴权"><a href="#Token鉴权" class="headerlink" title="Token鉴权"></a>Token鉴权</h3><p>服务端不保存 sessionId。Token机制在认证成功后，服务端会签发一个令牌(Token)，以后每次请求都要带上这个Token，服务端通过校验这个Token来判断当前的请求是否合法。</p>
<p>特点：</p>
<ul>
<li>跨平台支持：Token机制不依赖于浏览器和Cookie，支持各种客户端平台，如iOS、Android等。</li>
<li>扩展性好：Token机制实现了无状态化，避免了Session的负担，更容易扩展。</li>
<li>安全性需要考虑：Token机制需要考虑密钥的安全性，如果密钥泄露，则会导致令牌被伪造，从而导致鉴权失效。</li>
<li>兼容性差：虽然Token机制可以支持跨域访问，但是它需要额外的处理来确保在不同的请求之间传递Token，从而影响了API的易用性。详情请点击<a href="/2023/12/02/token%E9%89%B4%E6%9D%83---JWT%E4%BB%A4%E7%89%8C/" title="token鉴权---JWT令牌">token鉴权---JWT令牌</a></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>登录接口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,jsonpath</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;application&quot;</span>:<span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;applicaiton_client_type&quot;</span>:<span class="string">&quot;weixin&quot;</span> </span><br><span class="line">&#125;<span class="comment">#请求参数</span></span><br><span class="line"></span><br><span class="line">data = &#123; <span class="comment">#date数据，即请求体数据，请求方式为post</span></span><br><span class="line">    <span class="string">&quot;accounts&quot;</span>:<span class="string">&quot;huace_xm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span>:<span class="number">123456</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;username&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">rs = requests.request(url=<span class="string">&quot;http://shop-xo.hctestedu.com/index.php?s=api/user/login&quot;</span>,<span class="comment">#请求路径</span></span><br><span class="line">                 method=<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                 params=params,<span class="comment">#路径参数</span></span><br><span class="line">                 data=data) <span class="comment"># 这就是发请求 ,括号里填四要素 --怎么确定接口地址？四要素是什么？</span></span><br><span class="line"><span class="comment"># print(rs.text)</span></span><br><span class="line"><span class="comment"># 拿出来做成一个变量？</span></span><br><span class="line"><span class="built_in">print</span>(rs.json())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出，登陆成功</span></span><br><span class="line"><span class="string">&#123;&#x27;msg&#x27;: &#x27;登录成功&#x27;, &#x27;code&#x27;: 0, &#x27;data&#x27;: &#123;&#x27;id&#x27;: &#x27;19898&#x27;, &#x27;username&#x27;: &#x27;huace_xm&#x27;, &#x27;nickname&#x27;: &#x27;&#x27;, &#x27;mobile&#x27;: &#x27;&#x27;, &#x27;email&#x27;: &#x27;&#x27;, &#x27;avatar&#x27;: &#x27;http://shop-xo.hctestedu.com/static/index/default/images/default-user-avatar.jpg&#x27;, &#x27;alipay_openid&#x27;: &#x27;&#x27;, &#x27;weixin_openid&#x27;: &#x27;&#x27;, &#x27;weixin_unionid&#x27;: &#x27;&#x27;, &#x27;weixin_web_openid&#x27;: &#x27;&#x27;, &#x27;baidu_openid&#x27;: &#x27;&#x27;, &#x27;toutiao_openid&#x27;: &#x27;&#x27;, &#x27;qq_openid&#x27;: &#x27;&#x27;, &#x27;qq_unionid&#x27;: &#x27;&#x27;, &#x27;integral&#x27;: &#x27;0&#x27;, &#x27;locking_integral&#x27;: &#x27;0&#x27;, &#x27;referrer&#x27;: &#x27;0&#x27;, &#x27;add_time&#x27;: &#x27;1669790543&#x27;, &#x27;add_time_text&#x27;: &#x27;2022-11-30 14:42:23&#x27;, &#x27;mobile_security&#x27;: &#x27;&#x27;, &#x27;email_security&#x27;: &#x27;&#x27;, &#x27;user_name_view&#x27;: &#x27;huace_xm&#x27;, &#x27;is_mandatory_bind_mobile&#x27;: 0, &#x27;token&#x27;: &#x27;88c06b3b23dd615cab4a0221d69ea637&#x27;&#125;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>收藏商品：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,jsonpath</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;application&quot;</span>:<span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;applicaiton_client_type&quot;</span>:<span class="string">&quot;weixin&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line">data2 = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;12&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">rs1 = requests.request(url=<span class="string">&quot;http://shop-xo.hctestedu.com/index.php?s=api/goods/favor&quot;</span>,</span><br><span class="line">                       <span class="comment">#请求路径</span></span><br><span class="line">                 method=<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                 params=params,</span><br><span class="line">                 data=data2) <span class="comment"># 这就是发请求 ,括号里填四要素 --怎么确定接口地址？四要素是什么？</span></span><br><span class="line"><span class="built_in">print</span>(rs1.json())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">&#123;&#x27;msg&#x27;: &#x27;登录失效，请重新登录&#x27;, &#x27;code&#x27;: -400, &#x27;data&#x27;: &#x27;&#x27;&#125;</span></span><br><span class="line"><span class="string">未进行接口鉴权，导致不能收藏商品</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进行接口鉴权</span></span><br><span class="line"><span class="keyword">import</span> requests,jsonpath</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;application&quot;</span>:<span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;applicaiton_client_type&quot;</span>:<span class="string">&quot;weixin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;accounts&quot;</span>:<span class="string">&quot;huace_xm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span>:<span class="number">123456</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;username&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">rs = requests.request(url=<span class="string">&quot;http://shop-xo.hctestedu.com/index.php?s=api/user/login&quot;</span>,</span><br><span class="line">                 method=<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                 params=params,</span><br><span class="line">                 data=data) <span class="comment"># 这就是发请求 ,括号里填四要素 --怎么确定接口地址？四要素是什么？</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rs.json())</span><br><span class="line"><span class="comment">#仔细观看登录成功后。返会的结果中含有token项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(rs.json()[&quot;data&quot;][&quot;token&quot;])</span></span><br><span class="line">token = rs.json()[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;token&quot;</span>]<span class="comment">#直接准确提出出token的值</span></span><br><span class="line">token1 = jsonpath.jsonpath(rs.json(),<span class="string">&quot;$..token&quot;</span>)</span><br><span class="line"><span class="comment">#不知道token的值具体在哪时，使用$..token</span></span><br><span class="line"><span class="comment">#肯定会提取出含有token的值，结果为一个列表。</span></span><br><span class="line"></span><br><span class="line">data2 = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;12&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">rs1 = requests.request(url=<span class="string">&quot;http://shop-xo.hctestedu.com/index.php?s=api/goods/favor?token=&quot;</span>+token1[<span class="number">0</span>],<span class="comment">#传入对应的token</span></span><br><span class="line">                 method=<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                 params=params,</span><br><span class="line">                 data=data2) <span class="comment"># 这就是发请求 ,括号里填四要素 --怎么确定接口地址？四要素是什么？</span></span><br><span class="line"><span class="built_in">print</span>(rs1.json())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">&#123;&#x27;msg&#x27;: &#x27;取消成功&#x27;, &#x27;code&#x27;: 0, &#x27;data&#x27;: &#123;&#x27;text&#x27;: &#x27;收藏&#x27;, &#x27;status&#x27;: 0, &#x27;count&#x27;: 49&#125;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#说明</span></span><br><span class="line"><span class="comment">#使用jsonpath需要导入对应的包，同时还需要在虚拟环境中下载安装</span></span><br><span class="line">pip install jsonpath  <span class="comment">#安装</span></span><br><span class="line">jsonpath --version   <span class="comment">#检查</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">jsonpath语法：jsonpath只能提取json对象中的参数</span></span><br><span class="line"><span class="string">$表示最外层大括号</span></span><br><span class="line"><span class="string">.表示进一层</span></span><br><span class="line"><span class="string">提取token的准确语法为：$.data.token</span></span><br><span class="line"><span class="string">模糊语法为：$..token，注意结果为列表，需要再准确取值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#并不是所有的token都是放在路径参数里面的，这个主要由前后端开发师共同决定</span></span><br><span class="line"><span class="comment">#可以放在请求头中，路径参数中，也可放在请求体中（不能是get，delect方式，没有请求体）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正则表达式提取</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">out=<span class="string">&#x27;&#x27;&#x27;&#123;&#x27;msg&#x27;: &#x27;登录成功&#x27;,</span></span><br><span class="line"><span class="string">&#x27;code&#x27;: 0, </span></span><br><span class="line"><span class="string">&#x27;data&#x27;: &#123;&#x27;id&#x27;: &#x27;19898&#x27;,  &#x27;token&#x27;: &#x27;54e66bcb250f172f92feee1440a79277&#x27;&#125;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">path=<span class="string">r&#x27;&#x27;&#x27;&#x27;token&#x27;: &#x27;(.+?)&#x27;&#125;&#125;&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(re.findall(path,out))</span><br><span class="line"><span class="comment">#将你想提取的值用(.+?)替换即可，别的直接复制粘贴</span></span><br></pre></td></tr></table></figure>


<h2 id="接口关联"><a href="#接口关联" class="headerlink" title="接口关联"></a>接口关联</h2><p>与接口鉴权类似。一个接口的参数需要使用上一个接口的一些参数。例如上一个接口生成了对应的订单 id，下个接口查询订单时需要使用到订单 id，故需要将其提取出来再传递给下个接口使用，提取方法类似上述。或者为了满足增删改查时<strong>业务闭环</strong>，执行一圈后数据库没有产生垃圾数据，也需要接口关联。</p>
<p>还是jsonpath与re的使用，即正则表达式的提取和json提取。</p>
<h2 id="接口加密"><a href="#接口加密" class="headerlink" title="接口加密"></a>接口加密</h2><p>系统明文传输的数据会被不明身份的人用抓包工具抓取，从而威胁系统和数据的<strong>安全性</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一般是对传输的数据进行加密，加密的方式有很多，具体看实际场景。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">测试时，若采用常规的方法进行加密，则可去对应的网站找取加密的密文，再传入接口中进行测试</span></span><br><span class="line"><span class="string">或者找开发要去加密的算法代码，进行调用后再传入对应的参数</span></span><br><span class="line"><span class="string">自己懂的，就自行编写对应的加密算法，加密后再传参</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>某些接口传入的数据是文件类型，再测试时需要先读出文件的信息，再将信息作为参数进行传参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span>  <span class="comment"># 上传文件接口</span></span><br><span class="line">files = &#123;</span><br><span class="line">    <span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;../file/test.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>),  <span class="comment"># 文件路径          </span></span><br><span class="line"> &#125;  <span class="comment"># =&gt; 打开上传文件并且加入文件相关参数</span></span><br><span class="line"> <span class="comment">#file是前端指定的需要传递的参数名。</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">#即先将文件读为二进制文件再进行传参</span></span><br><span class="line"><span class="comment">#传递的参数也是</span></span><br><span class="line"> <span class="comment"># data传入请求参数dict,files传入待上传文件参数dict</span></span><br><span class="line">r = requests.post(url, data=data, files=files)</span><br><span class="line"><span class="built_in">print</span>(r.json())</span><br></pre></td></tr></table></figure>

<h2 id="cookie关联"><a href="#cookie关联" class="headerlink" title="cookie关联"></a>cookie关联</h2><p>有些接口之间是存在着cookie关联的，即需要发送某些cookie信息才能进行访问该接口，类似cookie鉴权。</p>
<p>一种方式是在请求参数的时候，直接传入对应的cookie信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_login</span>(<span class="params">username,password</span>):</span><br><span class="line">    host=<span class="string">&#x27;http://localhost&#x27;</span></span><br><span class="line">    url=<span class="string">f&#x27;<span class="subst">&#123;host&#125;</span>/api/bbb/ccc&#x27;</span></span><br><span class="line">    payload=&#123;<span class="string">&#x27;username&#x27;</span>:username,</span><br><span class="line">             <span class="string">&#x27;password&#x27;</span>:password</span><br><span class="line">             &#125;</span><br><span class="line">    reps=requests.post(url,data=payload)</span><br><span class="line">    <span class="keyword">return</span> reps.cookies</span><br><span class="line"></span><br><span class="line">user_cookie= test_login(<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;12345678&#x27;</span>) <span class="comment">#调用函数获取返回值并赋值给user_cookie</span></span><br><span class="line">reps=requests.post(api_url,data=payload,cookies=user_cookie)<span class="comment">#直接在请求中加上cookies=user_cookie</span></span><br></pre></td></tr></table></figure>

<p>另一种方式是发送请求时，直接使用session的request方法。会自动关联所有请求的cookie信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先生成对应的session对象</span></span><br><span class="line">sess=requests.session();</span><br><span class="line"><span class="comment">#操作</span></span><br><span class="line"><span class="comment">#sess.request(url,param,data,**kwargs)</span></span><br><span class="line"><span class="comment">#可以使用对应的夹具函数，完成对session的初始化，同时使用单例模式，保证session的唯一性</span></span><br></pre></td></tr></table></figure>

<h2 id="总结–简单封装"><a href="#总结–简单封装" class="headerlink" title="总结–简单封装"></a>总结–简单封装</h2><h3 id="统一方法封装"><a href="#统一方法封装" class="headerlink" title="统一方法封装"></a>统一方法封装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RequestUtil</span>:</span><br><span class="line">    sess=requests.session();</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_requests</span>(<span class="params">self,**kwargs</span>):</span><br><span class="line">        res=RequestUtil.sess.request(**kwargs)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以进行统一的日志请求处理</span></span><br><span class="line"><span class="comment">#所有的请求调用的入口信息，统一的日志管理，不用在每个方法进行日志打印</span></span><br></pre></td></tr></table></figure>

<h3 id="接口关联封装"><a href="#接口关联封装" class="headerlink" title="接口关联封装"></a>接口关联封装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将提取的参数可写入yaml文件中，方便后续的使用（写入地方由自己定，看自己具体的需求）</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#写入,追加的方式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_Yaml</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.getcwd()+<span class="string">&quot;/yaml1.yaml&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>,mode=<span class="string">&quot;a+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment">#对应的yaml文件路径 ，编码格式，打开方式：追加</span></span><br><span class="line">        yaml.dump(data,stream=f,allow_unicode=<span class="literal">True</span>) <span class="comment">#写入yaml文件，写入对象为f，允许编码（不乱码）</span></span><br><span class="line"><span class="comment">#读取yaml文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_Yaml</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.getcwd()+<span class="string">&quot;/yaml1.yaml&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>,mode=<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment">#全部读取文件</span></span><br><span class="line">        value=yaml.load(f,yaml.FullLoader)</span><br><span class="line">        <span class="keyword">return</span> value[key]<span class="comment">#返回key为key的value值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#清空， 覆盖的方式</span></span><br><span class="line"><span class="comment">#在所有用例执行之前清空yaml文件</span></span><br><span class="line"><span class="comment">#夹具函数，在一次session之前，清空yaml文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear_Yaml</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.getcwd()+<span class="string">&quot;/yaml1.yaml&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>,mode=<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.truncate();<span class="comment">#清空yaml文件，防止产生废物数据</span></span><br></pre></td></tr></table></figure>

<h3 id="yaml数据驱动"><a href="#yaml数据驱动" class="headerlink" title="yaml数据驱动"></a>yaml数据驱动</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line">	<span class="attr">feature:</span> <span class="string">模块名</span></span><br><span class="line">	<span class="attr">story:</span> <span class="string">接口</span></span><br><span class="line">	<span class="attr">title:</span> <span class="string">用例标题</span></span><br><span class="line">	<span class="attr">request:</span> </span><br><span class="line">		<span class="attr">method:</span> <span class="string">请求方式</span></span><br><span class="line">		<span class="attr">url:</span> <span class="string">请求url</span></span><br><span class="line">		<span class="attr">headers:</span> <span class="string">请求头</span></span><br><span class="line">		<span class="attr">params:</span> <span class="string">请求参数</span></span><br><span class="line">		<span class="attr">json:</span> <span class="string">json参数</span></span><br><span class="line">	<span class="comment">#extract: 提取的数据</span></span><br><span class="line">	<span class="attr">vilidate:</span> <span class="string">请求断言</span>	</span><br><span class="line"><span class="comment">#需要的参数按需求自己添加	</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取yaml文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_Yaml_Testcase</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, encoding=<span class="string">&quot;utf-8&quot;</span>, mode=<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        value = yaml.load(f, yaml.FullLoader)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>测试</tag>
        <tag>接口测试</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Fidder抓包</title>
    <url>/2023/11/28/Fidder/</url>
    <content><![CDATA[<h3 id="Fidder"><a href="#Fidder" class="headerlink" title="Fidder"></a>Fidder</h3><p>Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一 。 它能够记录客户端和服务器之间的所有 HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据<span id="more"></span></p>
<p>注意：使用Fiddler的话，需要先设置浏览器的代理地址，才可以抓取到浏览器的数据包。<strong>而很方便的是在你启动该工具后，它就已经自动帮你设置好了浏览器的代理了</strong>，当关闭后，它又将浏览器代理还原了。当然如果发现没有自动设置浏览器代理的话，那就得自己动手去浏览器进行设置代理操作了。（可自行百度每个浏览器是如何设置代理的）</p>
<h3 id="Fidder设置"><a href="#Fidder设置" class="headerlink" title="Fidder设置"></a>Fidder设置</h3><h4 id="https设置"><a href="#https设置" class="headerlink" title="https设置"></a>https设置</h4><p>首先点击Tools—&gt;Options,之后在出现的页面选择HTTSPS，将其全部勾选。如下图所示。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128144508010.png" alt="image-20231128144508010" style="zoom: 67%;" />

<p>之后，浏览器访问<a href="http://localhost:8888，点击download">http://localhost:8888，点击download</a> the FidderRoot certificate，安装对应证书。之后打开下载的内容，一直next即可。再次进入上图页面，点击Actions，选择reset all certificate，，先删除所有证书，再安装你下载的证书（按照提示来即可）点击yes，点击是，之后ok关闭即可。完成上述步骤就可以进行https请求的抓取了。</p>
<h4 id="远程连接设置"><a href="#远程连接设置" class="headerlink" title="远程连接设置"></a>远程连接设置</h4><p>首先点击Tools—&gt;Options,然后点击Connections，勾选Allow remote computers to connect即可。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128150943183.png" alt="image-20231128150943183" style="zoom: 67%;" />

<p>同时，此界面还可以更改fidder的默认端口8888。</p>
<h3 id="Fidder请求"><a href="#Fidder请求" class="headerlink" title="Fidder请求"></a>Fidder请求</h3><p>1）各图标含义</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128151748732.png" alt="image-20231128151748732" style="zoom:67%;" />

<p>2）工具栏</p>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128152053892.png" alt="image-20231128152053892"></p>
<p>从左到右表示的意义分别是：</p>
<ul>
<li>WinConfig：windows 使用了一种叫做“AppContainer”的隔离技术，使得一些流量无法正常捕获，在 fiddler中点击 WinConfig 按钮可以解除这个诅咒，这个与菜单栏 Tools→Win8 Loopback Exemptions 功能是一致的</li>
<li>气泡：给请求添加备注说明。选中一条请求，点击气泡，即可添加对应的备注说明</li>
<li>Replay：对请求进行回放。选择一条请求，点击replay，即再次发送该请求</li>
<li>X：删除某些请求会话，可下拉选择。常用remove all</li>
<li>Go：debug断点调试时，继续执行该请求</li>
<li>Stream：流模式，实时通信模式，有请求就有返回。一般用不到</li>
<li>Decode：将请求的东西解压出来，方便查阅</li>
<li>Keep all Sessions：保存所有会话。注意，保存越多，占用内存越大。fidder默认保存所有，可下拉选择更改</li>
<li>Any Process：过滤请求。将其按住拖到edge浏览器上即可屏蔽该浏览器发出的请求。只能屏蔽对应的进程，应用发出的会话请求</li>
<li>Find：查找会话，使用黄色标记该会话。</li>
<li>Save：保存选择的会话。保存为 .saz文件</li>
<li>照相机&#x2F;截图：保存截图，5秒后将截图保存下来</li>
<li>计时器：左击开始计时，再左击停止。右击清0</li>
<li>Browse：快速启动浏览器，可下拉选择</li>
<li>Clear cache：清除缓存</li>
<li>TextWizard：编&#x2F;解码字符串</li>
<li>Tearoff：将请求和响应单独独立为一个新窗口，方便查看</li>
<li>MSDN：搜索功能</li>
<li>？：fidder在线帮助网站</li>
</ul>
<p>3）选项卡</p>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128154847828.png" alt="image-20231128154847828"></p>
<p>下面将只介绍一些常用的选项卡。</p>
<h4 id="Inspectors"><a href="#Inspectors" class="headerlink" title="Inspectors"></a>Inspectors</h4><p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128155446293.png" alt="image-20231128155446293"></p>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128155505246.png" alt="image-20231128155505246"></p>
<p>包含请求和响应的一些信息。主要是对这些信息的多种格式展示。主要查看请求头，响应头重要信息。</p>
<h4 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h4><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128155952719.png" alt="image-20231128155952719" style="zoom:67%;" />

<p>设置完成后，点击Actions执行定义的过滤规则。</p>
<p>1）Hosts过滤</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">No Zone Filter：不设置过滤；指定只显示内网（Intranet）或互联网（Internet）的内容(不常用)</span><br><span class="line">Show only Intranet Hosts：指定只显示内网（Intranet）的内容</span><br><span class="line">Show only Internet Hosts：指定只显示互联网（Internet）的内容</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No Host Filter：不过滤</span><br><span class="line">Hide the following Hosts ： 隐藏文本框中的相关主机请求</span><br><span class="line">Show only the following Hosts ：显示文本框中相关的主机请求（多个用分号分开）</span><br><span class="line">Flag the following Hosts ：标记（高亮）显示文本框中的主机请求</span><br></pre></td></tr></table></figure>

<p>2）Client Process过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Show only traffic from：你可以指定只捕获哪个Windows进程中的请求；</span><br><span class="line">Show only Internet Explorer traffic：只显示IE发出的请求；</span><br><span class="line">Hide traffic from Service Host：隐藏来自Host发出的请求；</span><br></pre></td></tr></table></figure>

<p>3）RequestHeader过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show only if URL contains: 只显示URL包含的，多个时空格分开</span><br><span class="line">Hide if URL contains: 隐藏URL包含的，多个时空格分开</span><br><span class="line">Flag requests with headers: 加粗显示HTTP请求头包含指定的HTTP请求头的类型名称</span><br><span class="line">Delete request headers: 删除HTTP请求头包含指定的HTTP请求头的类型名称</span><br><span class="line">Set request header : 创建一个指定名称和值的HTTP请求头,或更新HTTP请求头为指定值。</span><br><span class="line">Break request on POST: POST请求设置断点</span><br><span class="line">Break request on GET with query string: GET方法且URL中包含查询条件的请求设置断点（URL中包含参数params）</span><br><span class="line">Break on XMLHttpRequest: 通过 XMLHttpRequest对象发送的请求设置断点。通过查找请求头中是否含有X-Request-With 和X-Download-Initiator</span><br><span class="line">Break response on Content-Type: 响应头Content-Type 中包含了指定的文本设置断点</span><br></pre></td></tr></table></figure>

<p>5）Response Status Code过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hide success(2XX): 隐藏状态码在200至299的响应</span><br><span class="line">Hide non-2xx: 隐藏非200至299的响应</span><br><span class="line">Hide Authentication demands(401,407): 隐藏状态码为401,407的响应.需要用户进一步确认证书的请求</span><br><span class="line">Hide redirects(300,301,302,303,307): 藏状态码为300,301,302,303,307重定向的响应</span><br><span class="line">Hide Not Modified(304):藏状态码为304的响应.缓存实体有效返回304</span><br></pre></td></tr></table></figure>

<p>6）Response Type and Size过滤</p>
<p>7）Response Headers过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flag responses that set cookies: 粗体显示和响应头包含Set-Cookie的响应</span><br><span class="line">Flag responses with headers: 粗体显示指定HTTP响应头。同Flag requests with headers</span><br><span class="line">Delete responses headers: 删除特定的HTTP响应头。只是从响应头中删除，不删除session</span><br><span class="line">Set response header；创建更新响应头。同Set Request header 用法一样</span><br></pre></td></tr></table></figure>

<h4 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h4><p>Composer选项卡支持手动构建和发请求；也可以在session列表中拖拽Session放到Composer中，会直接把该session的请求复制到用户界面；</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128163002061.png" alt="image-20231128163002061" style="zoom:67%;" />

<p>上面填写对应的请求路径，请求头信息等。下面填写请求体中对应的内容。即请求的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	Options标签：</span><br><span class="line">Inspect Session: 执行请求后，会自动打开Inspectors选项卡；</span><br><span class="line">Fix Content-Length header:控制Composer是否会自动添加或修改Content-Length请求头，表示请求体的大小；</span><br><span class="line">Follow Redirects:是否会自动使用响应的Location头；</span><br><span class="line">Automatically Authenticate: 是否会自动响应服务器的认证需求；</span><br><span class="line">Tear off 按钮：使Composer选项卡以独立的窗口悬浮；</span><br></pre></td></tr></table></figure>

<h3 id="Fidder应用"><a href="#Fidder应用" class="headerlink" title="Fidder应用"></a>Fidder应用</h3><h4 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h4><p>根据对应的请求头，响应头信息，判断是前端错误还是后端错误。若请求有问题，则前端错误，若响应的数据有问题，则后端服务错误，若响应数据没问题，则前端渲染错误。（同时还要结合数据库数据进行判断）</p>
<h4 id="Mock测试—查看页面布局"><a href="#Mock测试—查看页面布局" class="headerlink" title="Mock测试—查看页面布局"></a>Mock测试—查看页面布局</h4><p><strong>断点改数据：</strong></p>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128170848085.png" alt="image-20231128170848085"></p>
<p>点击第一下是请求前断点，可以修改对应的请求数据；点击第二下是响应后断点，可以修改对应的响应数据，点击第三下是取消断点。断点设置之后点击Run to completion执行断点后的操作，观察结果。</p>
<p><strong>改数据库：</strong>优点，可以同时测多种环境下页面显示问题，如web页面，app页面，h5等。缺点：信息千人前面，每个人的推荐信息是不同的。</p>
<p><strong>mock测试：</strong>先save对应的响应体数据，然后修改保存。后点击AutoResponder选项卡，拖动对应请求到其中，而后选择find a file替换响应结果，而后再次发送该请求去查看结果即可。如下图所示</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128165733545.png" alt="image-20231128165733545" style="zoom:67%;" />

<h4 id="弱网测试"><a href="#弱网测试" class="headerlink" title="弱网测试"></a>弱网测试</h4><p>Rules-&gt;Performance -&gt; Simulate Modem Speeds</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128172259066.png" alt="image-20231128172259066" style="zoom:67%;" />

<p>同时，可以点击Rules—&gt;Cutomize Rules，即</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231128172415152.png" alt="image-20231128172415152" style="zoom:67%;" />

<p>进去弱网设置代码里，找到m_SimulateModem，修改oSession[“request-trickle-delay”] &#x3D; “300”;（表示上传1kb需要300ms）和oSession[“response-trickle-delay”] &#x3D; “150”;，自定义弱网的网络条件。</p>
<h4 id="app抓包"><a href="#app抓包" class="headerlink" title="app抓包"></a>app抓包</h4><p>首先打开fidder的远程连接，见上。其次，进行手机上的设置，保证手机网络和fidder所在电脑网络处于同一局域网下。然后设置手机的代理网络为fidder的服务地址。</p>
<p>此外，手机上也需要下载安装fidder安全证书。访问http:&#x2F;&#x2F;电脑IP:8888，一路下载安装，按照提示干就完了。（不要干坏事哇）</p>
]]></content>
      <tags>
        <tag>测试</tag>
        <tag>抓包</tag>
        <tag>Fidder</tag>
      </tags>
  </entry>
  <entry>
    <title>Jmeter---压力测试</title>
    <url>/2023/12/16/Jmeter---%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="Jmeter压力测试"><a href="#Jmeter压力测试" class="headerlink" title="Jmeter压力测试"></a>Jmeter压力测试</h2><p>性能测试是一个系统化的过程，用于评估系统在不同负载条件下的表现。下面是使用Jmeter进行性能测试的一般流程。<span id="more"></span></p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ol>
<li>首先新建对应的线程组，以及添加一个http cookie管理器。（某些请求之间存在cookie关联，故添加cookie管理器防止报错）。</li>
<li>在测试计划右键添加，非测试元件，http代理服务器。</li>
<li>基本信息填写</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216145015594.png" alt="image-20231216145015594" style="zoom:67%;" />

<ol start="4">
<li>请求过滤，将一些请求过滤，如图片，音视频等数据。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216145421637.png" alt="image-20231216145421637" style="zoom:67%;" />

<ol start="5">
<li>配置电脑代理。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216150106985.png" alt="image-20231216150106985" style="zoom:67%;" />

<ol start="6">
<li>开始录制。点击HTTP代理服务器中的绿色启动按钮。（shift+f5，去缓存刷新页面）</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216150325859.png" alt="image-20231216150325859" style="zoom:67%;" />

<ol start="7">
<li>完成整个事务流程后，自己修改相关逻辑。如接口关联中的值的修改，删除不必要的请求头信息，删除不必要的跳转请求等。</li>
</ol>
<h3 id="聚合报告"><a href="#聚合报告" class="headerlink" title="聚合报告"></a>聚合报告</h3><p>在线程组或请求上右键，添加，监听器，聚合报告。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216152211346.png" alt="image-20231216152211346" style="zoom:67%;" />

<h3 id="逻辑控制器"><a href="#逻辑控制器" class="headerlink" title="逻辑控制器"></a>逻辑控制器</h3><p>常用的逻辑控制器有事务控制器，吞吐量控制器，仅一次控制器。均在线程组右键添加，逻辑控制器，选择对应的控制器即可，而后将响应的请求拖动到其下面即可。</p>
<p>事务控制器：将几个请求聚合为一个事务，在聚合报告中可以只查看到聚合后的性能指标。</p>
<p>仅一次控制器：常用于登录请求，一个虚拟用户的多次请求应当只登录一次。</p>
<p>吞吐量控制器：例如博客发帖的测试，发帖的吞吐量应该远小于回帖的吞吐量，模拟真实的性能场景。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216154104793.png" alt="image-20231216154104793" style="zoom:67%;" />

<p>（per user：对于percent模式不影响，对于total模式，单个虚拟用户单独计算其吞吐量，即取样器的次数）</p>
<h3 id="同步定时器（集合点）"><a href="#同步定时器（集合点）" class="headerlink" title="同步定时器（集合点）"></a>同步定时器（集合点）</h3><p>用于实现并发。右键添加，定时器，同步定时器。在虚拟用户来了之后，不是立即发送请求，而是先集合，形成用户组。用户组达到规定的用户数量后，再统一的发送请求，模拟并发的场景。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216155251490.png" alt="image-20231216155251490" style="zoom:67%;" />

<h3 id="Jmeter插件管理"><a href="#Jmeter插件管理" class="headerlink" title="Jmeter插件管理"></a>Jmeter插件管理</h3><ol>
<li><p>首先下载对应的插件管理包。<a href="https://jmeter-plugins.org/install/Install/">jmeter-plugins-manager.jar</a>，<a href="https://jmeter-plugins.org/downloads/file/JMeterPlugins-Standard-1.4.0.zip">JMeterPlugins-Standard-1.4.0.zip</a>，<a href="https://jmeter-plugins.org/downloads/file/JMeterPlugins-Extras-1.4.0.zip">JMeterPlugins-Extras-1.4.0.zip</a>。(<a href="https://jmeter-plugins.org/downloads/old/">其余插件地址</a>)</p>
</li>
<li><p>将其中的对应名字的jar包放入jmeter安装位置下的lib&#x2F;ext文件夹中</p>
</li>
<li><p>重启Jmeter。</p>
</li>
<li><p>在监听器里面，就有了对应的TPS和RT的图形显示结果。</p>
</li>
</ol>
<h3 id="实际性能压测"><a href="#实际性能压测" class="headerlink" title="实际性能压测"></a>实际性能压测</h3><p>一般使用简单线程组进行基准测试，得到性能拐点。再使用混合复杂压测得到性能分析。</p>
<h4 id="jp-gc-Stepping-Thread-Group"><a href="#jp-gc-Stepping-Thread-Group" class="headerlink" title="jp@gc - Stepping Thread Group"></a>jp@gc - Stepping Thread Group</h4><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216163917889.png" alt="image-20231216163917889" style="zoom:67%;" />

<h3 id="无界面指令"><a href="#无界面指令" class="headerlink" title="无界面指令"></a>无界面指令</h3><p>JMeter 是一个功能强大的性能测试工具，可以通过命令行进行许多操作。以下是一些常用的 JMeter 命令行参数：</p>
<ul>
<li><p><code>-n</code>：非 GUI 模式，以无界面方式启动 JMeter。</p>
</li>
<li><p><code>-t [测试计划文件]</code>：指定要运行的 JMeter 测试计划文件。</p>
</li>
<li><p><code>-r</code>：启动 JMeter 远程服务器。</p>
</li>
<li><p><code>-R [远程服务器列表]</code>：指定要连接的远程服务器列表。</p>
</li>
<li><p><code>-e</code>：在测试运行结束后生成 HTML 报告。</p>
</li>
<li><p><code>-l [输出文件]</code>：将结果写入指定文件。</p>
</li>
<li><p><code>-J[prop_name]=[prop_value]</code>：设置 JMeter 属性值。</p>
</li>
<li><p><code>-j [日志文件]</code>：将日志写入指定文件。</p>
</li>
<li><p><code>-h</code>：显示命令行参数的帮助信息。</p>
</li>
<li><p><code>-v [变量名]</code>：输出指定变量的值。</p>
</li>
<li><p><code>-q [属性文件]</code>：指定要使用的属性文件。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jmeter -n -t ./scripts/test.jmx -l resout.jtl</span><br><span class="line"><span class="comment">#./scripts/test.jmx为脚本的位置</span></span><br><span class="line"><span class="comment">#resout.jtl为生成的jtl报告。</span></span><br><span class="line"><span class="comment">#最后使用聚合报告打开jtl文件，即可得到对应的聚合报告</span></span><br><span class="line">jmeter -n -t ./scripts/test.jmx -l resout2.jtl -e -o reports</span><br><span class="line"><span class="comment">#-e： html报告</span></span><br><span class="line"><span class="comment">#-o： 文件夹的位置，reports</span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>测试</tag>
        <tag>Jmeter</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium API</title>
    <url>/2023/12/04/Selenium-API/</url>
    <content><![CDATA[<h2 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h2><p>上面介绍了Selenium中的元素定位以及元素的相关操作（详情请点击 <a href="/2023/12/03/Selenium%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%93%8D%E4%BD%9C/" title="Selenium元素定位和操作">Selenium元素定位和操作</a> ）。接下来将继续介绍Selenium中的API方法。</p>
<h3 id="浏览器操作"><a href="#浏览器操作" class="headerlink" title="浏览器操作"></a>浏览器操作</h3><p>脚本启动浏览器窗口大小默认不是全屏？如何刷新页面？</p>
<p>通过调用Selenium的API来实现浏览器的操作。<span id="more"></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maximize_window() 最大化浏览器窗口 --&gt; 模拟浏览器最大化按钮</span><br><span class="line">set_window_size(width, height) 设置浏览器窗口大小 --&gt; 设置浏览器宽、高(像素点)</span><br><span class="line">set_window_position(x, y) 设置浏览器窗口位置 --&gt; 设置浏览器位置</span><br><span class="line">back() 后退 --&gt; 模拟浏览器后退按钮</span><br><span class="line">forward() 前进 --&gt; 模拟浏览器前进按钮</span><br><span class="line">refresh() 刷新 --&gt; 模拟浏览器F5刷新</span><br><span class="line">close() 关闭当前窗口 --&gt; 模拟点击浏览器关闭按钮</span><br><span class="line">quit() 关闭浏览器驱动对象 --&gt; 关闭所有程序启动的窗口</span><br><span class="line">title 获取页面title</span><br><span class="line">current_url 获取当前页面URL</span><br><span class="line">注意： </span><br><span class="line">	driver.title 和 driver.current_url 没有括号，应用场景：一般为判断上步操作是否执行成功。</span><br><span class="line">driver.maximize_window() # 一般为我的前置代码，在获取driver后，直接编写最大化浏览器</span><br><span class="line">driver.refresh() 应用场景，在后面的cookie章节会使用到。</span><br><span class="line">driver.close()与driver.quit()区别：</span><br><span class="line">	close():关闭当前主窗口</span><br><span class="line">	quit():关闭由driver对象启动的所有窗口</span><br><span class="line">	提示：如果当前只有1个窗口，close与quit没有任何区别。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="comment"># 最大化浏览器</span></span><br><span class="line">driver.maximize_window()</span><br><span class="line"><span class="comment"># 刷新</span></span><br><span class="line">driver.refresh()</span><br><span class="line"><span class="comment"># 后退</span></span><br><span class="line">driver.back()</span><br><span class="line"><span class="comment"># 前进</span></span><br><span class="line">driver.forward()</span><br><span class="line"><span class="comment"># 设置浏览器大小</span></span><br><span class="line">driver.set_window_size(<span class="number">300</span>,<span class="number">300</span>)</span><br><span class="line"><span class="comment"># 设置浏览器位置</span></span><br><span class="line">driver.set_window_position(<span class="number">300</span>,<span class="number">200</span>)</span><br><span class="line"><span class="comment"># 关闭浏览器单个窗口</span></span><br><span class="line">driver.close()</span><br><span class="line"><span class="comment"># 关闭浏览器所有窗口</span></span><br><span class="line">driver.quit()</span><br><span class="line"><span class="comment"># 获取title</span></span><br><span class="line">title = driver.title</span><br><span class="line"><span class="comment"># 获取当前页面url</span></span><br><span class="line">url = driver.current_url</span><br></pre></td></tr></table></figure>

<h3 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h3><p>现在Web产品中存在丰富的鼠标交互方式，作为一个Web自动化测试框架，需要应对这些鼠标操作的应用场景。常见的鼠标操作有：点击、右击、双击、悬停、拖拽等，对于这些鼠标操作Selenium都封装了相应的操作方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：在Selenium中将操作鼠标的方法封装在ActionChains类中</span><br><span class="line">导包：from selenium.webdriver.common.action_chains import ActionChains</span><br><span class="line">实例化对象：action = ActionChains(driver)</span><br><span class="line">方法：</span><br><span class="line"> 	context_click(element) 右击 --&gt; 模拟鼠标右键点击效果</span><br><span class="line"> 	double_click(element) 双击 --&gt; 模拟鼠标双击效果</span><br><span class="line"> 	drag_and_drop(source, target) 拖动 --&gt; 模拟鼠标拖动效果</span><br><span class="line"> 	move_to_element(element) 悬停 --&gt; 模拟鼠标悬停效果</span><br><span class="line"> 	perform() 执行 --&gt; 此方法用来执行以上所有鼠标操作，操作上诉方法后，还需调用此方法猜能生效</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">鼠标执行-perform()</span><br><span class="line">说明：在ActionChains类中所有提供的鼠标事件方法，在调用的时候所有的行为都存储在ActionChains对象中，而perform()方法就是真正去执行所有的鼠标事件。</span><br><span class="line">强调：必须调用perform()方法才能执行鼠标事件</span><br><span class="line"></span><br><span class="line">鼠标右键-context_click()</span><br><span class="line">说明：对于点击鼠标右键，如果弹出的是浏览器默认的菜单，Selenium没有提供操作菜单选项的方法；如果是自定义的右键菜单，则可以通过元素定位来操作菜单中的选项。</span><br><span class="line"></span><br><span class="line">鼠标双击-double_click()</span><br><span class="line">说明：模拟双击鼠标左键操作</span><br><span class="line"></span><br><span class="line">鼠标拖动-drag_and_drop()</span><br><span class="line">说明：模拟鼠标拖动动作，选定拖动源元素释放到目标元素</span><br><span class="line">	源元素 source = driver.find_element_by_id(xxx)</span><br><span class="line">	目标元素 target = driver.find_element_by_id(xxx)</span><br><span class="line">	调用方法 action.drag_and_drop(source, target).perform()</span><br><span class="line"></span><br><span class="line">鼠标悬停-move_to_element()</span><br><span class="line">说明: 模拟鼠标悬停在指定的的元素上</span><br><span class="line"></span><br><span class="line">再次说明，最后调用perform()方法才能真正执行对应的鼠标方法。</span><br><span class="line">selenium框架中虽然提供了，右击鼠标方法，但是没有提供选择右击菜单方法，可以通过发送快捷键的方式解决(经测试，谷歌浏览器不支持)。</span><br></pre></td></tr></table></figure>

<h3 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h3><p>如何实现复制、粘贴的操作？模拟键盘上一些按键或者组合键的输入 如：Ctrl+C 、Ctrl+V？Selenium中把键盘的按键都封装在Keys类中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导包：from selenium.webdriver.common.keys import Keys</span><br><span class="line">方法：</span><br><span class="line">	send_keys(Keys.BACK_SPACE) 删除键(BackSpace)</span><br><span class="line"> 	send_keys(Keys.SPACE) 空格键(Space)</span><br><span class="line"> 	send_keys(Keys.TAB) 制表键(Tab)</span><br><span class="line">	send_keys(Keys.ESCAPE) 回退键(Esc)</span><br><span class="line">	send_keys(Keys.ENTER) 回车键(Enter)</span><br><span class="line">	send_keys(Keys.CONTROL,&#x27;a&#x27;) 全选(Ctrl+A)</span><br><span class="line">	send_keys(Keys.CONTROL,&#x27;c&#x27;) 复制(Ctrl+C)</span><br><span class="line">别的组合键与上面类似。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定位用户名</span></span><br><span class="line">element = driver.find_element_by_id(<span class="string">&quot;HonorHL&quot;</span>)</span><br><span class="line"><span class="comment"># 输入用户名</span></span><br><span class="line">element.send_keys(<span class="string">&quot;荷包蛋HL&quot;</span>)</span><br><span class="line"><span class="comment"># 删除1</span></span><br><span class="line">element.send_keys(Keys.BACK_SPACE)</span><br><span class="line"><span class="comment"># 全选</span></span><br><span class="line">element.send_keys(Keys.CONTROL, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># 复制</span></span><br><span class="line">element.send_keys(Keys.CONTROL, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># 粘贴</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;HL&#x27;</span>).send_keys(Keys.CONTROL, <span class="string">&#x27;v&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="元素等待"><a href="#元素等待" class="headerlink" title="元素等待"></a>元素等待</h3><p>在定位页面元素时如果未找到，会在指定时间内一直等待的过程。</p>
<p>为什么需要元素等待？网络速度慢，电脑配置低，服务器处理请求慢。即在有的时候，元素定位操作代码没有问题，可就是定位不到元素，可能的原因是页面没有加载完成就在执行元素定位，故定位不到元素。</p>
<p>与sleep()的区别：不论是否找到元素，sleep都会等待设定的时间长度，而元素等待再定位到元素时就不会继续等待了。</p>
<h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><p>定位元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该元素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出元素不存在的异常 NoSuchElementException 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法：driver.implicitly_wait(timeout)    (timeout：为等待最大时长，单位：秒)</span><br><span class="line">说明：隐式等待为全局设置（只需要设置一次，就会作用于所有元素），查找时间间隔为0.5秒</span><br></pre></td></tr></table></figure>

<h4 id="显示等待"><a href="#显示等待" class="headerlink" title="显示等待"></a>显示等待</h4><p>定位指定元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该元素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出超时异常 TimeoutException 。（与隐式抛出的异常对象不同）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Selenium中把显式等待的相关方法封装在WebDriverWait类中</span><br><span class="line">导包：from selenium.webdriver.support.wait import WebDriverWait</span><br><span class="line"></span><br><span class="line">WebDriverWait(driver, timeout, poll_frequency=0.5)</span><br><span class="line"> 	driver：浏览器驱动对象</span><br><span class="line"> 	timeout：超时的时长，单位：秒</span><br><span class="line"> 	poll_frequency：检测间隔时间，默认为0.5秒</span><br><span class="line"> 	</span><br><span class="line">调用方法 until(method)：直到...时</span><br><span class="line">	 method：函数名称，该函数用来实现对元素的定位</span><br><span class="line"> 	一般使用匿名函数来实现：lambda x: x.find_element_by_id(&quot;userA&quot;)</span><br><span class="line"> 	</span><br><span class="line">例如：	element = WebDriverWait(driver, 10, 1).until(lambda x: x.find_element_by_id(&quot;HL&quot;))</span><br><span class="line">每隔1秒就去页面查找id为HL的元素，定位到元素后，则不再等待，继续操作，若未查找到，在10秒内每隔一秒就再去检查该元素，超时后就抛出异常。</span><br><span class="line"></span><br><span class="line">显示等待作用于一个元素，且可以自定义查找的时间间隔。</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>作用域：隐式为全局元素，显式等待为单个元素有效</li>
<li>使用方法：隐式等待直接通过驱动对象调用，而显式等待方法封装在WebDriverWait类中</li>
<li>达到最大超时时长后抛出的异常不同：隐式为NoSuchElementException，显式等待为TimeoutException</li>
</ul>
<h3 id="下拉框操作"><a href="#下拉框操作" class="headerlink" title="下拉框操作"></a>下拉框操作</h3><p>下拉框就是HTML中select元素，可以使用前面学习的元素定位操作，定位到下拉框，再对其进行相应的操作。当选中某个下拉框时，需要先定位到该select元素的子元素option下拉框，再执行点击操作，操作较为繁琐。故Selenium为下拉框封装了Select类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：Select类是Selenium为操作select标签特殊封装的。</span><br><span class="line">导包：from selenium.webdriver.support.select import Select</span><br><span class="line"></span><br><span class="line">实例化对象：</span><br><span class="line">	select = Select(element)</span><br><span class="line">		element: &lt;select&gt;标签对应的元素，通过元素定位方式获取，例如：driver.find_element_by_id(&quot;selectHL&quot;)</span><br><span class="line">注意：只需定位到对应的select元素，而不用定位到其子元素option。</span><br><span class="line"></span><br><span class="line">方法：选择对应的下拉框</span><br><span class="line">	select.select_by_index(index) --&gt; 根据option索引来定位，从0开始</span><br><span class="line">	select.select_by_value(value) --&gt; 根据option属性 value值来定位</span><br><span class="line">	select.select_by_visible_text(text) --&gt; 根据option显示文本来定位</span><br><span class="line"></span><br><span class="line">注意：调用Select类下面的方法，是通过索引、value属性值、显示文本去控制，而不需要click事件</span><br></pre></td></tr></table></figure>

<h3 id="弹出框操作"><a href="#弹出框操作" class="headerlink" title="弹出框操作"></a>弹出框操作</h3><p>网页中常用的弹出框有三种</p>
<ul>
<li>alert 警告框</li>
<li>confirm 确认框</li>
<li>prompt 提示框</li>
</ul>
<p>当网页弹出对应的弹出框时，再对页面进行相应的点击，赋值操作就没有执行了。故只有将其关闭后，接下来的语句才能正常执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：Selenium中对处理弹出框的操作，有专用的处理方法；并且处理的方法都一样</span><br><span class="line">获取弹出框对象： alert = driver.switch_to.alert</span><br><span class="line">调用：</span><br><span class="line">	alert.text --&gt; 返回alert/confirm/prompt中的文字信息</span><br><span class="line">	alert.accept() --&gt; 接受对话框选项</span><br><span class="line">	alert.dismiss() --&gt; 取消对话框选项</span><br><span class="line">注意：</span><br><span class="line">	可能有的弹出框的页面显示上没有取消/确定按钮，但仍能调用对应的接受和取消的方法。底层的弹出框是含有上述的方法的。且三种弹出框的处理方式都是一样的。</span><br><span class="line">	注意分辨前端人员自己编写的弹出框（使用div等模拟），而不是使用浏览器自带的弹出框。此类采用传统的方法，使用Selenium定位到该元素，再执行关闭操作。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 点击弹出框按钮（弹出警告框）</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;alertHL&quot;</span>).click()</span><br><span class="line"><span class="comment"># 获取警告框</span></span><br><span class="line">alert = driver.switch_to.alert</span><br><span class="line"><span class="comment"># 打印警告框文本</span></span><br><span class="line"><span class="built_in">print</span>(alert.text)</span><br><span class="line"><span class="comment"># 接受警告框</span></span><br><span class="line">alert.accept()</span><br><span class="line"><span class="comment"># 取消警告框</span></span><br><span class="line"><span class="comment"># alert.dismiss()</span></span><br></pre></td></tr></table></figure>

<h3 id="滚动条操作"><a href="#滚动条操作" class="headerlink" title="滚动条操作"></a>滚动条操作</h3><p>滚动条：一种可控制页面显示范围的组件</p>
<p>在HTML页面中，由于前端技术框架的原因，页面元素为动态显示，元素根据滚动条的下拉而被加载。页面注册同意条款，需要滚动条到最底层，才能点击同意。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：selenium中并没有直接提供操作滚动条的方法，但是它提供了可执行JavaScript脚本的方法，所以我们可以通过JavaScript脚本来达到操作滚动条的目的。</span><br><span class="line">设置JavaScript脚本控制滚动条</span><br><span class="line">	js = &quot;window.scrollTo(0,1000)&quot;</span><br><span class="line">		(0:左边距；1000：上边距；单位：像素)</span><br><span class="line">		</span><br><span class="line">selenium调用执行JavaScript脚本的方法</span><br><span class="line">	driver.execute_script(js)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最底层</span></span><br><span class="line">js1 = <span class="string">&quot;window.scrollTo(0,10000)&quot;</span></span><br><span class="line">driver.execute_script(js1)</span><br><span class="line"><span class="comment"># 最顶层</span></span><br><span class="line">js2 = <span class="string">&quot;window.scrollTo(0,0)&quot;</span></span><br><span class="line">driver.execute_script(js2)</span><br></pre></td></tr></table></figure>

<h3 id="Frame切换"><a href="#Frame切换" class="headerlink" title="Frame切换"></a>Frame切换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame：HTML页面中的一种框架，主要作用是在当前页面中指定区域显示另一页面元素；</span><br><span class="line">形式一：[了解]</span><br><span class="line">	&lt;frameset cols=&quot;25%,75%&quot;&gt;</span><br><span class="line">		&lt;frame src=&quot;frame_a.htm&quot;&gt;  引用a.html</span><br><span class="line">		&lt;frame src=&quot;frame_b.htm&quot;&gt;</span><br><span class="line">	&lt;/frameset&gt;</span><br><span class="line">形式二：</span><br><span class="line">&lt;iframe name=&quot;iframe_a&quot; src=&quot;iframeHL.htm&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<p>若此时的页面中，有对应的Frame别的页面信息，是定位不到对应的Frame页面的元素的，故就需要切换到该Frame页面才能定位到对应的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：在Selenium中封装了如何切换frame框架的方法</span><br><span class="line">方法：</span><br><span class="line">	driver.switch_to.frame(frame_reference) --&gt; 切换到指定frame的方法</span><br><span class="line">		frame_reference：可以为frame框架的name、id或者定位到的frame元素</span><br><span class="line">		</span><br><span class="line">	driver.switch_to.default_content() --&gt; 恢复默认页面方法,回到主页面。在frame中操作其他页面，必须先回到默认页面，才能进一步操作。不能从Frame a页面切换到Frame b页面。只能a到主页面，主页面再到b页面。</span><br></pre></td></tr></table></figure>

<h3 id="多窗口切换"><a href="#多窗口切换" class="headerlink" title="多窗口切换"></a>多窗口切换</h3><p>在HTML页面中，当点击超链接或者按钮时，有的会在新的窗口打开页面。</p>
<p>与Frame类似，当打开某个连接，浏览器打开新页面时，无法定位到新页面内容，也就无法对新页面进行操作。故需要进行窗口切换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：在Selenium中封装了获取当前窗口句柄、获取所有窗口句柄和切换到指定句柄窗口的方法；句柄：英文handle，窗口的唯一识别码。</span><br><span class="line">方法：</span><br><span class="line"> 	driver.current_window_handle --&gt; 获取当前窗口句柄</span><br><span class="line"> 	driver.window_handles --&gt; 获取所有窗口句柄</span><br><span class="line"> 	driver.switch_to.window(handle) --&gt; 切换指定句柄窗口</span><br><span class="line"> 注意：通过获取所有的句柄以及当前窗口的句柄，来判断去要切换的句柄。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取所有的窗口句柄</span></span><br><span class="line">window_handles = driver.window_handles</span><br><span class="line"><span class="comment">#当只有两个窗口时，当前所在的窗口句柄下标为0，要切换的窗口句柄下标为1</span></span><br><span class="line">driver.switch_to.window(window_handles[<span class="number">1</span>])</span><br><span class="line"><span class="comment">#切回主窗口</span></span><br><span class="line">driver.switch_to.window(window_handles[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h3 id="窗口截图"><a href="#窗口截图" class="headerlink" title="窗口截图"></a>窗口截图</h3><p>自动化脚本是由程序去执行的，因此有时候打印的错误信息并不是十分明确。如果在执行出错的时候对当前窗口截图保存，那么通过图片就可以非常直观地看到出错的原因。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：在Selenium中，提供了截图方法，我们只需要调用即可</span><br><span class="line">方法：driver.get_screenshot_as_file(imgpath)   </span><br><span class="line">		imgpath：图片保存路径</span><br><span class="line">		</span><br><span class="line">例如：driver.get_screenshot_as_file(&quot;./img/HL.jpg&quot;)    存放到当前目录下的img文件夹下，命名为HL.jpg图片。可以通过时间戳的方式，生成对应的图片名，防止图片被覆盖。</span><br><span class="line">     driver.get_screenshot_as_file(&quot;../image/%s.png&quot;%(time.strftime(&quot;%Y_%m_%d %H_%M_%S&quot;)))</span><br><span class="line">	 		strftime:将时间转为字符串函数</span><br><span class="line">	        注意：%Y_%m_%d %H_%M_%S：代表，年 月 日 时 分 秒</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver.get_screenshot_as_file(<span class="string">&quot;../image/%s.png&quot;</span>%(time.strftime(<span class="string">&quot;%Y_%m_%d %H_%M_%S&quot;</span>)))</span><br><span class="line"><span class="comment"># %s：占位符，使用%后面的字符串代替</span></span><br><span class="line"><span class="comment"># strftime:将时间转为字符串函数</span></span><br><span class="line"><span class="comment"># %Y_%m_%d %H_%M_%S：代表，年 月 日 时 分 秒</span></span><br></pre></td></tr></table></figure>

<h3 id="Cookie操作"><a href="#Cookie操作" class="headerlink" title="Cookie操作"></a>Cookie操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie是由Web服务器生成的，并且保存在用户浏览器上的小文本文件，它可以包含用户相关的信息。</span><br><span class="line">Cookie数据格式：键值对组成（python中的字典）</span><br><span class="line">Cookie产生：客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个Cookie数据</span><br><span class="line">Cookie使用：当浏览器再次请求该网站时，浏览器把请求的数据和Cookie数据一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。</span><br></pre></td></tr></table></figure>

<p>更多鉴权内容请点击 （ <a href="/2023/12/02/token%E9%89%B4%E6%9D%83---JWT%E4%BB%A4%E7%89%8C/" title="token鉴权---JWT令牌">token鉴权---JWT令牌</a> ）</p>
<p>实现会话跟踪，记录用户登录状态，实现记住密码和自动登录的功能。</p>
<p>某些场景下，可使用cookie鉴权的方式，跳过繁琐的登录验证过程。如复杂的图片验证码验证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：Selenium中对cookie操作提供相应的方法</span><br><span class="line">方法：</span><br><span class="line">	get_cookie(name) --&gt; 获取指定cookie</span><br><span class="line">		name:为cookie的名称</span><br><span class="line">		</span><br><span class="line">	get_cookies() --&gt; 获取本网站所有本地cookies</span><br><span class="line">	add_cookie(cookie_dict) --&gt; 添加cookie</span><br><span class="line">		cookie_dict：一个字典对象，必选的键包括：&quot;name&quot; and &quot;value&quot;</span><br><span class="line">注意：对cookie操作后，必须刷新当前页面才能生效。driver.refresh()</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>测试</tag>
        <tag>Web测试</tag>
        <tag>爬虫</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>Jmeter---接口测试</title>
    <url>/2023/12/13/Jmeter---%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="Jmeter—接口测试"><a href="#Jmeter—接口测试" class="headerlink" title="Jmeter—接口测试"></a>Jmeter—接口测试</h2><h3 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h3><p>Apache JMeter，它是一个开源的性能测试工具，用于测试和评估应用程序、服务或网站的性能、负载和稳定性。<span id="more"></span></p>
<ul>
<li><p><strong>性能测试</strong>：JMeter 主要用于执行性能测试，通过模拟多个并发用户同时访问目标系统来测量系统的性能、响应时间和吞吐量。</p>
</li>
<li><p><strong>负载测试</strong>：您可以使用 JMeter 来测试应用程序在不同负载条件下的性能，以确定系统在高负载情况下的稳定性。</p>
</li>
<li><p><strong>压力测试</strong>：JMeter 可以帮助您确定应用程序在极限负载下的行为，包括性能瓶颈和系统崩溃点。</p>
</li>
<li><p><strong>功能测试</strong>：除了性能测试，JMeter 也可以用于功能测试，验证应用程序的各种功能是否按预期工作。</p>
</li>
<li><p><strong>多协议支持</strong>：JMeter 支持多种协议，包括HTTP、HTTPS、FTP、JDBC、SMTP、SOAP、REST等，因此可以测试各种类型的应用程序。</p>
</li>
<li><p><strong>分布式测试</strong>：JMeter 具有分布式测试功能，可以将负载分散到多个测试机器上，以模拟更大的负载。</p>
</li>
<li><p><strong>数据驱动测试</strong>：您可以使用 JMeter 进行数据驱动测试，通过CSV文件或数据库中的数据来执行多个测试用例。</p>
</li>
<li><p><strong>生成报告</strong>：JMeter 可以生成详细的测试报告，包括图表和性能指标，以便分析测试结果。</p>
</li>
<li><p><strong>插件支持</strong>：JMeter 具有丰富的插件生态系统，可以扩展其功能，满足不同测试需求。</p>
</li>
</ul>
<h4 id="十大组件"><a href="#十大组件" class="headerlink" title="十大组件"></a>十大组件</h4><ul>
<li>Test Plan (测试计划)：测试计划是测试场景的顶层元素，测试的起点以及容器，它包含了整个测试的配置信息和执行逻辑。您可以在测试计划中添加各种组件以模拟不同的用户行为。</li>
<li>Thread Group (线程组)：线程组定义了模拟的用户数量和执行计划。每个线程表示一个虚拟用户，您可以配置线程组的并发用户数、循环次数和启动延迟等。</li>
</ul>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213151812622.png" alt="image-20231213151812622"></p>
<hr>
<p>下面的组件都在线程组里面。</p>
<hr>
<ul>
<li>Controllers (控制器)：控制器用于定义测试计划中的执行流程，定义发送请求的逻辑过程。常见的控制器包括逻辑控制器（如 If 控制器和 While 控制器）、事务控制器和分隔符控制器，它们允许您组织测试步骤。</li>
<li>Samplers (采样器)：采样器用于发送请求并模拟用户与应用程序的交互。HTTP请求、FTP请求和数据库请求等都是常见的采样器。是发送请求的最小单元</li>
<li>Listeners (监听器)：监听器用于收集和显示测试结果。JMeter提供了各种监听器，如查看结果树、汇总报告、图形结果等，以便您分析性能测试数据。</li>
<li>Config Elements (配置元素)：配置元素允许您设置全局和特定请求的参数。例如，HTTP Cookie 管理器用于处理会话 cookie，HTTP请求默认值可以设置默认的HTTP请求属性。</li>
<li>Timers (定时器)：定时器用于模拟用户之间的时间间隔，以便更真实地模拟负载，用于性能测试。常见的定时器包括常量定时器和随机定时器。</li>
<li>Assertions (断言)：断言用于验证响应是否符合预期。您可以使用响应断言检查响应数据的内容、响应代码和响应时间等。</li>
<li>Pre-Processors (前处理器)：前处理器允许您在发送请求之前对数据进行修改或准备。例如，正则表达式提取器可以从响应中提取特定数据。</li>
<li>Post-Processors (后处理器)：后处理器用于对响应进行进一步处理。例如，JSON提取器可以从JSON响应中提取特定值，以供以后使用。</li>
</ul>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol>
<li>配置元素 (Config Elements)：配置元素首先被处理。它们用于设置全局或特定请求的参数，以确保测试的一致性。这些元素的设置将影响测试计划中的所有线程和请求。</li>
<li>线程组 (Thread Group)：线程组是测试计划的入口点，定义了虚拟用户的数量和执行计划。线程组会根据配置中的并发用户数和循环次数启动线程。</li>
<li>前处理器 (Pre-Processors)：前处理器在每个线程开始执行请求之前运行。它们通常用于修改请求数据或准备测试环境。</li>
<li>采样器 (Samplers)：采样器发送请求并模拟用户与应用程序的交互。它们是性能测试的核心组件，根据线程组的配置以并发方式执行。</li>
<li>定时器 (Timers)：定时器用于模拟用户之间的时间间隔。它们控制线程之间的请求发送时间，以模拟负载。</li>
<li>后处理器 (Post-Processors)：后处理器在收到响应后运行。它们可以用于提取、处理或转换响应数据。</li>
<li>断言 (Assertions)：断言用于验证响应是否符合预期。它们在接收到响应后运行，并且如果断言失败，测试计划将标记为失败。</li>
<li>监听器 (Listeners)：监听器用于收集和显示测试结果。它们在测试执行过程中实时捕获和记录性能数据，也可以在测试结束后生成报告。</li>
<li>控制器 (Controllers)：控制器用于定义测试计划中的执行流程。它们控制着组件的执行顺序和条件。例如，循环控制器可以使一组组件多次执行。</li>
</ol>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p><strong>全局作用域组件</strong>：</p>
<ol>
<li><strong>HTTP Cookie 管理器</strong>：全局作用域。Cookie 管理器用于管理HTTP请求中的会话cookie，对整个测试计划可见。</li>
<li><strong>HTTP请求默认值</strong>：全局作用域。HTTP请求默认值组件用于设置全局HTTP请求属性，如协议、主机和端口，对整个测试计划可见。</li>
<li><strong>用户定义的变量</strong>：全局作用域。用户定义的变量允许您创建全局变量，以供测试计划中的各个部分使用，对整个测试计划可见。</li>
<li><strong>Keystore配置</strong>：全局作用域。Keystore配置用于管理SSL证书，对整个测试计划可见。</li>
</ol>
<p><strong>局部作用域组件</strong>：</p>
<ol>
<li><strong>HTTP请求</strong>：局部作用域。每个线程组可以包含自己的HTTP请求，这些请求仅在该线程组内部有效。</li>
<li><strong>前处理器和后处理器</strong>：局部作用域。前处理器和后处理器可以附加到特定请求或线程组，以定制请求的行为或处理响应。它们的作用仅限于它们所附加的请求或线程组。</li>
<li><strong>断言</strong>：局部作用域。每个线程组可以包含自己的断言，用于验证该线程组的请求响应。断言仅适用于所属的线程组。</li>
<li><strong>定时器</strong>：局部作用域。定时器可以附加到特定请求或线程组，用于控制请求之间的时间间隔。它们的作用仅限于它们所附加的请求或线程组。</li>
<li><strong>逻辑控制器</strong>：局部作用域。逻辑控制器用于定义特定请求的执行流程。每个线程组可以包含自己的逻辑控制器，它们的作用仅限于所属的线程组。</li>
<li><strong>循环控制器</strong>：局部作用域。循环控制器可以定义特定请求的循环次数。它们的作用仅限于所属的线程组</li>
</ol>
<h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><ol>
<li><strong>创建测试计划</strong>：打开 JMeter 并创建一个新的测试计划。</li>
</ol>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213153337812.png" alt="image-20231213153337812"></p>
<ol start="2">
<li><strong>设置线程组</strong>：在测试计划中，右键单击并添加线程组（Thread Group）。线程组用于定义并发用户的数量和测试执行次数。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213153548433.png" alt="image-20231213153548433" style="zoom:67%;" />

<ol start="3">
<li><strong>Http cookie管理器</strong>：在测试计划（线程组）右键添加，配置元件，添加cookie管理器。有些请求是包含cookie关联的，添加上管理器jmeter会自动的管理cookie信息。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213153949489.png" alt="image-20231213153949489" style="zoom:67%;" />

<ol start="4">
<li><strong>Http 请求默认值</strong>：在测试计划（线程组）中右键添加，配置元件，添加HTTP 请求默认值。用来填写对应的请求对应的 ip 地址、协议、内容编码格式和端口号等默认信息。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213154428919.png" alt="image-20231213154428919" style="zoom:67%;" />

<ol start="5">
<li><strong>取样器—http请求</strong>：在线程组下，添加HTTP请求（HTTP Request）或其他适当的采样器来模拟接口请求。（上传文件时需要勾上对post使用。。。）</li>
</ol>
<p><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213155631627.png" alt="image-20231213155631627"><br><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213155618069.png" alt="image-20231213155618069"  /></p>
<ol start="6">
<li><strong>断言</strong>：在对应的请求上右键，添加断言，选择对应的断言即可。用于对实际结果与预期结果的比较。可以添加多个断言来验证不同方面的响应。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213160203241.png" alt="image-20231213160203241" style="zoom:67%;" />

<ol start="7">
<li><strong>配置监听器</strong>：可以在线程组上添加监听器作用于整个线程组，也可在对应的请求上右键添加对应的监听器监听某一个请求。常见的监听器包括查看结果树、汇总报告、图形结果等。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213161921498.png" alt="image-20231213161921498" style="zoom:67%;" />
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213162009981.png" alt="image-20231213162009981" style="zoom:67%;" />
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213162110209.png" alt="image-20231213162110209" style="zoom:67%;" />

<h3 id="接口关联"><a href="#接口关联" class="headerlink" title="接口关联"></a>接口关联</h3><p>一般采用后置处理器处理对应的接口鉴权和接口关联信息。常用的有json提取器和正则表达式提取器。在对应的请求上右键添加，后置处理器，选择你需要的后置处理器即可。</p>
<h4 id="json提取器"><a href="#json提取器" class="headerlink" title="json提取器"></a>json提取器</h4><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213164037897.png" alt="image-20231213164037897" style="zoom:67%;" />
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213164247734.png" alt="image-20231213164247734" style="zoom:67%;" />

<p>后面采用 **${设置的名字}**使用对应的变量值。</p>
<hr>
<p>json提取器只能用于结果是json类型的数据，如果是普通的文本数据就需要用到正则表达式提取器。</p>
<hr>
<h4 id="调试结果取样器"><a href="#调试结果取样器" class="headerlink" title="调试结果取样器"></a>调试结果取样器</h4><p>通过在线程组上右键添加，取样器，调试结果取样器，并且将其拖动到查看结果树的上面，就可在查看结果树种观察到我们提取的参数的值。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213165143132.png" alt="image-20231213165143132" style="zoom:67%;" />

<h4 id="正则表达式提取器"><a href="#正则表达式提取器" class="headerlink" title="正则表达式提取器"></a>正则表达式提取器</h4><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213165833081.png" alt="image-20231213165833081" style="zoom:67%;" />
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213170144373.png" alt="image-20231213170144373" style="zoom:67%;" />

<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213170556157.png" alt="image-20231213170556157" style="zoom:67%;" />
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213170716647.png" alt="image-20231213170716647" style="zoom:67%;" />

<p>最后还是通过${对应的名字}来使用它的值。</p>
<h4 id="跨越线程组"><a href="#跨越线程组" class="headerlink" title="跨越线程组"></a>跨越线程组</h4><p>一般通过后置处理器提取到的变量，只能在当前线程组下才能使用。将其设置为全局属性才能在线程组间进行使用。</p>
<p>在提取参数值的请求上右键，添加，后置处理器，beanshell后置处理程序。</p>
<p>而后点击工具里的函数助手对话框。选择setProperty。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216141143455.png" alt="image-20231216141143455" style="zoom:67%;" />

<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216141401318.png" alt="image-20231216141401318" style="zoom:67%;" />

<p>最后，再次点击函数对话助手框，选择P函数。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231216141932897.png" alt="image-20231216141932897" style="zoom:67%;" />

<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>在测试时，比如添加某个物品时，不能重名，如果直接写对应的名字后，只能执行一次后就会报错。故需要给数据添加随机性。同时还包含一些<strong>加密函数</strong>等，用于对数据加密。<br>导航栏上选择工具，选择函数助手对话框，里面内置了许多的函数供我们使用。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213171538297.png" alt="image-20231213171538297" style="zoom:67%;" />

<p>示例：加密算法，且加密后将字符串转为大写。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213190233388.png" alt="image-20231213190233388" style="zoom:67%;" />

<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213190410437.png" alt="image-20231213190410437" style="zoom:67%;" />

<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>实现方式1：填写mime类型。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213185050910.png" alt="image-20231213185050910" style="zoom:67%;" />

<p>实现方式2：勾选对post使用，不填写mime类型。与上面类似，填写对应内容，但是勾选对post使用，且不填写mime类型。将高级里面实现选择java即可。（默认是httpclient4）</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213185331816.png" alt="image-20231213185331816" style="zoom:67%;" />

<h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><p>一般选择多个测试用例，多次执行该请求，包含正确的用例和错误的用例。<strong>一般一行代表一个测试用例，同时还应该代表预期返回的结果便于做结果断言。</strong></p>
<p>在对应的请求上右键，添加，配置元件，csv数据文件设置（可处理txt文件和csv文件）。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213191223399.png" alt="image-20231213191223399" style="zoom:67%;" />

<p>**说明：变量的使用都是${变量名}**。之后，设置循环器（不要使用线程组中的循环次数，虽然也能执行，但是是所有的请求都会执行那么多次。应为此次请求设置循环器，就只作用于此次请求）。线程组右键，添加，逻辑控制器，循环控制器。而后将对应请求拖动到while控制器内确保只对该请求生效。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231213191808181.png" alt="image-20231213191808181" style="zoom:67%;" />

<h3 id="测试片段"><a href="#测试片段" class="headerlink" title="测试片段"></a>测试片段</h3><p>测试片段（Test Fragment）是一种可重复使用的组件，用于存储测试计划中的通用配置和操作。测试片段允许您将一组关键字或配置元素封装到一个可重用的单元中，以便在多个测试计划或线程组中使用。这有助于减少重复工作，提高测试计划的可维护性。<strong>测试片段与线程组是同级的</strong>。</p>
<ul>
<li>当jmeter脚本非常复杂的时候，可以通过测试片段分模块管理用例</li>
<li>当jmeter脚本由多个测试人员共同完成，通过测试片段分人分模块管理用例</li>
</ul>
<p>比如：A测试购物车相关模块，B测试订单相关模块，但是都需要先进行登录。就进行了重复工作。就可以将登录测试封装成一个测试片段，然后A，B需要使用的时候直接调用该片段即可。</p>
<h4 id="新建测试片段"><a href="#新建测试片段" class="headerlink" title="新建测试片段"></a>新建测试片段</h4><p>在测试计划右键，添加，测试片段即可。而后再测试片段中添加你所需要的测试请求。最后选中将其保存为测试片段方便后面使用。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231214104049384.png" alt="image-20231214104049384" style="zoom:67%;" />

<h4 id="使用测试片段"><a href="#使用测试片段" class="headerlink" title="使用测试片段"></a>使用测试片段</h4><p>一般使用include控制器或模块控制器使用测试片段。</p>
<p>在线程组上右键添加，逻辑控制器，include控制器或者模块控制器。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231214104353938.png" alt="image-20231214104353938" style="zoom:67%;" />

<h5 id="include控制器"><a href="#include控制器" class="headerlink" title="include控制器"></a>include控制器</h5><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231214104522084.png" alt="image-20231214104522084" style="zoom:67%;" />

<h5 id="模块控制器"><a href="#模块控制器" class="headerlink" title="模块控制器"></a>模块控制器</h5><img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231214105106075.png" alt="image-20231214105106075" style="zoom:67%;" />

<h3 id="公共数据"><a href="#公共数据" class="headerlink" title="公共数据"></a>公共数据</h3><p>通过将一些数据定义为用户自定义的变量，能使得修改更加的方便。比如ip和端口号。</p>
<p>测试计划右键添加，配置元件，用户定义的变量。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231214110441786.png" alt="image-20231214110441786" style="zoom:67%;" />

<h3 id="数据库数据"><a href="#数据库数据" class="headerlink" title="数据库数据"></a>数据库数据</h3><ol>
<li>首先去官网下载对应的sql版本驱动。<a href="https://dev.mysql.com/downloads/connector/j/">驱动地址</a>，将下载好的驱动jar包放入jmeter的lib文件夹中。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231215110336901.png" alt="image-20231215110336901" style="zoom:67%;" />

<ol start="2">
<li>测试计划右键，添加，配置元件，JDBC Connection Configuration。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231215110718581.png" alt="image-20231215110718581" style="zoom:67%;" />

<p><strong>DataBase URL：</strong> jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;user?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8</p>
<ul>
<li>localhost:3306为数据库的地址和端口号；dataname为数据库名</li>
<li>useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8 指定字符的编码解码格式utf-8</li>
</ul>
<p><strong>JDBC Driver Class ：</strong> com.mysql.jdbc.Driver ，此为mysql数据库的驱动</p>
<p><strong>Username：</strong> 数据库的登录用户名</p>
<p><strong>Password：</strong> 数据库的密码</p>
<ol start="3">
<li>添加线程组，在线程组右键添加，取样器，JDBC Request。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231215111310243.png" alt="image-20231215111310243" style="zoom:67%;" />

<p>（一般取出的变量有几个，对应写几个变量在Variable names中，用逗号分隔，一一对应保存，后续方便使用，这里只做演示，将查询的所有结果保存在Result variable name中）</p>
<p><strong>（注意Result variable name为所有结果的保存变量名，单个变量名写在上面Variable neme中使用）</strong></p>
<ol start="4">
<li>在jdbc request中右键，添加，后置处理器，调试后置处理程序。查看对应的结果值（user值）</li>
<li>添加查看结果树查看整个结果。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231215112304757.png" alt="image-20231215112304757" style="zoom:67%;" />

<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231215112428284.png" alt="image-20231215112428284" style="zoom:67%;" />

<p>可以查看到将数据库中数据查出来并正确传递到了user值中。</p>
<ol start="6">
<li>对于数据库中查询出来的数据，一般使用for each循环处理器循环调用。在线程组右键添加逻辑控制器，foreach循环控制器。</li>
</ol>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231215113106058.png" alt="image-20231215113106058" style="zoom:67%;" />

<ol start="7">
<li>添加对应的http请求，然后传入的数据按照要求改即可。不仅可以通过${usera}使用对应的值。同时还可以使用${user_1}使用user中的第一个值。（根据上图，默认的语法就是在数字之前加上_，故可以直接使用${user_1}（<strong>注意不是usera，同时下标从1开始</strong>）（<strong>下划线的语法只针对Variable value变量有效</strong>）</li>
</ol>
<hr>
<p>将数据库中的所有数据进行数据驱动DDT。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231215115858828.png" alt="image-20231215115858828" style="zoom:67%;" />

<p><strong>（此处count应该写在Variable value中）</strong></p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231215115943544.png" alt="image-20231215115943544" style="zoom:67%;" />

<p>可以直接使用${count_1}。</p>
<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231215114528045.png" alt="image-20231215114528045" style="zoom:67%;" />
]]></content>
      <tags>
        <tag>测试</tag>
        <tag>接口测试</tag>
        <tag>Jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium元素定位和操作</title>
    <url>/2023/12/03/Selenium%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h2><p>Selenium是一个用于Web应用程序的自动化测试工具；中文的意思（硒）。Web自动化测试：让程序代替人工自动验证Web项目功能的过程。功能测试完毕(手工测试)之后，再进行Web自动化测试。Web自动化测试属于黑盒测试(功能测试)。（接口测试属于灰盒测试）<span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install selenium   <span class="comment">###安装</span></span><br><span class="line">selenium --version     <span class="comment">###检查</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">火狐浏览器</span><br><span class="line">1. Firefox 48 以上版本</span><br><span class="line">selenium 3.x + Firefox驱动(geckodriver)</span><br><span class="line">驱动下载地址：https://github.com/mozilla/geckodriver/releases</span><br><span class="line">2. Firefox 48 以下版本</span><br><span class="line">selenium 2.x + 内置驱动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">谷歌浏览器</span><br><span class="line">selenium 2.x/3.x + Chrome驱动(chromedriver)</span><br><span class="line">驱动下载地址：https://sites.google.com/a/chromium.org/chromedriver/downloads</span><br><span class="line">chromedriver版本 支持的Chrome版本</span><br><span class="line">2.41 v67-69</span><br><span class="line">2.40 v66-68</span><br><span class="line">2.39 v66-68</span><br><span class="line">2.38 v65-67</span><br><span class="line">2.37 v64-66</span><br><span class="line">2.36 v63-65</span><br><span class="line">2.35 v62-64</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edge浏览器(了解)</span><br><span class="line">selenium 3.x + Edge驱动(MicrosoftWebDriver)</span><br><span class="line">驱动下载地址：https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装浏览器驱动的步骤</span><br><span class="line">1. 下载浏览器驱动</span><br><span class="line">各个驱动下载地址： http://www.seleniumhq.org/download/</span><br><span class="line">浏览器的版本和驱动版本要一致！</span><br><span class="line">2. 把驱动文件所在目录添加到Path环境变量中</span><br><span class="line">或者直接放到Python安装目录，因为Python已添加到Path中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 科普path</span><br><span class="line">	说明：指定系统搜索的目录</span><br><span class="line">	dos命令默认搜索顺序：</span><br><span class="line">		1. 检测是否为内部命令</span><br><span class="line">		2. 检测是否为当前目录下可执行文件</span><br><span class="line">		3. 检测path环境变量指定的目录</span><br><span class="line">	提示：</span><br><span class="line">		如果以上搜索目录都检测不到输入的命令或可执行文件，系统会抛出不是内部或外部命令...</span><br><span class="line">		在web环境中，如果不将浏览器驱动添加到path中，selenium在运行的时候会提示浏览器驱动有误。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#入门案例</span></span><br><span class="line"><span class="comment"># 导包</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 创建浏览器驱动对象</span></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"><span class="comment"># driver = webdriver.Chrome()</span></span><br><span class="line"><span class="comment"># driver = webdriver.Edge()</span></span><br><span class="line"><span class="comment"># 加载web页面</span></span><br><span class="line">driver.get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line"><span class="comment"># 暂停3秒</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 关闭驱动对象</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h3 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h3><p>为什么要学习元素定位？<br>让程序操作指定元素，就必须先找到它。元素定位就是通过元素的信息或元素层级结构来定位元素的。</p>
<p>Selenium提供了八种定位元素方式</p>
<ol>
<li>id</li>
<li>name</li>
<li>class_name</li>
<li>tag_name</li>
<li>link_text</li>
<li>partial_link_text</li>
<li>XPath</li>
<li>CSS</li>
</ol>
<h4 id="id定位"><a href="#id定位" class="headerlink" title="id定位"></a>id定位</h4><p>说明：id定位就是通过元素的id属性来定位元素，HTML<strong>规定</strong>id属性在整个HTML文档中必须是<strong>唯一</strong>的；（<strong>但实际不唯一也没有问题</strong>）<br>前提：元素有id属性</p>
<p>方法：element &#x3D; driver.find_element_by_id(id)</p>
<h4 id="name定位"><a href="#name定位" class="headerlink" title="name定位"></a>name定位</h4><p>说明：name定位就是根据元素name属性来定位。HTML文档中name的属性值是可以重复的。<br>前提：元素有name属性</p>
<p>方法：element &#x3D; driver.find_element_by_name(name)</p>
<h4 id="class-name定位"><a href="#class-name定位" class="headerlink" title="class_name定位"></a>class_name定位</h4><p>说明：class_name定位就是根据元素class属性值来定位元素。HTML通过使用class来定义元素的样式。<br>前提：元素有class属性<br>注意：如果class有多个属性值，只能使用其中的一个</p>
<p>方法：element &#x3D; driver.find_element_by_class_name(class_name)</p>
<h4 id="tag-name定位"><a href="#tag-name定位" class="headerlink" title="tag_name定位"></a>tag_name定位</h4><p>说明：tag_name定位就是通过标签名来定位；HTML本质就是由不同的tag组成，每一种标签一般在页面中会存在多个，所以不方便进行精确定位，一般很少使用</p>
<p>方法：element &#x3D; driver.find_element_by_tag_name(tag_name)，如果存在多个相同标签，则返回符合条件的第一个标签</p>
<h4 id="link-text定位"><a href="#link-text定位" class="headerlink" title="link_text定位"></a>link_text定位</h4><p>说明：link_text定位是专门用来定位超链接元素<a>标签</a>，并且是通过超链接的文本内容来定位元素。</p>
<p>方法：element &#x3D; driver.find_element_by_link_text(link_text)，其中link_text：为超链接的全部文本内容，只能精确定位</p>
<h4 id="partial-link-text定位"><a href="#partial-link-text定位" class="headerlink" title="partial_link_text定位"></a>partial_link_text定位</h4><p>说明：partial_link_text定位是对link_text定位的补充，link_text使用全部文本内容匹配元素，而partial_link_text可以使用局部来匹配元素，也可以使用全部文本内容匹配元素。</p>
<p>方法：element &#x3D; driver.find_element_by_partial_link_text(partial_link_text)，其中partial_link_text：可以传入a标签局部文本-能表达唯一性的文本</p>
<hr>
<p><strong>以上方法若定位到多个元素，均返回定位到的第一个元素。</strong></p>
<hr>
<p>考虑以下问题，该如何定位元素？</p>
<ol>
<li>如果要定位的元素没有id、name、class属性，该如何进行定位？</li>
<li>如果通过name、class、tag_name无法定位到唯一的元素，该如何进行定位？</li>
</ol>
<p>于是又提出了XPath定位和CSS定位。</p>
<hr>
<h4 id="XPath定位"><a href="#XPath定位" class="headerlink" title="XPath定位"></a>XPath定位</h4><ol>
<li><strong>什么是XPath</strong></li>
</ol>
<p>XPath即为XML Path的简称，它是一门在 XML 文档中查找元素信息的语言。HTML可以看做是XML的一种实现，所以Selenium用户可以使用这种强大的语言在Web应用中定位元素。XML：一种标记语言，用于数据的存储和传递。 后缀.xml结尾</p>
<ol start="2">
<li><strong>定位方法</strong></li>
</ol>
<p>element &#x3D; driver.find_element_by_xpath(xpath)</p>
<ol start="3">
<li><strong>XPath定位策略</strong></li>
</ol>
<ul>
<li>路径-定位</li>
<li>利用元素属性-定位</li>
<li>属性与逻辑结合-定位</li>
<li>层级与属性结合-定位</li>
</ul>
<h5 id="路径定位"><a href="#路径定位" class="headerlink" title="路径定位"></a>路径定位</h5><p><strong>绝对路径</strong>：从最外层元素到指定元素之间所有经过元素层级的路径<br>1). 绝对路径以&#x2F;html根节点开始，使用 &#x2F; 来分隔元素层级；<br>如：&#x2F;html&#x2F;body&#x2F;div&#x2F;fieldset&#x2F;p[1]&#x2F;input<br>2). 绝对路径对页面结构要求比较严格，不建议使用</p>
<p><strong>相对路径</strong>：匹配任意层级的元素，不限制元素的位置<br>1). 相对路径以&#x2F;&#x2F;开始<br>2). 格式：&#x2F;&#x2F;input 或者 &#x2F;&#x2F;*</p>
<h5 id="利用元素属性定位"><a href="#利用元素属性定位" class="headerlink" title="利用元素属性定位"></a>利用元素属性定位</h5><p>说明：通过使用元素的属性信息来定位元素，解决上述定位多个标签元素问题<br>格式：&#x2F;&#x2F;input[@id&#x3D;’userA’] 或者 &#x2F;&#x2F;*[@id&#x3D;’userA’]</p>
<h5 id="属性与逻辑结合"><a href="#属性与逻辑结合" class="headerlink" title="属性与逻辑结合"></a>属性与逻辑结合</h5><p>说明：解决元素之间个相同属性重名问题，使用多个属性间的关系，即逻辑与或非<br>格式：&#x2F;&#x2F;*[@name&#x3D;’tel’ and @class&#x3D;’tel’]</p>
<h5 id="层级与属性结合"><a href="#层级与属性结合" class="headerlink" title="层级与属性结合"></a>层级与属性结合</h5><p>说明：如果通过元素自身的信息不方便直接定位到该元素，则可以先定位到其父级元素，然后再找到该元素<br>格式：&#x2F;&#x2F;*[@id&#x3D;’p1’]&#x2F;input</p>
<ol start="4">
<li><strong>XPath-延伸</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//*[text()=&quot;xxx&quot;] 文本内容是xxx的元素</span><br><span class="line">//*[contains(@attribute,&#x27;xxx&#x27;)] 属性中含有xxx的元素</span><br><span class="line">//*[starts-with(@attribute,&#x27;xxx&#x27;)] 属性以xxx开头的元素</span><br></pre></td></tr></table></figure>

<h4 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h4><ol>
<li><strong>什么是css定位？</strong></li>
</ol>
<p>CSS（Cascading Style Sheets）是一种语言，它用来描述HTML元素的显示样式；在CSS中，选择器是一种模式，用于选择需要添加样式的元素；在Selenium中也可以使用这种选择器来定位元素。在selenium中推荐<strong>使用CSS定位，因为它比XPath定位速度要快。</strong></p>
<ol start="2">
<li><strong>定位方法</strong></li>
</ol>
<p>element &#x3D; driver.find_element_by_css_selector(css_selector)</p>
<ol start="3">
<li><strong>CSS定位策略</strong></li>
</ol>
<ul>
<li>id选择器</li>
<li>class选择器</li>
<li>元素选择器</li>
<li>属性选择器</li>
<li>层级选择器</li>
</ul>
<h5 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h5><p>说明：根据元素id属性来选择<br>格式：#id<br>例如：#userA &lt;选择id属性值为userA的元素&gt;</p>
<h5 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h5><p>说明：根据元素class属性来选择<br>格式：.class<br>例如：.telA &lt;选择class属性值为telA的所有元素&gt;</p>
<h5 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h5><p>说明：根据元素的标签名选择<br>格式：element<br>例如：input &lt;选择所有input元素&gt;</p>
<h5 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h5><p>说明：根据元素的属性名和值来选择<br>格式：[attribute&#x3D;value]，element[attribute&#x3D;value]<br>例如：[type&#x3D;”password”]，选择type属性值为password的元素</p>
<h5 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h5><p>说明：根据元素的父子关系来选择<br><strong>格式1</strong>：element1&gt;element2 ，通过element1来定位element2，并且element2必须为element1的直接子元素<br>例如1：p[id&#x3D;’p1’]&gt;input，定位指定p元素下的直接子元素input</p>
<p><strong>格式2</strong>：element1 element2，通过element1来定位element2，并且element2为element1的后代元素<br>例如2：p[id&#x3D;’p1’] input，定位指定p元素下的后代元素input</p>
<ol start="4">
<li><strong>CSS延申</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input[type^=&#x27;p&#x27;]，type属性以p字母开头的元素</span><br><span class="line">input[type$=&#x27;d&#x27;]，type属性以d字母结束的元素</span><br><span class="line">input[type*=&#x27;w&#x27;]，type属性包含w字母的元素</span><br></pre></td></tr></table></figure>

<h4 id="定位一组元素"><a href="#定位一组元素" class="headerlink" title="定位一组元素"></a>定位一组元素</h4><p>作用： 查找定位所有符合条件的元素，返回的定位元素格式为数组(列表)格式；<br>说明： 列表数据格式的读取需要指定下标(下标从0开始)</p>
<p>方法： element&#x3D;driver.find_elements_by_XXX()。</p>
<h4 id="定位元素—延申写法"><a href="#定位元素—延申写法" class="headerlink" title="定位元素—延申写法"></a>定位元素—延申写法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导包：from selenium.webdriver.common.by import By</span><br><span class="line">方法：find_element(by=By.ID, value=None)</span><br><span class="line">备注：需要两个参数，第一个参数为定位的类型由By提供，第二个参数为定位的具体方式</span><br><span class="line">示例：</span><br><span class="line"> driver.find_element(By.CSS_SELECTOR, &#x27;#emailA&#x27;).send_keys(&quot;3113390285@qq.com&quot;)</span><br><span class="line"> driver.find_element(By.XPATH, &#x27;//*[@id=&quot;emailA&quot;]&#x27;).send_keys(&#x27;3113390285@qq.com&#x27;)</span><br><span class="line"> driver.find_element(By.ID, &quot;userA&quot;).send_keys(&quot;Honor HL&quot;)</span><br><span class="line"> driver.find_element(By.NAME, &quot;passwordA&quot;).send_keys(&quot;荷包蛋HL&quot;)</span><br><span class="line"> driver.find_element(By.CLASS_NAME, &quot;telA&quot;).send_keys(&quot;159837665**&quot;)</span><br><span class="line"> driver.find_element(By.TAG_NAME, &#x27;input&#x27;).send_keys(&quot;哪有小孩天天哭&quot;)</span><br><span class="line"> driver.find_element(By.LINK_TEXT, &#x27;访问 新浪 网站&#x27;).click()</span><br><span class="line"> driver.find_element(By.PARTIAL_LINK_TEXT, &#x27;访问&#x27;).click()</span><br><span class="line"></span><br><span class="line">说明：通过查看find_element_by_id底层实现方法，发现底层是调用find_element方法进行的封装；</span><br></pre></td></tr></table></figure>

<h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><p>为什么学习操作的方法？</p>
<ol>
<li>需要让脚本模拟用户给指定元素输入值</li>
<li>需要让脚本模拟人为删除元素的内容</li>
<li>需要让脚本模拟点击操作</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">click()   <span class="comment">#单击元素</span></span><br><span class="line">send_keys(value)    <span class="comment">#模拟输入</span></span><br><span class="line">clear()   <span class="comment">#清除文本</span></span><br></pre></td></tr></table></figure>

<h3 id="获取元素信息"><a href="#获取元素信息" class="headerlink" title="获取元素信息"></a>获取元素信息</h3><p>如何获取元素的文本？如何获取元素属性值？如何让程序判断元素是否为可见状态？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> size <span class="comment">#返回元素大小</span></span><br><span class="line"> text     <span class="comment">#获取元素的文本</span></span><br><span class="line"> get_attribute(<span class="string">&quot;xxx&quot;</span>)    <span class="comment">#获取属性值，传递的参数为元素的属性名</span></span><br><span class="line"> is_displayed()       <span class="comment">#判断元素是否可见</span></span><br><span class="line"> is_enabled()     <span class="comment">#判断元素是否可用</span></span><br><span class="line"> is_selected()     <span class="comment">#判断元素是否选中，用来检查复选框或单选按钮是否被选中</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 提示： size、text：为属性，调用时无括号；如：xxx.size</span></span><br><span class="line"><span class="comment"># get_attribute一般应用场景：判断一组元素是否为想要的元素或者判断元素属性值是否正确</span></span><br><span class="line"><span class="comment"># is_displayed、is_enabled、is_selected，在特殊应用场景中使用。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>测试</tag>
        <tag>Web测试</tag>
        <tag>爬虫</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>Web测试---PO模式</title>
    <url>/2023/12/18/Web%E6%B5%8B%E8%AF%95---PO%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Web测试"><a href="#Web测试" class="headerlink" title="Web测试"></a>Web测试</h2><p>Web UI测试是确保网站或应用程序用户界面的功能、外观和交互行为符合预期的测试过程。它包括以下方面：</p>
<ul>
<li><strong>功能性测试：</strong> 确保用户界面的各个部分按照预期工作。例如，按钮是否执行正确的操作，表单是否接收正确的输入等等。<span id="more"></span></li>
<li><strong>兼容性测试：</strong> 确保用户界面在不同的浏览器、操作系统和设备上能够正确显示和工作。</li>
<li><strong>可用性测试：</strong> 评估用户界面的易用性和可访问性。这包括确保界面清晰易懂，易于导航，并且对于所有用户（包括残障用户）都可以访问和操作。</li>
<li><strong>响应式设计测试：</strong> 确保界面在不同的屏幕尺寸和设备上能够适应和呈现良好。</li>
<li><strong>UI性能测试：</strong> 评估用户界面的性能，例如加载速度、交互响应时间等。</li>
</ul>
<h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>验证码是一种用于验证用户身份或确认用户不是自动程序（比如机器人或恶意软件）的安全机制。它通常以文字、数字、图像或音频的形式呈现给用户，要求用户根据提示进行输入或操作，以验证其是真实的人类用户。<strong>验证码就是用来防止自动化测试脚本自动化处理的</strong>。目前面对验证码，常用的几种操作为：</p>
<ol>
<li>去掉验证码—测试环境下可用 </li>
<li>设置万能验证码—生产测试环境下可用，注意保密。<strong>（以上都由开发进行相应工作的完成）</strong></li>
<li>验证码识别技术—精度不高，验证码越来越复杂</li>
<li>cookie—通过cookie跳过登录验证，前提是不能进行登录的测试。</li>
</ol>
<hr>
<p>在做UI自动化时定位元素特别依赖页面，一旦页面发生变更就不得不跟着去修改定位元素的代码。举例:假设要对一个元素进行点击操作，而且会经常对该元素进行操作，那么你就可能会编写多处如下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.find_element_by_id(<span class="string">&quot;1ogin-btn&quot;</span>).click()</span><br></pre></td></tr></table></figure>
<p>存在的问题:<br>如果开发人员修改了这个元素的id，这时候你就不得不修改所有对应的代码<br>存在大量冗余代码</p>
<hr>
<h3 id="PO模式"><a href="#PO模式" class="headerlink" title="PO模式"></a>PO模式</h3><p>“Page Object” 是一种软件测试设计模式，通常用于自动化测试中，特别是针对 web 应用程序的测试。它的核心思想是将页面的逻辑和行为封装到一个对象中，以便于测试代码的编写和维护。在 Page Object 模式中，每个页面或页面片段都被抽象为一个对象，对象中包含了该页面的元素定位、操作方法和行为。这种抽象使测试代码更加模块化、可读性更强、易于维护。</p>
<ol>
<li>提高可维护性和可重用性</li>
</ol>
<ul>
<li><strong>模块化结构：</strong> 将页面功能封装成对象，使得代码更加模块化和清晰。</li>
<li><strong>减少重复代码：</strong> 将页面元素定位和操作方法封装在对象中，减少了测试代码中的重复代码，提高了代码的重用性。</li>
</ul>
<ol start="2">
<li>简化测试用例</li>
</ol>
<ul>
<li><strong>清晰的接口：</strong> 提供了简洁、易读的接口，测试用例可以专注于业务逻辑而不是页面细节。</li>
<li><strong>易于维护：</strong> 当页面结构变化时，只需更新页面对象类，而不需要修改所有相关的测试用例。</li>
</ul>
<ol start="3">
<li>提高可读性和可维护性</li>
</ol>
<ul>
<li><strong>抽象化和封装：</strong> 隐藏了页面细节，使得测试代码更易读、易懂。</li>
<li><strong>减少耦合性：</strong> 页面对象模式降低了测试代码与页面结构的耦合，使得代码更加稳定。</li>
</ul>
<ol start="4">
<li>团队协作和开发效率</li>
</ol>
<ul>
<li><strong>便于团队协作：</strong> 使用 Page Object 模式可以提高团队协作，因为代码结构更清晰，每个成员都能更容易理解和使用。</li>
<li><strong>提高效率：</strong> 通过将页面功能抽象为对象，使得自动化测试代码更易于编写和维护，提高了开发效率。</li>
</ul>
<h4 id="公共层"><a href="#公共层" class="headerlink" title="公共层"></a>公共层</h4><p>在公共层中，可以包含以下内容：</p>
<ul>
<li>元素定位和操作方法（Element Locators and Actions）<ul>
<li>封装元素的定位方法，如使用 XPath、CSS 选择器等来定位页面元素。</li>
<li>封装元素的操作方法，如点击、输入文本、获取元素文本等操作。</li>
</ul>
</li>
<li>辅助函数和工具类（Utility Functions and Helper Classes）<ul>
<li>包括一些通用的辅助函数，比如日期处理、文件操作等。</li>
<li>可能还包括一些辅助类或方法，用于初始化测试环境、驱动器设置、日志记录等通用功能。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line"> <span class="comment">#初始化函数，传入需要的driver对象，一般由前置夹具生成，保证一次session会话的driver的唯一性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, driver</span>):</span><br><span class="line">        self.driver = driver</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查找元素方法 封装</span></span><br><span class="line">    <span class="comment"># loc=By.CSS_SELECTOR,&quot;.HL&quot;</span></span><br><span class="line">    <span class="comment"># loc变量为元组，*loc为解包，去掉没用的引号</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">base_find</span>(<span class="params">self, loc,  timeout=<span class="number">30</span>, poll=<span class="number">0.5</span></span>):</span><br><span class="line">        <span class="comment"># 使用显示等待 查找元素</span></span><br><span class="line">        <span class="comment">#查找时间间隔默认0.5s，超时时间为30秒</span></span><br><span class="line">        <span class="keyword">return</span> WebDriverWait(self.driver,</span><br><span class="line">                             timeout=timeout,</span><br><span class="line">                             poll_frequency=poll).until(<span class="keyword">lambda</span> x:x.find_element(*loc))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 点击元素 方法封装</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">base_click</span>(<span class="params">self, loc</span>):</span><br><span class="line">        self.base_find(loc).click()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入元素 方法封装</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">base_input</span>(<span class="params">self, loc, value</span>):</span><br><span class="line">        <span class="comment"># 获取元素</span></span><br><span class="line">        el = self.base_find(loc)</span><br><span class="line">        <span class="comment"># 清空</span></span><br><span class="line">        el.clear()</span><br><span class="line">        <span class="comment"># 输入</span></span><br><span class="line">        el.send_keys(value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取文本信息 方法封装（用于判断操作的成功与否）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">base_get_text</span>(<span class="params">self, loc</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base_find(loc).text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 截图 方法封装</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">base_get_image</span>(<span class="params">self</span>):</span><br><span class="line">        self.driver.get_screenshot_as_file(<span class="string">&quot;../image/&#123;&#125;.png&quot;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&quot;%Y_%m_%d %H_%M_%S&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断元素是否存在 方法封装</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">base_element_is_exist</span>(<span class="params">self, loc</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.base_find(loc, timeout=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 代表元素存在</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 代表元素不存在</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="页面层"><a href="#页面层" class="headerlink" title="页面层"></a>页面层</h4><p>页面层主要包含页面对象类（Page Object Classes），每个页面对象类代表一个页面或页面片段，并封装了该页面的元素定位和操作方法。</p>
<p>一个页面对象类通常包含以下内容：</p>
<ol>
<li>元素定位器（Element Locators）</li>
</ol>
<ul>
<li>包括页面中各个元素的定位方式，如XPath、CSS选择器、ID等。</li>
<li>这些定位器<strong>通常作为类中的属性，便于在类中进行使用。</strong></li>
</ul>
<ol start="2">
<li>页面操作方法（Page Action Methods）</li>
</ol>
<ul>
<li>封装了对页面元素的操作方法，如点击按钮、输入文本等。</li>
<li>这些方法用于执行特定的用户操作，隐藏了底层的元素定位和操作细节。</li>
</ul>
<ol start="3">
<li>页面状态检查方法（Page Assertion Methods）</li>
</ol>
<ul>
<li>用于验证页面状态或元素的方法，通常包括断言操作。</li>
<li>这些方法用于验证页面是否按预期加载、元素是否显示等。</li>
</ul>
<ol start="4">
<li>可能的业务逻辑方法（Business Logic Methods）</li>
</ol>
<ul>
<li>在某些情况下，页面对象类可能包含一些实现业务逻辑的方法，比如表单提交、搜索等。</li>
<li>这些方法封装了页面的业务流程，提高了测试代码的可读性和复用性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> page</span><br><span class="line"><span class="comment">#定位元素的基本数据放在page pathon文件夹下的_init_.py文件夹中</span></span><br><span class="line"><span class="keyword">from</span> base.base <span class="keyword">import</span> Base</span><br><span class="line"></span><br><span class="line"><span class="comment">#以登录页为例</span></span><br><span class="line"><span class="comment">#page python文件夹下的PageLogin类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageLogin</span>(<span class="title class_ inherited__">Base</span>):   <span class="comment">#继承上面的base类</span></span><br><span class="line">    <span class="comment"># 点击登录链接</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_click_login_link</span>(<span class="params">self</span>):</span><br><span class="line">        self.base_click(page.login_link)</span><br><span class="line">        <span class="comment">#page.login_link即为_init_.py中的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入用户名</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_input_username</span>(<span class="params">self, username</span>):</span><br><span class="line">        <span class="comment">#username即为文本框中填写的数据</span></span><br><span class="line">        <span class="comment">#page.login_username为定位到文本框，调用base里的相应函数</span></span><br><span class="line">        self.base_input(page.login_username, username)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入密码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_input_password</span>(<span class="params">self, pwd</span>):</span><br><span class="line">        self.base_input(page.login_pwd, pwd)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入验证码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_input_verify_code</span>(<span class="params">self, code</span>):</span><br><span class="line">        self.base_input(page.login_verify_code, code)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 点击登录按钮</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_click_login_btn</span>(<span class="params">self</span>):</span><br><span class="line">        self.base_click(page.login_btn)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取异常提示信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_get_error_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base_get_text(page.login_err_info)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 点击异常信息框 确定</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_click_err_btn_ok</span>(<span class="params">self</span>):</span><br><span class="line">        self.base_click(page.login_err_btn_ok)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 截图</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_get_img</span>(<span class="params">self</span>):</span><br><span class="line">        self.base_get_image()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 点击 安全退出 --》退出使用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_click_logout</span>(<span class="params">self</span>):</span><br><span class="line">        self.base_click(page.login_logout)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否登录成功</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_is_login_success</span>(<span class="params">self</span>):<span class="comment">#通过判断是否有退出登录按钮</span></span><br><span class="line">        <span class="keyword">return</span> self.base_element_is_exist(page.login_logout)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否退出成功</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_is_logout_success</span>(<span class="params">self</span>):<span class="comment">#通过判断是否有登录按钮</span></span><br><span class="line">        <span class="keyword">return</span> self.base_element_is_exist(page.login_link)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 组合业务方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_login</span>(<span class="params">self, username, pwd, code</span>):</span><br><span class="line">        self.page_input_username(username)</span><br><span class="line">        self.page_input_password(pwd)</span><br><span class="line">        self.page_input_verify_code(code)</span><br><span class="line">        self.page_click_login_btn()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#_init_.py</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="string">&quot;&quot;&quot;项目配置地址&quot;&quot;&quot;</span></span><br><span class="line">url = <span class="string">&quot;http://localhost&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;以下为登录页面元素配置信息&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 登录链接</span></span><br><span class="line">login_link = By.PARTIAL_LINK_TEXT, <span class="string">&quot;登录&quot;</span></span><br><span class="line"><span class="comment"># 用户名</span></span><br><span class="line">login_username = By.ID, <span class="string">&quot;username&quot;</span></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line">login_pwd = By.ID, <span class="string">&quot;password&quot;</span></span><br><span class="line"><span class="comment"># 验证码</span></span><br><span class="line">login_verify_code = By.ID, <span class="string">&quot;verify_code&quot;</span></span><br><span class="line"><span class="comment"># 登录按钮</span></span><br><span class="line">login_btn = By.CSS_SELECTOR, <span class="string">&quot;.J-login-submit&quot;</span></span><br><span class="line"><span class="comment"># 获取异常文本信息</span></span><br><span class="line">login_err_info = By.CSS_SELECTOR, <span class="string">&quot;.layui-layer-content&quot;</span></span><br><span class="line"><span class="comment"># 点击异常提示框 按钮</span></span><br><span class="line">login_err_btn_ok = By.CSS_SELECTOR, <span class="string">&quot;.layui-layer-btn0&quot;</span></span><br><span class="line"><span class="comment"># 安全退出</span></span><br><span class="line">login_logout = By.PARTIAL_LINK_TEXT, <span class="string">&quot;安全退出&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="测试层"><a href="#测试层" class="headerlink" title="测试层"></a>测试层</h4><p>测试层是指测试用例的集合，这些用例用于验证应用程序的特定功能、行为或业务流程。测试层包含了实际的测试用例和测试数据。</p>
<p>在测试层中，通常包含以下内容：</p>
<ol>
<li>测试用例（Test Cases）</li>
</ol>
<ul>
<li><strong>测试脚本：</strong> 包括编写测试逻辑的代码，调用页面对象类来执行测试步骤。</li>
<li><strong>测试数据：</strong> 不同的测试用例可能需要不同的输入数据和预期输出数据，这些数据用于验证系统的行为是否符合预期。</li>
</ul>
<ol start="2">
<li>测试断言和验证（Assertions and Validations）</li>
</ol>
<ul>
<li><strong>断言操作：</strong> 在测试用例中执行断言来验证系统的状态、页面元素的存在或特定操作的结果是否与预期一致。</li>
<li><strong>验证功能：</strong> 测试用例中包含验证步骤，确保被测试的功能按照预期执行。</li>
</ul>
<ol start="3">
<li>测试环境设置和清理</li>
</ol>
<ul>
<li><strong>测试前置条件：</strong> 在测试开始之前，可能需要进行一些测试环境的设置，比如初始化数据库、模拟用户登录等操作。</li>
<li><strong>测试后置条件：</strong> 在测试结束后，可能需要进行一些清理工作，比如删除测试数据、恢复测试环境等操作。</li>
</ul>
<ol start="4">
<li>测试报告和记录</li>
</ol>
<ul>
<li><strong>生成测试报告：</strong> 在测试执行完毕后，生成测试报告以汇总测试结果和执行情况。</li>
<li><strong>记录测试日志：</strong> 记录测试执行过程中的详细日志，便于排查问题和回溯测试执行路径。</li>
</ul>
<p>测试层是验证软件功能和行为的地方，它利用页面对象类来执行测试步骤，并进行验证和断言。测试用例和测试数据的设计非常重要，它们直接影响着测试的全面性和有效性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导包</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> base.get_driver <span class="keyword">import</span> GetDriver</span><br><span class="line"><span class="keyword">from</span> page.page_login <span class="keyword">import</span> PageLogin</span><br><span class="line"><span class="keyword">from</span> parameterized <span class="keyword">import</span> parameterized</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tool.read_json <span class="keyword">import</span> read_json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>():</span><br><span class="line">    arrs = []</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> read_json(<span class="string">&quot;login.json&quot;</span>).values():</span><br><span class="line">        arrs.append((data.get(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">                     data.get(<span class="string">&quot;password&quot;</span>),</span><br><span class="line">                     data.get(<span class="string">&quot;verify_code&quot;</span>),</span><br><span class="line">                     data.get(<span class="string">&quot;expect_result&quot;</span>),</span><br><span class="line">                     data.get(<span class="string">&quot;success&quot;</span>)))</span><br><span class="line">    <span class="keyword">return</span> arrs <span class="comment"># 注意：必须进行return 返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建测试类 并使用pytest框架</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestLogin</span>():</span><br><span class="line">    login = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># setUp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setUpClass</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="comment"># 实例化 获取页面对象 PageLogin</span></span><br><span class="line">        cls.login = PageLogin(GetDriver().get_driver())</span><br><span class="line">        <span class="comment"># 点击登录连接</span></span><br><span class="line">        cls.login.page_click_login_link()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tearDown</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tearDownClass</span>(<span class="params">cls</span>):</span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 关闭 driver驱动对象</span></span><br><span class="line">        GetDriver().quit_driver()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登录测试方法</span></span><br><span class="line"><span class="meta">    @parameterized.expand(<span class="params">get_data(<span class="params"></span>)</span>)</span></span><br><span class="line">    <span class="comment">#使用@pytest.mark.parametrize(&quot;username, pwd, code, expect_result, success&quot;, get_data())替代</span></span><br><span class="line">    <span class="comment">#名字不需要完全相同，一一对应即可。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_login</span>(<span class="params">self, username, pwd, code, expect_result, success</span>):</span><br><span class="line">        <span class="comment"># 调用登录方法</span></span><br><span class="line">        self.login.page_login(username, pwd, code)</span><br><span class="line">        <span class="keyword">if</span> success:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 判断安全退出是否存在</span></span><br><span class="line">                self.assertTrue(self.login.page_is_login_success())</span><br><span class="line">                <span class="comment"># 点击退出</span></span><br><span class="line">                self.login.page_click_logout()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self.assertTrue(self.login.page_is_logout_success)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="comment"># 截图</span></span><br><span class="line">                    self.login.page_get_img()</span><br><span class="line">                <span class="comment"># 点击登录连接</span></span><br><span class="line">                self.login.page_click_login_link()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="comment"># 截图</span></span><br><span class="line">                self.login.page_get_img()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 获取登录提示信息</span></span><br><span class="line">            msg = self.login.page_get_error_info()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 断言</span></span><br><span class="line">                self.assertEqual(msg, expect_result)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> AssertionError:</span><br><span class="line">                <span class="comment"># 截图</span></span><br><span class="line">                self.login.page_get_img()</span><br><span class="line">            <span class="comment"># 点击 确认框</span></span><br><span class="line">            self.login.page_click_err_btn_ok()</span><br></pre></td></tr></table></figure>

<h4 id="浏览器获取"><a href="#浏览器获取" class="headerlink" title="浏览器获取"></a>浏览器获取</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方式一</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> page</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetDriver</span>:</span><br><span class="line">    <span class="comment"># 设置类属性</span></span><br><span class="line">    driver = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取driver</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_driver</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">if</span> cls.driver <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 实例化浏览器</span></span><br><span class="line">            cls.driver = webdriver.Firefox()</span><br><span class="line">            <span class="comment"># 最大化</span></span><br><span class="line">            cls.driver.maximize_window()</span><br><span class="line">            <span class="comment"># 打开浏览器</span></span><br><span class="line">            cls.driver.get(page.url)</span><br><span class="line">        <span class="keyword">return</span> cls.driver</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 退出driver</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quit_driver</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">if</span> cls.driver:</span><br><span class="line">            cls.driver.quit()</span><br><span class="line">            <span class="comment"># 注意：此处有一个很大坑,退出之后需要将drive置空</span></span><br><span class="line">            cls.driver = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># print(&quot;置空之后：&quot;, cls.driver)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方式二,而后函数中使用broswer调用对应的浏览器，且一次session有效</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver =<span class="literal">None</span></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;session&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">browser</span>():</span><br><span class="line">    <span class="keyword">global</span> driver</span><br><span class="line">    <span class="keyword">if</span> driver <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    	driver = webdriver.Chrome()  <span class="comment"># 例如，这里使用 Chrome 作为示例，你可以选择其他浏览器</span></span><br><span class="line">    	driver.maximize_window()<span class="comment">#最大化窗口</span></span><br><span class="line">    <span class="keyword">yield</span> driver</span><br><span class="line">    driver.quit()</span><br><span class="line">    driver = <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>测试</tag>
        <tag>Web测试</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest单元测试框架（基础篇）</title>
    <url>/2023/11/21/pytest%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h2><p>​		1）什么是单元测试框架</p>
<p>​		单元测试框架是指在软件开发的过程种，针对软件的最小单位（函数、方法）进行正确性测试</p>
<span id="more"></span>

<p>​		2）常见的单元测试框架</p>
<p>​		基于java的：junit和testng</p>
<p>​		基于python的：unittest和<strong>pytest</strong></p>
<p>​		3）单元测试流程</p>
<p>​		1.测试发现：从多个文件中找到需要被测试的测试用例</p>
<p>​		2.测试执行：按照一定的顺序执行测试用例，并生成结果</p>
<p>​		3.测试判断：通过assert断言来自动判断结果与预期是否相符</p>
<p>​		4.测试报告：生成这次测试的测试报告，包括耗时、通过率等</p>
<h2 id="pytest"><a href="#pytest" class="headerlink" title="pytest"></a>pytest</h2><p>​		1）简介</p>
<p>​		pytest是python的一种单元测试框架，与python自带的测试框架unittest类似，但比其更易上手，也更加的灵活。因此使用面也广于unittest。</p>
<ul>
<li><p>pytest比unittest更加成熟，同时支持unittest编写的测试用例</p>
</li>
<li><p>pytest可以和selenium，request，appium等测试框架相结合，实现web ui自动化，web 接口自动化，app ui自动化</p>
</li>
<li><p>pytest可以实现测试用例的跳过以及失败用例重试</p>
</li>
<li><p>pytest支持参数化数据驱动方式</p>
</li>
<li><p>pytest可以和Jenkins持续集成</p>
</li>
<li><p>pytest具有很多第三方插件，且支持自定义扩展</p>
<ul>
<li><p>pytest：单元测试框架</p>
<p>pytest-xdist： 测试用例的分布式执行，即并发执行。可缩短总的用例的执行时间</p>
<p>pytest-ordering： 可以指定测试用例的执行顺序，默认是从上到下依次执行</p>
<p>pytest-rerunfailures： 用例失败后进行再次执行（多用于ui测试）</p>
<p>pytest-html： 生成html格式的测试报告（不够美观）</p>
<p>allure-pytest： 生成比上面美观的测试报告，且可进行测试报告的自定义</p>
</li>
</ul>
</li>
</ul>
<p>​		2）安装</p>
<p>​		新建python项目———在本地虚拟终端中执行以下命令即可。（注意：使用以上插件也需要安装到本地环境中，语法类似）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pytest   <span class="comment">#安装命令</span></span><br><span class="line"></span><br><span class="line">pytest --version     <span class="comment">#检查命令</span></span><br></pre></td></tr></table></figure>

<p>​		3）使用pytest</p>
<p>​		pytest的默认测试用例发现规则</p>
<ul>
<li><p>模块名（简单理解为一个py文件）以test_ 开头或 _test结尾</p>
</li>
<li><p>测试类以Test开头，并且不包含init()方法</p>
</li>
<li><p>测试方法以test开头</p>
<p>4）运行pytest</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">TestName</span>():</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">testName</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;hello,pytest&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     pytest.main()</span><br></pre></td></tr></table></figure>

<h2 id="pytest运行方式"><a href="#pytest运行方式" class="headerlink" title="pytest运行方式"></a>pytest运行方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参数详解:</span><br><span class="line">-s:输出调试信心，包括<span class="built_in">print</span>打印的信息</span><br><span class="line">-v:显示更详细的信息</span><br><span class="line">-vs:两个连用，效用就是两个相加</span><br><span class="line">-n NUM: 支持多线程或分布式运行测试用例，使用NUM个线程。需要导入pytest-xdist插件</span><br><span class="line">--<span class="built_in">return</span> NUM:失败用例重跑NUM次，失败用例总共运行NUM+1次</span><br><span class="line">-x:有一个用例失败报错，则停止测试，默认是不停止测试</span><br><span class="line">--maxfail=NUM:出现NUM个失败用例就停止测试</span><br><span class="line">-k String:根据String字符串匹配对应的测试用例</span><br><span class="line">--html 文件路径/文件名：生成html格式的测试报告</span><br></pre></td></tr></table></figure>

<p>​		1）主函数方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件夹与python package的区别：python package下包含一个_init_.py文件</span></span><br><span class="line"><span class="comment"># ./  :表示当前文件路径下</span></span><br><span class="line"><span class="comment"># ../  :表示当前文件路径的父路径，即向上一层</span></span><br><span class="line">pytest.main()    <span class="comment">#运行所有的按条件写的测试用例</span></span><br><span class="line">pytest.main(<span class="string">&#x27;-vs&#x27;</span>,<span class="string">&#x27;./tasecase&#x27;</span>)   <span class="comment">#运行tasecase文件夹下的测试用例</span></span><br><span class="line">pytest.main(<span class="string">&#x27;-x&#x27;</span>,<span class="string">&#x27;test01.py&#x27;</span>)    <span class="comment">#运行test01模块下的测试用例,且出现错误就停止测试</span></span><br><span class="line">pytest.mian(<span class="string">&#x27;-n 2&#x27;</span>,<span class="string">&#x27;./tesecase/test01.py::TestName::testName&#x27;</span>)   <span class="comment">#运行testcase文件夹下test01模块里TsetName类里的testName方法,且使用两个线程</span></span><br></pre></td></tr></table></figure>

<p>​		2）命令行模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#即在安装pytest的本地虚拟环境中运行</span></span><br><span class="line">pytest     <span class="comment">#运行所有满足条件的测试用例</span></span><br><span class="line">pytest -vs ./testcase   <span class="comment">#运行tasecase文件夹下的测试用例</span></span><br><span class="line">pytest -x ./testcase/test01.py    <span class="comment">#运行test01模块下的测试用例,且出现错误就停止测试</span></span><br><span class="line">pytest -n 2 ./tesecase/test01.py::TestName::testName    <span class="comment">#运行testcase文件夹下test01模块里TsetName类里的testName方法,且使用两个线程</span></span><br></pre></td></tr></table></figure>

<p>​		3）全局配置模式</p>
<p>​		通过读取pytest.ini文件得到对应的配置信息，最后在命令行输入pytest即可运行（名字不可变，只能为pytest.ini）</p>
<ul>
<li>文件位置：放在项目的根目录，即最外层即可</li>
<li>编码格式：必须为ANSI格式，可使用notpad++修改格式</li>
<li>运行规则：不论是主函数方式还是命令行方式，都会优先读取该配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#模板，前面的参数是不可变的，后面根据实际情况填写</span></span><br><span class="line"></span><br><span class="line">[<span class="string">pytest</span>]</span><br><span class="line"><span class="string">addopts</span> <span class="string">=</span> <span class="string">-vs</span> <span class="comment">#命令行的参数，用空格分隔</span></span><br><span class="line"><span class="string">testpaths</span> <span class="string">=</span> <span class="string">./testcase</span> <span class="comment">#测试用例的路径</span></span><br><span class="line"><span class="string">python_files</span> <span class="string">=</span> <span class="string">test_*.py</span> <span class="comment">#模块名的规则，可以更改默认规则</span></span><br><span class="line"><span class="string">python_classes</span> <span class="string">=</span> <span class="string">Test*</span> <span class="comment">#类名的规则</span></span><br><span class="line"><span class="string">python_functions</span> <span class="string">=</span> <span class="string">test</span> <span class="comment">#方法名的规则</span></span><br><span class="line"><span class="string">markers</span> <span class="string">=</span></span><br><span class="line">  <span class="string">smoke:冒烟用例</span>          <span class="comment">#设置独有的标记</span></span><br><span class="line">  <span class="string">usermanage:用户管理模块</span></span><br><span class="line">  <span class="string">productmanage:商品管理模块</span></span><br></pre></td></tr></table></figure>

<p>​		4）改变执行顺序</p>
<p>​		pytest默认的执行顺序是从上到下，改变默认执行顺序，使用mark标记。（需要引入pytest-ordering插件）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestName</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello,pytest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">99</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAge</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myage&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">100</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAddr</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myaddr&quot;</span>)</span><br><span class="line">        </span><br><span class="line">   <span class="comment">#优先执行带注释的用例，且order值越小，优先执行</span></span><br></pre></td></tr></table></figure>

<p>​		5）分组执行</p>
<p>​		在实际的测试场景中，需要对一类的用例进行优先测试，如，冒烟测试、用户管理模块测试、商品管理模块测试等。（还记得上面pytest.ini文件中得makers标记吗？就是用来自定自己的分组的）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.somke</span></span><br><span class="line"><span class="comment">#在对应的方法上添加注解即可</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行</span></span><br><span class="line">pytest -m <span class="string">&quot;smoke&quot;</span> <span class="comment">#执行smoke模块测试用例</span></span><br><span class="line">pytest -m <span class="string">&quot;smoke or usermanage or productmanage&quot;</span>  <span class="comment">#执行这三个模块的测试用例</span></span><br></pre></td></tr></table></figure>

<p>​		6）跳过测试用例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestName</span>():</span><br><span class="line"></span><br><span class="line">    age=<span class="number">18</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello,pytest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">99</span></span>)</span></span><br><span class="line"><span class="meta">    @pytest.mark.skipif(<span class="params">age&gt;<span class="number">18</span>,reason=<span class="string">&quot;年龄已经大于18，不用测啦&quot;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAge</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myage&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.skip(<span class="params">reas=<span class="string">&quot;不想测试这个啦&quot;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAddr</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myaddr&quot;</span>)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  输出</span></span><br><span class="line"><span class="string">testcase/test_01.py::TestName::testAge myage PASSED testcase/test_01.py::TestName::testName hello,pytest PASSED testcase/test_01.py::TestName::testAddr SKIPPED (不想测试这个啦)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 当age=19时，输出</span></span><br><span class="line"><span class="string">testcase/test_01.py::TestName::testAge SKIPPED (年龄已经大于18，不用测啦) testcase/test_01.py::TestName::testName hello,pytest PASSED testcase/test_01.py::TestName::testAddr SKIPPED (不想测试这个啦)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<a href="/2023/11/27/pytest%E8%BF%9B%E9%98%B6/" title="pytest单元测试框架（进阶篇）">pytest单元测试框架（进阶篇）</a>





]]></content>
      <tags>
        <tag>测试</tag>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest单元测试框架（进阶篇）</title>
    <url>/2023/11/27/pytest%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<a href="/2023/11/21/pytest%E5%9F%BA%E7%A1%80/" title="pytest单元测试框架（基础篇）">pytest单元测试框架（基础篇）</a>讲解了pytest的基本运用，下面将继续介绍其的高阶用法。

<h2 id="测试夹具"><a href="#测试夹具" class="headerlink" title="测试夹具"></a>测试夹具</h2><p>​		1）什么是夹具？</p>
<p>​		在自动化测试过程中，为测试用例提前准备的一个运行环境，这个测试环境被称为测试夹具。测试夹具的本质是一个函数，在测试用例方法执行之前的称为前置条件，测试用例方法执行之后的称为后置条件。</p>
<span id="more"></span>

<p>​		2）为什么需要夹具</p>
<p>​		比如在进行web ui测试时，需要打开浏览器（前置条件），关闭浏览器（后置条件）；比如在进行接口自动化测试时，接口关联的参数值写入yaml文件，测试之前需要清空yaml文件（前置条件）；比如测试时需要记录日志，日志对象的生成（前置条件），日志对象的销毁（后置条件）。</p>
<p>​		2）常用的pytest夹具</p>
<ul>
<li>setup&#x2F;teardown，setup_class&#x2F;teardown_class</li>
<li>@pytest.fixture()</li>
<li>conftest.py和@pytest.fixture()结合</li>
</ul>
<h3 id="setup-teardown，setup-class-teardown-class"><a href="#setup-teardown，setup-class-teardown-class" class="headerlink" title="setup&#x2F;teardown，setup_class&#x2F;teardown_class"></a>setup&#x2F;teardown，setup_class&#x2F;teardown_class</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestName</span>():</span><br><span class="line"></span><br><span class="line">    age=<span class="number">19</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello,pytest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">99</span></span>)</span></span><br><span class="line">   <span class="comment"># @pytest.mark.skipif(age&gt;18,reason=&quot;年龄已经大于18，不用测啦&quot;)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAge</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myage&quot;</span>)</span><br><span class="line">        </span><br><span class="line">   <span class="comment"># @pytest.mark.skip(reason=&quot;不想测试这个啦&quot;)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAddr</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;myaddr&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始进行测试用例---作用范围为单个方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;测试用例结束---作用范围单个方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup_class</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始进行测试用例，对TestName类&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown_class</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;结束对TestName类的测试&quot;</span>)</span><br><span class="line">        </span><br><span class="line">  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">testcase/test_01.py:: TestName : :testAge开始进行测试用例，对TestName类</span></span><br><span class="line"><span class="string">开始进行测试用例---作用范围为单个方法</span></span><br><span class="line"><span class="string">myage</span></span><br><span class="line"><span class="string">PASSED测试用例结束---作用范围单个方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">testcase/test_01.py : :TestName : :testName 开始进行测试用例---作用范围为单个方法</span></span><br><span class="line"><span class="string">hello , pytest</span></span><br><span class="line"><span class="string">PASSED测试用例结束---作用范围单个方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">testcase/test_01.py : :TestName : :testAddr开始进行测试用例---作用范围为单个方法</span></span><br><span class="line"><span class="string">myaddr</span></span><br><span class="line"><span class="string">PASSED测试用例结束---作用范围单个方法</span></span><br><span class="line"><span class="string">结束对TestName类的测试</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#不建议使用此方法，抛出了警告信息（已过时），且此方法针对所有的测试用例都必须执行该方法，不能选择一部分执行。</span></span><br><span class="line"><span class="comment">#@pytest.fixture()装饰器模式可以对部分方法的前后置方法</span></span><br></pre></td></tr></table></figure>

<h3 id="pytest-fixture"><a href="#pytest-fixture" class="headerlink" title="@pytest.fixture()"></a>@pytest.fixture()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上代码</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&#x27;function&#x27;</span>, params=[<span class="string">&#x27;成龙&#x27;</span>, <span class="string">&#x27;甄子丹&#x27;</span>, <span class="string">&#x27;菜10&#x27;</span>]</span>)</span></span><br><span class="line"><span class="comment">#这参数有什么作用呢？引出后面的数据驱动DDT</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_fixture</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;前置函数&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> request.param</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;后置函数&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestPytest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_Pytest</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test01&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_02</span>(<span class="params">self,my_fixture</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test02&quot;</span>)</span><br><span class="line">        <span class="comment">#print(my_fixture)  //返回成龙，甄子丹，菜10</span></span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;&quot;&quot;输出</span></span><br><span class="line"><span class="string">test_Pytest.py::TestPytest::test_Pytest test01 PASSED test_Pytest.py::TestPytest::test_02[成龙] 前置函数</span></span><br><span class="line"><span class="string">test02 PASSED后置函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test_Pytest.py::TestPytest::test_02[甄子丹] 前置函数</span></span><br><span class="line"><span class="string">test02 PASSED后置函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test_Pytest.py::TestPytest::test_02[菜10] 前置函数</span></span><br><span class="line"><span class="string">test02 PASSED后置函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;&quot;</span>,params=<span class="string">&quot;&quot;</span>,autouse=<span class="string">&quot;&quot;</span>,ids=<span class="string">&quot;&quot;</span>,name=<span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(1)scope表示的是被@pytest.fixture标记的方法的作用域。function(默认)，class，module，package/session.</span></span><br><span class="line"><span class="string">		session 会话级别：每个session只运行一次，session级别的fixture需要定义到conftest.py中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		module 模块级别：模块里所有的用例执行前执行一次module级别的fixture，即单个py文件执行一次模块级别</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		class 类级别 ：每个类执行前都会执行一次class级别的fixture</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		function ：此模式是默认的模式，函数级别的，每个测试用例执行前都会执行一次function级别的fixture</span></span><br><span class="line"><span class="string">(2)params：参数化（支持，列表[]，元祖()，字典列表[&#123;&#125;,&#123;&#125;,&#123;&#125;]，字典元祖(&#123;&#125;,&#123;&#125;,&#123;&#125;)，循环执行，每次取下一个</span></span><br><span class="line"><span class="string">(3)autouse=True：自动使用，默认False</span></span><br><span class="line"><span class="string">(4)ids：当使用params参数化时，给每一个值设置一个变量名。意义不大。</span></span><br><span class="line"><span class="string">(5)name：给表示的是被@pytest.fixture标记的方法取一个别名。意义不大</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">yield前面是前置函数，yield后面是后置函数，且yield能将后面的结果return给对应的用例函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">问题：使用时，每个类或者模块里都需要定义对应的函数，才能被调用执行。代码复用性不强</span></span><br><span class="line"><span class="string">如何在一个地方定义夹具函数，所有的用例函数都能调用到呢？</span></span><br><span class="line"><span class="string">有请我们的conftest.py文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="conftest-py结合-pytest-fixture"><a href="#conftest-py结合-pytest-fixture" class="headerlink" title="conftest.py结合@pytest.fixture()"></a>conftest.py结合@pytest.fixture()</h3><p>​		通过使用conftest.py文件和@pytest.fixture结合，实现全局的夹具配置</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">conftest.py文件是单独存放的一个夹具配置文件，名称是不能更改。</span></span><br><span class="line"><span class="string">可以在不同的py文件中使用同一个fixture函数。</span></span><br><span class="line"><span class="string">原则上conftest.py需要和运行的用例放到统一层(一般放在根目录下即可）。并且不需要做任何的imprt导入的操作。</span></span><br><span class="line"><span class="string">写法与@pytest.fiuture无异，只不过将定义的函数都放在conftest.py文件中</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>setup&#x2F;teardown，setup_class&#x2F;teardown_class 它是作用于所有用例或者所有的类 </p>
<p>@pytest.fixtrue() 它的作用是既可以部分也可以全部前后置。 </p>
<p>conftest.py和@pytest.fixtrue()结合使用，作用于全局的前后置。</p>
<h2 id="allure报告"><a href="#allure报告" class="headerlink" title="allure报告"></a>allure报告</h2><p>​		1）下载</p>
<p>​		<a href="https://github.com/allure-framework/allure2/releases">Releases · allure-framework&#x2F;allure2 (github.com)</a></p>
<p>​		2）配置bin</p>
<p>​		找到安装的allure文件夹的bin路径，将其加入path中即可。</p>
<p>​		3）使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pytest [测试文件] --alluredir=./result <span class="comment">#--alluredir用于指定存储测试结果的路径</span></span><br><span class="line">allure serve ./result  <span class="comment">#生成页面报告</span></span><br></pre></td></tr></table></figure>

<h2 id="数据驱动DDT"><a href="#数据驱动DDT" class="headerlink" title="数据驱动DDT"></a>数据驱动DDT</h2><p>​		DDT即data-driver test，数据驱动测试。 以数据来驱动整个测试用例的执行（即测试数据决定测试结果）,核心使用@pytest.mark.parametrize</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test_Demo</span>():</span><br><span class="line">    <span class="comment">#前面可以为String，list，元组，逗号分隔</span></span><br><span class="line">    <span class="comment"># @pytest.mark.parametrize(&quot;a, b, result&quot;, [(1, 1, 2), (2, 8, 10)])</span></span><br><span class="line">    <span class="comment"># @pytest.mark.parametrize((&quot;a, b, result&quot;), data)</span></span><br><span class="line"><span class="meta">    @pytest.mark.parametrize(<span class="params">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;result&quot;</span>],yaml.safe_load(<span class="params"><span class="built_in">open</span>(<span class="params"><span class="string">&quot;./data.yaml&quot;</span></span>)</span>)</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_case1</span>(<span class="params">self, a, b, result</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n开始执行测试用例1&quot;</span>)</span><br><span class="line">        <span class="keyword">assert</span> a + b == result</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>测试</tag>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>java杂谈---1</title>
    <url>/2024/01/04/java%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<h3 id="jdk，jre，jvm"><a href="#jdk，jre，jvm" class="headerlink" title="jdk，jre，jvm"></a>jdk，jre，jvm</h3><ol>
<li><strong>JDK（Java Development Kit）</strong>：<ul>
<li>JDK是Java开发工具包，它包含了用于开发Java程序的工具和库。<span id="more"></span></li>
<li>它包括<strong>Java编译器（javac）、Java运行时环境（JRE）、调试器和其他开发工具</strong>。</li>
<li>JDK允许开发人员编写、编译和调试Java程序。</li>
</ul>
</li>
<li><strong>JRE（Java Runtime Environment）</strong>：<ul>
<li>JRE是Java运行时环境，它提供了Java程序运行所需的环境。</li>
<li>包括<strong>Java虚拟机（JVM）、Java核心类库</strong>以及其他支持文件。</li>
<li>JRE允许用户在计算机上运行Java程序，但不包含用于编译Java程序的工具。</li>
</ul>
</li>
<li><strong>JVM（Java Virtual Machine）</strong>：<ul>
<li>JVM是<strong>Java虚拟机，它是Java程序运行的核心部分</strong>。</li>
<li>它负责将<strong>Java字节码（由Java编译器生成）翻译成特定操作系统的机器代码，并执行程序</strong>。</li>
<li>JVM提供了内存管理、垃圾回收和其他运行时环境的支持，以确保Java程序可以在不同平台上保持一致的行为。</li>
</ul>
</li>
</ol>
<p>总结：jDK是用于开发Java程序的工具包，其中包含了JRE。JRE包含了运行Java程序所需的环境，其中包括JVM。jvm负责执行Java程序。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li><code>byte</code>：8 位有符号整数，范围为 -128 到 127。1字节</li>
<li><code>short</code>：16 位有符号整数，范围为 -32,768 到 32,767。2字节</li>
<li><code>int</code>：32 位有符号整数，范围为 -2^31 到 2^31 - 1。4字节</li>
<li><code>long</code>：64 位有符号整数，范围为 -2^63 到 2^63 - 1。8字节</li>
<li><code>float</code>：32 位单精度浮点数，范围为大约 -3.4E+38 到 3.4E+38，有效精度约为 6~7 位小数。4字节</li>
<li><code>double</code>：64 位双精度浮点数，范围为大约 -1.7E+308 到 1.7E+308，有效精度约为 15 位小数。8字节</li>
<li><code>char</code>：16 位无符号Unicode字符，范围为 0 到 65,535。2字节</li>
<li><code>boolean</code>：表示布尔值，只有两个取值，<code>true</code> 或 <code>false</code>。1字节</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">boolean编译时不谈占几个字节。</span><br><span class="line"></span><br><span class="line">但是JVM在给boolean类型分配内存空间时，boolean类型的变量占据一个槽位(slot，等于4个字节)。</span><br><span class="line">细节：true:1  false:0</span><br><span class="line"></span><br><span class="line">&gt;拓展：在内存中，byte\short\char\boolean\int\float : 占用1个slot</span><br><span class="line">              double\long :占用2个slot</span><br><span class="line">             </span><br><span class="line"> //占用一个槽位但是用不完  boolean、byte：1字节  char、short：2字节 </span><br><span class="line"> // int、float：4字节（1槽位）  double、long：8字节（2槽位）</span><br></pre></td></tr></table></figure>

<h3 id="类型运算"><a href="#类型运算" class="headerlink" title="类型运算"></a>类型运算</h3><ol>
<li>byte，char，short相加的时候，会自动转化为int类型，再相加，结果也还是int。</li>
<li>byte<code>-&gt;</code>short<code>-&gt;</code>int<code>-&gt;</code>long<code>-&gt;</code>float<code>-&gt;</code>double，左边能自动转换为右边，而右边到左边需要强制转换，且可能导致溢出。低精度的数与高精度的数相加，结果为高精度的数。</li>
<li>表达式的类型是由最高精度的操作数类型决定的。例如，在表达式 <code>int x = 5 / 2;</code> 中，结果是 <code>2</code>，因为整数相除结果仍为整数</li>
<li>小数默认的数据类型是double，float需要再末尾加上f&#x2F;F。<strong>（float f &#x3D; 1.2;&#x2F;&#x2F;编译不通过）</strong></li>
<li>long类型，结尾l&#x2F;L。整数默认类型是int，可以自动类型提升为高精度</li>
<li><code>char</code> 类型是可以存储汉字的。char使用的是unicode字符集，包含了世界范围的所有的字符。   <strong>（char c6 &#x3D; ‘’;&#x2F;&#x2F;编译不通过，‘引号内需要有东西）</strong></li>
<li>boolean类型不能与其它数据类型运算。</li>
<li>String+every都是String类型。</li>
<li>+&#x3D;会默认执行强转。别的也类似，奥里给</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如下代码的计算结果是：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i *= <span class="number">0.2</span>;  <span class="comment">//i =（int）i*0.2，类似</span></span><br><span class="line">i++;</span><br><span class="line">System.out.println(<span class="string">&quot;i=&quot;</span> + i);<span class="comment">//i=1</span></span><br><span class="line"><span class="comment">//int * double,结果为double，0.2</span></span><br><span class="line"><span class="comment">//又赋值给i，变为int，不是4舍5入，是直接截断小数，故结果为0</span></span><br><span class="line"><span class="comment">//++，变为1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//long l4 = 123123123123;编译报错，后面那坨数字为int类型，溢出了</span></span><br><span class="line"><span class="comment">//System.out.println(1+2+ &quot;666&quot;);先int+int，再变为string，连接，3666</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左移运算相当于乘法，移一位就是*2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">为什么0.1+0.2=0.3000000000004?java</span><br><span class="line"></span><br><span class="line">计算机使用二进制来表示浮点数，而0.1和0.2这样的十进制小数在二进制中是无限循环的小数，因此在二进制表示中无法精确地表示这些值。</span><br><span class="line">IEEE 754标准,不能实现“每一个十进制小数，都对应一个二进制小数”.</span><br><span class="line">所以在编程中，遇见小数判断相等情况，比如开发银行、交易等系统，可以采用<span class="code">`四舍五入`</span>或者“<span class="code">`同乘同除`</span>”等方式进行验证，避免上述问题。</span><br></pre></td></tr></table></figure>

<h3 id="包装类比较"><a href="#包装类比较" class="headerlink" title="包装类比较"></a>包装类比较</h3><ul>
<li>包装类与基本数据类型比较时，自动拆箱，使用基本数值类型的比较规则。</li>
<li>包装类重写了equals方法，值比较。只有在对象类型相同时，equals() 方法才会比较它们的值。</li>
<li>包装类具有自动装箱缓存机制。用于缓存某些特定范围的包装类对象，这样频繁使用的对象可以被重用，节省内存和提高性能。这种缓存机制可以节省内存，因为在使用某些特定值时，会重用已经存在的对象而不是创建新的对象。但是在超出这个缓存范围时，仍然会创建新的对象。这种机制是为了提高性能和节省内存而设计的。<ul>
<li>Boolean：(全部缓存)</li>
<li>Byte：(全部缓存)</li>
<li>Character：(0 — 127缓存)</li>
<li>Short：(-128 — 127缓存)</li>
<li>Long：(-128 — 127缓存)</li>
<li>Integer：(-128 — 127缓存)</li>
</ul>
</li>
<li>与基本类型的区别：<strong>数值类型，存储位置，默认值，调用方法，性能</strong>等方面比较。（基本类型更加高效率）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        Short a=<span class="number">1</span>;</span><br><span class="line">          Integer b=<span class="number">1</span>;</span><br><span class="line">        System.out.println(a.equals(b));<span class="comment">//false</span></span><br><span class="line"><span class="comment">//虽然重写了equals方法，但还是不同的对象，还是false，只有在对象类型相同时，equals() 方法才会比较它们的值。</span></span><br><span class="line"><span class="comment">//有点东西</span></span><br><span class="line"> 		  <span class="type">short</span> a=<span class="number">1</span>;</span><br><span class="line">          Integer b=<span class="number">1</span>;</span><br><span class="line">        System.out.println(a==b);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//equals只要是类型不同，就是false</span></span><br><span class="line"><span class="comment">//b先自动拆箱为int，而后short与int运算，short自动类型转换为int，故变为值比较，结果为true。</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">		System.out.println(i1 == i2);<span class="comment">//false，比较地址，128超过Integer缓存对象</span></span><br><span class="line">		System.out.println(i3 == i4);<span class="comment">//true，比较数据值</span></span><br><span class="line">		System.out.println(i1 == i3);<span class="comment">//true，i1自动拆箱按照基本数据类型比较</span></span><br><span class="line">        <span class="comment">//包装类对象与基本数据类型进行比较时，就会把包装类对象自动拆箱，按照基本数据类型的规则进行比较</span></span><br></pre></td></tr></table></figure>

<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><ol>
<li>整数类型 int<code>、</code>short<code>、</code>byte&#96;</li>
<li>字符类型 <code>char</code></li>
<li>枚举类型（<code>enum</code>）</li>
<li>字符串类型 <code>String</code>（Java 7 及更高版本支持）</li>
</ol>
<p><code>switch</code> 中，每个 <code>case</code> 后面的代码块必须以 <code>break</code>、<code>return</code> 或 <code>throw</code> 等语句结束，否则会出现“case穿透”（fall-through），导致多个 <code>case</code> 的代码块被连续执行。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> if-else语句优势</span><br><span class="line"><span class="bullet">  -</span> if语句的条件是一个布尔类型值，if条件表达式为true则进入分支，可以用于范围的判断，也可以用于等值的判断，<span class="code">`使用范围更广`</span>。</span><br><span class="line"><span class="bullet">  -</span> switch语句的条件是一个常量值（byte,short,int,char,枚举,String），只能判断某个变量或表达式的结果是否等于某个常量值，<span class="code">`使用场景较狭窄`</span>。</span><br><span class="line"><span class="bullet">-</span> switch语句优势</span><br><span class="line"><span class="bullet">  -</span> 当条件是判断某个变量或表达式是否等于某个固定的常量值时，使用if和switch都可以，习惯上使用switch更多。因为<span class="code">`效率稍高`</span>。当条件是区间范围的判断时，只能使用if语句。</span><br><span class="line"><span class="bullet">  -</span> 使用switch可以利用<span class="code">`穿透性`</span>，同时执行多个分支，而if...else没有穿透性</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>数组一旦初始化，其长度就是确定的。arr.length</li>
<li>数组长度一旦确定，就不可修改。</li>
<li>ArrayIndexOutOfBoundsException:数组角标越界异常：</li>
<li>NullPointerException:空指针异常</li>
<li>初值<ul>
<li>整型 : 0</li>
<li>浮点型：0.0</li>
<li>char:0</li>
<li>boolean :false</li>
<li>引用类型：null</li>
</ul>
</li>
<li>数组的索引，表示了数组元素距离首地址的偏离量。因为第1个元素的地址与首地址相同，所以偏移量就是0。所以从0开始。</li>
</ul>
<h3 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h3><p><strong>TimSort算法</strong>:<strong>混合排序</strong>.TimSort是一种稳定的排序算法，即相等元素的相对位置在排序后不变。</p>
<p>这个算法的实现主要由以下步骤组成：</p>
<ol>
<li><strong>预处理阶段</strong>：<ul>
<li>首先，将数组分割成多个小的有序块（runs）。</li>
<li>对每个小块进行插入排序，使得它们变得更加有序。</li>
</ul>
</li>
<li><strong>归并阶段</strong>：<ul>
<li>将这些有序的小块逐步合并为更大的有序块，直到整个数组被完全排序</li>
</ul>
</li>
</ol>
<h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><p><strong>重载方法</strong>可以有<strong>不同的参数类型</strong>、<strong>数量</strong>或<strong>顺序</strong>，但是它们的方法名必须相同。（若只是返回类型不同，或方法的修饰符不同，则会编译报错）。两同一不同：相同的方法名字，在同一个类中；不同的参数列表。</p>
<p><strong>重写方法</strong>（Method Overriding）是指在子类中重新定义父类中已有的方法，方法签名（方法名、参数列表和返回类型）必须与父类中的方法相同。在 Java 中，当子类继承自父类时，如果子类中定义了一个与父类中具有相同名称和参数列表的方法，则子类的方法会重写（覆盖）父类的方法。这样，在使用子类对象调用这个方法时，将执行子类中的方法而不是父类中的方法。</p>
<h3 id="重载的方法找寻原则"><a href="#重载的方法找寻原则" class="headerlink" title="重载的方法找寻原则"></a>重载的方法找寻原则</h3><p>重载方法找寻原则：<br>        A：先找最匹配的<br>        什么叫最匹配的？<br>            实参的<strong>“编译时”</strong>类型和<strong>形参的“声明”类型</strong>一致，个数也一致。<strong>（注意编译，就是左边是啥类型就是啥类型）</strong><br>        B：再找唯一可以兼容的<br>        什么叫兼容？<br>            实参的<strong>“编译时”类型</strong> &lt; <strong>形参的“声明”类型</strong>（父类类型大于子类类型）</p>
<p>​            形参是可变参数的话，实参的个数在它允许的范围内</p>
<h3 id="类的变量的赋值过程"><a href="#类的变量的赋值过程" class="headerlink" title="类的变量的赋值过程"></a>类的变量的赋值过程</h3><p><strong>实例化变量</strong></p>
<ol>
<li>默认初始化：实例变量会根据其类型进行默认初始化。数值类型初始化为 <code>0</code>，布尔类型初始化为 <code>false</code>，引用类型初始化为 <code>null</code>。</li>
<li>显式初始化：如果在类定义中对实例变量进行了显式初始化，将使用显式提供的值来初始化实例变量。</li>
<li>实例初始化块：在构造函数之前执行实例初始化块，<strong>每次创建对象时都会执行</strong>。实例初始化块中的代码会对实例变量进行初始化。</li>
<li>构造函数中初始化：构造函数会在对象创建时被调用，可以在构造函数中对实例变量进行初始化。构造函数可以使用参数传递值，或者在构造函数内部进行赋值操作。</li>
<li>通过 “对象.方法” 的方式赋值：使用公共方法（setter方法）来设置对象的属性值。这种方式通常在对象已经被创建后使用。</li>
<li>通过 “对象.属性” 的方式赋值：直接访问对象的属性来设置其值。这种方式绕过了类中定义的方法，可以直接修改属性的值。</li>
</ol>
<p><strong>静态变量</strong></p>
<ol>
<li>默认初始化：实例变量会根据其类型进行默认初始化。数值类型初始化为 <code>0</code>，布尔类型初始化为 <code>false</code>，引用类型初始化为 <code>null</code>。</li>
<li>显式初始化：如果在类定义中对实例变量进行了显式初始化，将使用显式提供的值来初始化实例变量。<strong>说的稍稍有点争议了，不够严谨，主要看是否调用了构造函数，从而调用实例 变量的定义过程，实例化代码块，反正按顺序执行static的相关内容。包括变量定义以及代码块</strong></li>
<li>静态初始化块：静态初始化块是一个在类加载时执行的代码块，用 <code>static &#123; &#125;</code> 声明。它可以对静态变量进行复杂赋值操作。<strong>只执行一次</strong></li>
</ol>
<h3 id="类的执行顺序"><a href="#类的执行顺序" class="headerlink" title="类的执行顺序"></a>类的执行顺序</h3><p>类加载时：只用查看变量的初始化过程，实例化变量直接不用管。查看<strong>静态变量的实例化</strong>，<strong>按顺序依次初始化</strong>，调用对应的函数。若初始化使用构造函数，则按顺序执行<strong>实例化变量</strong>的初始化过程，<strong>代码块，最后执行构造函数</strong>。最后所有静态变量初始化完成后，按顺序执行<strong>静态代码块。</strong>如果<strong>没用构造函数的调用</strong>，那么<strong>代码块，实例变量的初始化过程均不会执行输出。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> print(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> print(<span class="string">&quot;j&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	&#123;</span><br><span class="line">		print(<span class="string">&quot;构造块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		print(<span class="string">&quot;静态块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String str)</span>&#123;</span><br><span class="line">		System.out.println((++k) + <span class="string">&quot;:&quot;</span> + str + <span class="string">&quot;  i=&quot;</span> + i + <span class="string">&quot;  n=&quot;</span> + n);</span><br><span class="line">		++n;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;</span><br><span class="line">		System.out.println((++k) + <span class="string">&quot;:&quot;</span> + str + <span class="string">&quot;  i=&quot;</span> + i + <span class="string">&quot;  n=&quot;</span> + n);</span><br><span class="line">		++n;</span><br><span class="line">		<span class="keyword">return</span> ++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">//只用管类加载过程，哈拉少</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出顺序：j,构造块，t1，j，构造块，t2，i，静态块</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1:j  i=0  n=0 </span></span><br><span class="line"><span class="comment">2:构造块  i=1  n=1</span></span><br><span class="line"><span class="comment">3:t1  i=2  n=2</span></span><br><span class="line"><span class="comment">4:j  i=3  n=3</span></span><br><span class="line"><span class="comment">5:构造块  i=4  n=4</span></span><br><span class="line"><span class="comment">6:t2  i=5  n=5</span></span><br><span class="line"><span class="comment">7:i  i=6  n=6</span></span><br><span class="line"><span class="comment">8:静态块  i=7  n=99 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>类加载完成使用时：构造函数调用前优先调用代码块。奥里给<strong>（不会调用静态代码块，静态只会类加载时调用一次）</strong></p>
<p>有继承时：先完成类的加载过程。而后子类先调用父类构造，父类构造先调用代码块，而后执行子类构造。子类构造也优先调用子类代码块。<strong>类加载–》父类代码块和别的实例变量的定义过程–》父类构造–》子类代码块别的变量定义过程–》子类构造。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloA</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HelloA</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;HelloA&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I&#x27;m A Class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;static A&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloB</span> <span class="keyword">extends</span> <span class="title class_">HelloA</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HelloB</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;HelloB&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I&#x27;m B Class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;static B&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">HelloB</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先类加载过程</span></span><br><span class="line"><span class="keyword">static</span> A</span><br><span class="line"><span class="keyword">static</span> B</span><br><span class="line"><span class="comment">//调用b的构造，b会先执行a的构造</span></span><br><span class="line"><span class="comment">//a调用自己的代码块</span></span><br><span class="line">I<span class="string">&#x27;m A Class</span></span><br><span class="line"><span class="string">//a的构造输出</span></span><br><span class="line"><span class="string">HelloA</span></span><br><span class="line"><span class="string">//b的构造，b也先调用代码块</span></span><br><span class="line"><span class="string">I&#x27;</span>m B Class</span><br><span class="line">HelloB</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例2：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise13</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	Base()&#123;</span><br><span class="line">		method(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;base&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;base : &quot;</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	Sub()&#123;</span><br><span class="line">		<span class="built_in">super</span>.method(<span class="number">70</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;sub&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> j)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;sub : &quot;</span> + j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先类加载，没有输出</span></span><br><span class="line"><span class="comment">//调用s的构造，优先调用父类构造，又优先调用父类代码块。</span></span><br><span class="line">base</span><br><span class="line"><span class="comment">//执行父类构造,但是重写了method方法，执行子类的method方法</span></span><br><span class="line">sub:<span class="number">100</span></span><br><span class="line"><span class="comment">//子类代码块</span></span><br><span class="line">sub</span><br><span class="line"><span class="comment">//super，父类method</span></span><br><span class="line">base:<span class="number">70</span></span><br></pre></td></tr></table></figure>

<h3 id="静态变量与静态方法"><a href="#静态变量与静态方法" class="headerlink" title="静态变量与静态方法"></a>静态变量与静态方法</h3><p>是可以被继承的，但是不能被重写（覆盖，不知道覆盖的意思是不是重写）。当子类和父类有相同名字的静态属性，会被子类覆盖。可以<strong>用父类类名访问父类的静态变量，但不能使用super访问</strong>。</p>
<h3 id="javabean"><a href="#javabean" class="headerlink" title="javabean"></a>javabean</h3><ol>
<li><strong>私有属性</strong>：通常使用私有的实例变量来封装数据，以确保数据的安全性和封装性。</li>
<li><strong>公共访问方法</strong>：提供公共的 getter 和 setter 方法，用于对私有属性进行访问和修改。这些方法按照一定的命名规范命名，如 <code>getPropertyName()</code> 和 <code>setPropertyName()</code>。</li>
<li><strong>无参构造函数</strong>：通常需要提供无参构造函数，便于 JavaBean 的实例化和初始化。</li>
<li><strong>可序列化</strong>：JavaBean 应该实现 <code>java.io.Serializable</code> 接口，使得它可以序列化，这样可以在网络上传输和持久化存储。</li>
<li><strong>命名约定</strong>：根据 JavaBean 的命名规范，类名应该是名词且首字母大写，属性名应该是名词且首字母小写，方法名应该符合对应属性的命名规范</li>
</ol>
<h3 id="与equals的区别（拓-思）"><a href="#与equals的区别（拓-思）" class="headerlink" title="&#x3D;&#x3D;与equals的区别（拓*思）"></a>&#x3D;&#x3D;与equals的区别（拓*思）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类似问法：</span><br><span class="line">&gt; 两个对象A和B，A==B，A.equals(B)有什么区别（华油**普）</span><br></pre></td></tr></table></figure>

<p>equals默认比较地址值<br>如果类中重写了equals方法，比较内容是否相等。<br>String、Date、File、包装类都重写了Object类的equals方法。<br>如果类中没有重写equals方法，比较地址值是否相等（是否指向同一个地址值）。</p>
<p>&#x3D;&#x3D;<br>比较运算符，返回的就是一个布尔值true，false<br>如果比较的是基本数据类型变量，比较两个变量的值是否相等。(不一定数据类型相同)<br>如果比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个地址值</p>
<h3 id="重写equals方法要注意什么？（安-网络科技）"><a href="#重写equals方法要注意什么？（安-网络科技）" class="headerlink" title="重写equals方法要注意什么？（安**网络科技）"></a>重写equals方法要注意什么？（安**网络科技）</h3><ul>
<li>明确判定两个对象实体equals()的标准。是否需要所有的属性参与。</li>
<li>对象的属性，又是自定义的类型，此属性也需要重写equals()</li>
<li>满足自反（a和a），对称（a和b，b和a），一致（a多次执行），传递性（a和b，b和c）。</li>
</ul>
<h3 id="Java中所有类的父类是什么？他都有什么方法？（阿-校招）"><a href="#Java中所有类的父类是什么？他都有什么方法？（阿-校招）" class="headerlink" title="Java中所有类的父类是什么？他都有什么方法？（阿*校招）"></a>Java中所有类的父类是什么？他都有什么方法？（阿*校招）</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">（1）clone方法</span><br><span class="line">保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</span><br><span class="line"></span><br><span class="line">（2）getClass方法</span><br><span class="line">final方法，获得运行时类型。</span><br><span class="line"></span><br><span class="line">（3）toString方法</span><br><span class="line">该方法用得比较多，一般子类都有覆盖。</span><br><span class="line"></span><br><span class="line">（4）finalize方法</span><br><span class="line">该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</span><br><span class="line"></span><br><span class="line">（5）equals方法</span><br><span class="line">该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</span><br><span class="line"></span><br><span class="line">（6）hashCode方法</span><br><span class="line">该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</span><br><span class="line"></span><br><span class="line">一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</span><br><span class="line"></span><br><span class="line">（7）wait方法</span><br><span class="line">wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</span><br><span class="line">调用该方法后当前线程进入睡眠状态，直到以下事件发生。</span><br><span class="line">（1）其他线程调用了该对象的notify方法。</span><br><span class="line">（2）其他线程调用了该对象的notifyAll方法。</span><br><span class="line">（3）其他线程调用了interrupt中断该线程。</span><br><span class="line">（4）时间间隔到了。</span><br><span class="line">此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</span><br><span class="line"></span><br><span class="line">（8）notify方法</span><br><span class="line">该方法唤醒在该对象上等待的某个线程。</span><br><span class="line"></span><br><span class="line">（9）notifyAll方法</span><br><span class="line">该方法唤醒在该对象上等待的所有线程。</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li><strong>方法</strong>：接口可以包含抽象方法、默认方法和静态方法。<ul>
<li>抽象方法：只有方法签名，没有方法体。</li>
<li>默认方法（Java 8+）：在接口中提供默认实现，实现类可以直接继承或覆盖。主要是接口修改以后（加了新方法，所有的实现类需要修改，实现改方法。所以引入默认方法，按需覆盖新加的方法即可。</li>
<li>静态方法（Java 8+）：接口中可以包含具有方法体的静态方法。主要是在接口中定义一些通用的工具方法，这些方法可以在接口的所有实现类中直接调用，提供便利和实用性。（<strong>比如collection接口含有对应的工具类Collections，不是实现类，包含排序等通用方法，使用静态方法后，就不需要再声明Collections类了</strong>）</li>
<li><strong>Java 7及之前版本：</strong><ul>
<li><strong>默认修饰符</strong>：接口方法默认为公共（public）且抽象（abstract）的，即<code>public abstract</code>，无需显式声明。</li>
</ul>
</li>
<li><strong>Java 8：</strong><ul>
<li>默认方法和静态方法<ul>
<li><strong>默认方法</strong>：在接口中可以提供默认实现，默认方法使用<code>default</code>关键字修饰。</li>
</ul>
</li>
<li><strong>静态方法</strong>：接口中可以包含静态方法的实现，使用<code>static</code>关键字修饰。<ul>
<li>不能同时定义为静态默认方法。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Java 9及之后版本：</strong><ul>
<li>私有接口方法<br>：从Java 9开始，接口中可以包含私有方法，这些方法只能在接口内部使用，以支持默认方法或静态方法的实现。<strong>因为java 8中可以有静态方法和默认方法，对应可能有冗余操作，故将重复的操作封装成一个独立的方法，并只能在接口内部使用，就定义为私有方法。</strong></li>
<li><strong>私有方法</strong>：使用<code>private</code>关键字修饰，提供在接口内部进行代码重用的能力。</li>
</ul>
</li>
</ul>
</li>
<li><strong>常量</strong>：接口中的变量默认为公共、静态、最终的常量，用于定义常量值。使得接口中的字段具有固定的值，并确保所有实现该接口的类都能使用相同的常量。<ul>
<li>java 8之前，默认的修饰符为public static final，只能是改类型。</li>
<li>java 9：可以是<strong>私有静态</strong>变量。默认不变。</li>
<li>总结：必须是静态变量，且final变量。<strong>默认就是静态不变</strong>。</li>
</ul>
</li>
</ul>
<h3 id="abstract抽象类"><a href="#abstract抽象类" class="headerlink" title="abstract抽象类"></a>abstract抽象类</h3><p>不能修饰以下东西。</p>
<ul>
<li><strong>属性（成员变量）</strong>：属性不能被声明为抽象，因为抽象性质通常与方法相关联，属性没有实现细节需要实现，它们只是存储数据的容器。属性的抽象并没有实际意义。</li>
<li><strong>私有方法</strong>：私有方法是类内部的辅助方法，它们不需要被子类实现或覆写，因此没有必要将其声明为抽象。抽象方法是为了让子类实现，但私有方法无法被子类调用或覆盖，所以将其声明为抽象没有意义。</li>
<li><strong>构造器</strong>：抽象类是不能被实例化的，而构造器的作用是创建对象并进行初始化。抽象类不能被实例化的特性与构造器的作用相违背，因此构造器不能被声明为抽象。</li>
<li><strong>静态方法</strong>：<strong>静态方法是与类相关联的，它们属于类而不是实例。抽象方法必须被子类实现，但静态方法是不具备多态性的，不能被子类覆盖，所以将静态方法声明为抽象也失去了意义。</strong></li>
<li><strong>final 的方法</strong>：<code>final</code> 关键字表示方法不可被子类覆盖或修改，而抽象方法则要求子类必须覆盖实现。这两个关键字的含义相互矛盾，因此不能将方法既声明为 <code>final</code> 又声明为 <code>abstract</code>。</li>
<li><strong>抽象类有构造方法</strong>，但不能直接用于实例化对象，常用子类构造函数调用父类的构造函数。</li>
<li>从声明，成员变量与方法，继承、实现方式，<strong>构造方法</strong>等方面来说明不同。</li>
<li>接口<strong>可以</strong>继承接口，抽象类<strong>可以</strong>实现接口，抽象类<strong>可以</strong>继承实现类。</li>
</ul>
<h3 id="枚举enmu"><a href="#枚举enmu" class="headerlink" title="枚举enmu"></a>枚举enmu</h3><ul>
<li>默认继承java.lang.Enum，故不能再继承别的类。</li>
<li>默认被final修饰，亦不可被别的类继承。</li>
<li>枚举类型的比较通常使用 <code>==</code> 运算符。这是因为枚举类型的每个常量是唯一的，并且在编译时已经确定。</li>
<li>枚举可实现接口，每个枚举常量都必须提供接口中定义的方法的实现。可以通过枚举变量来调用接口中定义的方法。</li>
<li>构造函数私有，系统会在枚举类加载时自动创建这些枚举常量，并且只会创建一次。构造函数可以重载，可以不同的枚举常量调用不同的构造函数。</li>
<li>枚举常量默认使用 <code>public static final</code> 修饰符，因此它们可以被任何类访问，是静态的（因为它们属于类而不是实例），并且是最终的（即不可修改）。</li>
<li>枚举中可定义抽象方法，但是枚举的所有实例必须实现对应的方法。调用也和实现接口类似。</li>
<li>枚举的equals方法调用&#x3D;&#x3D;方法，即object类中的equals方法。但由于枚举常量的唯一性，所以可以简单认为是值等判断。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义形状接口   例1</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举实现形状接口</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SimpleShape</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    CIRCLE &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SQUARE &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;绘制正方形&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TRIANGLE &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;绘制三角形&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HL</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SimpleShape.CIRCLE.draw();    <span class="comment">// 输出 &quot;绘制圆形&quot;</span></span><br><span class="line">        SimpleShape.SQUARE.draw();    <span class="comment">// 输出 &quot;绘制正方形&quot;</span></span><br><span class="line">        SimpleShape.TRIANGLE.draw();  <span class="comment">// 输出 &quot;绘制三角形&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SimpleShape</span> &#123;</span><br><span class="line">    CIRCLE &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SQUARE &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;绘制正方形&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TRIANGLE &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;绘制三角形&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在枚举类内部定义的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HL</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SimpleShape.CIRCLE.draw();    <span class="comment">// 输出 &quot;绘制圆形&quot;</span></span><br><span class="line">        SimpleShape.SQUARE.draw();    <span class="comment">// 输出 &quot;绘制正方形&quot;</span></span><br><span class="line">        SimpleShape.TRIANGLE.draw();  <span class="comment">// 输出 &quot;绘制三角形&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><ul>
<li>当你运行一个Java程序时，Java虚拟机（JVM）会尝试在指定的类中寻找<code>public static void main(String[] args)</code>方法，并且仅当<code>main()</code>方法是<code>public</code>时，JVM才能访问和执行它。</li>
<li>访问类型能改为private，但就不是程序的入口了。</li>
<li>main方法是静态方法，只能直接调用静态变量或静态方法。实例方法需要初始化对象后调用。</li>
<li>System.exit(0); &#x2F;&#x2F; 0 代表正常退出JVM虚拟机</li>
</ul>
<h3 id="异常-try-catch-finally"><a href="#异常-try-catch-finally" class="headerlink" title="异常 try catch finally"></a>异常 try catch finally</h3><ul>
<li><ul>
<li>finally块中的代码是无论try中是否发生异常，也无论catch是否可以捕获异常，也不管try和catch中是否有return语句，都会执行的部分</li>
</ul>
<ul>
<li>（2）如果finally中有return语句，那么try…catch…finally结构一定从finally中的return回去</li>
<li>（3）如果finally中没有return语句，那么try…catch…finally结构才会从try或catch中的return回去，但是finally值中代码不会影响最终的返回值（如果返回的是引用类型并在 <code>finally</code> 中修改了对象的状态，这种改变会影响方法返回的引用对象的状态。）</li>
<li>finally是在return后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</li>
</ul>
</li>
<li>先捕获子类异常，再捕获父类异常。捕获父类异常之后，不能捕获子类异常了，否则编译不通过。</li>
<li>Exception分为两大类：运行时异常 [即程序运行时，发生的异常]。编译时异常 [即编程时编译器检查出的异常，Checked异常]。<br>所有的RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常。<ul>
<li>编译时异常：(受检异常)在执行javac.exe命令时，出现的异常。<br>                |—– ClassNotFoundException<br>                |—– FileNotFoundException<br>                |—– IOException</li>
<li>运行时异常：(非受检异常)在执行java.exe命令时，出现的异常。<br>                |—- ArrayIndexOutOfBoundsException<br>                |—- NullPointerException<br>                |—- ClassCastException<br>                |—- NumberFormatException<br>                |—- InputMismatchException<br>                |—- ArithmeticException</li>
</ul>
</li>
<li>throw是抛出异常，二throws是处理异常（交由调用者处理，自己不管，继续向上抛出异常）</li>
<li>异常处理方式，两种，throws和try，catch</li>
<li>继承于Throwable父类</li>
<li>finally语句和catch语句是可选的，但finally不能单独使用。写入finally中：我们在开发中，有一些资源（比如：输入流、输出流，数据库连接、Socket连接等资源），在使用完以后，必须显式的进行关闭操作，否则，GC不会自动的回收这些资源。进而导致内存的泄漏。</li>
<li>子类重写的方法抛出的异常类型可以与父类被重写的方法抛出的异常类型相同，或是<strong>父类被重写的方法抛出的异常类型的子类</strong>。</li>
<li><code>finalize()</code> 方法是 Java 中 <code>Object</code> 类的一个方法，用于在对象被垃圾回收之前执行一些清理操作。每个对象在被垃圾回收器回收之前都有机会执行 <code>finalize()</code> 方法。</li>
<li>自定义异常<ul>
<li>继承于现有的异常体系。通常继承于RuntimeException \ Exception</li>
<li>通常提供几个重载的构造器</li>
<li><strong>提供一个全局常量</strong>，声明为：static final long serialVersionUID;</li>
<li><code>serialVersionUID</code>是 Java 序列化机制用来验证版本一致性的一个标识符。在自定义异常类中声明这个字段是一个好的做法，以确保在序列化和反序列化时的兼容性。</li>
</ul>
</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用时才创建对应得单例对象。</span></span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>： 在多线程环境下，多个线程同时进入 <code>getInstance()</code> 方法，可能导致创建多个实例。</p>
<p><strong>改进</strong>：使用 <code>synchronized</code> 关键字或者双重检查锁等机制来实现线程安全。</p>
<h4 id="synchronized单例（懒汉安全版）"><a href="#synchronized单例（懒汉安全版）" class="headerlink" title="synchronized单例（懒汉安全版）"></a>synchronized单例（懒汉安全版）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在方法上添加 synchronized 关键字，保证线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：<strong>性能开销：</strong> 每次调用 <code>getInstance()</code> 方法都需要获取同步锁，这会带来性能开销。在高并发环境下，可能会造成性能问题。<strong>无法应对反射攻击：</strong> 同样无法防止反射机制调用私有构造器创建新的实例。</p>
<h4 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最开始就直接创建对应得单例对象</span></span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>： 在类加载时就创建实例可能导致资源浪费。</p>
<p><strong>改进</strong>：可以考虑使用静态内部类延迟加载或者双重检查锁机制。</p>
<h4 id="静态内部类单例"><a href="#静态内部类单例" class="headerlink" title="静态内部类单例"></a>静态内部类单例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 内部类中持有单例对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供获取单例对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*延迟加载单例对象，只有在第一次调用 getInstance() 方法时才会初始化单例对象，避免了在类加载时就创建对象的问题。</span></span><br><span class="line"><span class="comment">线程安全： 利用了类加载机制保证了线程安全，静态内部类在第一次加载时初始化单例对象，保证了线程安全性。</span></span><br><span class="line"><span class="comment">防止反序列化重新创建对象： 与枚举类一样，也能避免反序列化重新创建对象的问题。</span></span><br><span class="line"><span class="comment">简洁高效： 实现简单，代码清晰，没有使用同步关键字，性能较高。*/</span></span><br></pre></td></tr></table></figure>

<p>缺点：无法应对反射攻击。</p>
<h4 id="双重检查锁机制单例"><a href="#双重检查锁机制单例" class="headerlink" title="双重检查锁机制单例"></a>双重检查锁机制单例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// 使用 volatile 关键字确保可见性和禁止指令重排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 volatile 关键字是为了避免指令重排序，确保在多线程环境下变量的可见性和正确性。</span></span><br></pre></td></tr></table></figure>

<p>缺点：尽管 <code>volatile</code> 能够确保变量的可见性和禁止指令重排序，但仍有一些特殊情况可能会出现问题，特别是在复合操作或复杂情况下。</p>
<p><strong>复合操作</strong>：如果需要对变量进行复合操作（例如自增、自减、赋值等），<code>volatile</code> 不能保证操作的原子性，这意味着即使变量的值在各个线程中是可见的，但可能会出现竞态条件（Race Condition）导致意外结果。</p>
<p><strong>指令重排序</strong>：虽然 <code>volatile</code> 会防止变量的写操作和读操作进行重排序，但并不会影响其他指令的重排序。这可能会导致在某些情况下，其它指令的重排序仍可能影响程序的行为。</p>
<p><strong>对象引用</strong>：当一个类中的某个字段使用 <code>volatile</code> 修饰，只有这个字段是可见的，但如果该字段是一个对象的引用，那么对象本身的状态并不受 <code>volatile</code> 的影响，可能会导致引用对象的状态不一致。</p>
<h4 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE; <span class="comment">// 唯一的枚举常量，即单例对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法或属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 单例对象的行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*线程安全： 枚举类天然具备线程安全性，因为枚举常量在类加载时被初始化，JVM 保证其在多线程环境下只被实例化一次。</span></span><br><span class="line"><span class="comment">防止反射攻击： 枚举类的实例在任何情况下都只会被实例化一次，无法通过反射机制调用私有构造器创建新的实例。</span></span><br><span class="line"><span class="comment">防止序列化和反序列化问题： 枚举类的实例在序列化和反序列化过程中会被处理，因此不存在通过序列化和反序列化创建新对象的问题。</span></span><br><span class="line"><span class="comment">简单明了： 实现简单、代码清晰，不需要额外的代码来实现单例模式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">缺点：</span></span><br><span class="line"><span class="comment">无法懒加载： 枚举类的实例在类加载时就被创建，无法延迟加载，如果初始化需要耗费大量资源，可能会影响程序启动速度。</span></span><br><span class="line"><span class="comment">无法继承： 枚举类无法被继承，因为它默认继承自 java.lang.Enum 类，这在某些特定情况下可能会受限。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>此外，还有</p>
<p>注册式单例模式：在一个管理器类中，使用 Map 或其他集合存储单例对象，按照一个唯一的键来管理和获取单例对象。这种方式的特点是可以动态添加、移除单例对象。</p>
<p>枚举和静态变量混合实现单例模式：有时候也可以利用枚举和静态变量相结合，将枚举中的属性当做单例对象的成员变量，通过枚举常量来访问。</p>
<p>ThreadLocal 实现单例模式：利用 <code>ThreadLocal</code> 来存储单例对象，确保每个线程中都有一个独立的实例，从而达到线程安全的效果。</p>
<h3 id="有趣"><a href="#有趣" class="headerlink" title="有趣"></a>有趣</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>​    <img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20230914155657651.png" alt="image-20230914155657651" style="zoom:80%;" /></p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise22</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Daughter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        第一个问题，my有没有多态引用？没有，从my角度来说，不需要考虑多态现象。</span></span><br><span class="line"><span class="comment">        第二个问题，my调用的method方法，去哪个类找？只MyClass类中找就可以，和其他类无关。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        第三个问题，method方法有三个形式，即重载的形式，那么怎么确定调用的是哪一个？</span></span><br><span class="line"><span class="comment">        重载方法找寻原则：</span></span><br><span class="line"><span class="comment">        A：先找最匹配的</span></span><br><span class="line"><span class="comment">        什么叫最匹配的？</span></span><br><span class="line"><span class="comment">            实参的“编译时”类型和形参的“声明”类型一致，个数也一致。</span></span><br><span class="line"><span class="comment">        B：再找唯一可以兼容的</span></span><br><span class="line"><span class="comment">        什么叫兼容？</span></span><br><span class="line"><span class="comment">            实参的“编译时”类型 &lt; 形参的“声明”类型</span></span><br><span class="line"><span class="comment">            形参是可变参数的话，实参的个数在它允许的范围内</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        my.method(f);<span class="comment">//father</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        实参f的编译时类型是 Father，和哪个方法的形参最匹配呢？public void method(Father f) 就它了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        my.method(s);<span class="comment">//father</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        实参s的编译时类型是 Father，和哪个方法的形参最匹配呢？public void method(Father f) 就它了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        my.method(d);<span class="comment">//father</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        实参d的编译时类型是 Father，和哪个方法的形参最匹配呢？public void method(Father f) 就它了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Father f)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Son s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Daughter f)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;daughter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Daughter</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise23</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="type">Daughter</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Daughter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();<span class="comment">//my没有多态引用，只看MyClass类就可以了</span></span><br><span class="line">        my.method(f);<span class="comment">//father</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        实参f的编译时类型仍然是Father，找最匹配的public void method(Father f)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        my.method(s);<span class="comment">//son</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        实参s的编译时类型是Son，找最匹配的public void method(Son s)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        my.method(d);<span class="comment">//father</span></span><br><span class="line">        <span class="comment">/*&#x27;</span></span><br><span class="line"><span class="comment">        实参d的编译时类型是Daughter，找最匹配，没有，找兼容的，public void method(Father f)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Father f)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Son s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Daughter</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise24</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="type">Daughter</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Daughter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySub</span>();<span class="comment">//my有多态引用了，而且method是虚方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如何确定它执行的是哪个方法呢？</span></span><br><span class="line"><span class="comment">        （1）编译时，去my的编译时类型MyClass中找合适的方法</span></span><br><span class="line"><span class="comment">        （2）运行时，去my的运行时类型MySub中看是否有对刚刚找到的方法进行了“重写”</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        my.method(f);<span class="comment">//father</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        （1）编译时，去my的编译时类型MyClass中找合适的方法</span></span><br><span class="line"><span class="comment">        实参f的编译时类型是Father，找最匹配的public void method(Father f)</span></span><br><span class="line"><span class="comment">        （2）运行时，去my的运行时类型MySub中看是否有对刚刚找到的方法进行了“重写”</span></span><br><span class="line"><span class="comment">        没有重写</span></span><br><span class="line"><span class="comment">        仍然执行刚刚在MyClass中找到的合适的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        my.method(s);<span class="comment">//son</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        （1）编译时，去my的编译时类型MyClass中找合适的方法</span></span><br><span class="line"><span class="comment">        实参s的编译时类型是Son，找最匹配的public void method(Son s)</span></span><br><span class="line"><span class="comment">        （2）运行时，去my的运行时类型MySub中看是否有对刚刚找到的方法进行了“重写”</span></span><br><span class="line"><span class="comment">        没有重写</span></span><br><span class="line"><span class="comment">        仍然执行刚刚在MyClass中找到的合适的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        my.method(d);<span class="comment">//father</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        （1）编译时，去my的编译时类型MyClass中找合适的方法</span></span><br><span class="line"><span class="comment">        实参s的编译时类型是Daughter，找最匹配的，没有，找兼容的，public void method(Father f)</span></span><br><span class="line"><span class="comment">        （2）运行时，去my的运行时类型MySub中看是否有对刚刚找到的方法进行了“重写”</span></span><br><span class="line"><span class="comment">        没有重写</span></span><br><span class="line"><span class="comment">        仍然执行刚刚在MyClass中找到的合适的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Father f)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Son s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySub</span> <span class="keyword">extends</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Daughter d)</span> &#123;<span class="comment">//这个不是重写，因为形参列表不同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;daughter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Daughter</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise25</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="type">Daughter</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Daughter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySub</span>();<span class="comment">//my有多态引用了，而且method是虚方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如何确定它执行的是哪个方法呢？</span></span><br><span class="line"><span class="comment">        （1）编译时，去my的编译时类型MyClass中找合适的方法</span></span><br><span class="line"><span class="comment">        （2）运行时，去my的运行时类型MySub中看是否有对刚刚找到的方法进行了“重写”</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        my.method(f);<span class="comment">//daughter</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        （1）编译时，去my的编译时类型MyClass中找合适的方法</span></span><br><span class="line"><span class="comment">        实参f的编译时类型是Father，找最匹配的public void method(Father f)</span></span><br><span class="line"><span class="comment">        （2）运行时，去my的运行时类型MySub中看是否有对刚刚找到的方法进行了“重写”</span></span><br><span class="line"><span class="comment">        有重写</span></span><br><span class="line"><span class="comment">        一定是执行重写后的代码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        my.method(s);<span class="comment">//son</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        （1）编译时，去my的编译时类型MyClass中找合适的方法</span></span><br><span class="line"><span class="comment">        实参s的编译时类型是Son，找最匹配的public void method(Son s)</span></span><br><span class="line"><span class="comment">        （2）运行时，去my的运行时类型MySub中看是否有对刚刚找到的方法进行了“重写”</span></span><br><span class="line"><span class="comment">        没有重写</span></span><br><span class="line"><span class="comment">        仍然执行刚刚在MyClass中找到的合适的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        my.method(d);<span class="comment">//daughter</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        （1）编译时，去my的编译时类型MyClass中找合适的方法</span></span><br><span class="line"><span class="comment">        实参s的编译时类型是Daughter，找最匹配的，没有，找兼容的，public void method(Father f)</span></span><br><span class="line"><span class="comment">        （2）运行时，去my的运行时类型MySub中看是否有对刚刚找到的方法进行了“重写”</span></span><br><span class="line"><span class="comment">        有重写</span></span><br><span class="line"><span class="comment">        执行的是重写的方法体 daughter</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Father f)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Son s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySub</span> <span class="keyword">extends</span> <span class="title class_">MyClass</span>&#123;<span class="comment">//有变化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Father d)</span> &#123;<span class="comment">//是重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;daughter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Daughter</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多态性现象：编译时类型与运行时类型不一致</span></span><br><span class="line"><span class="comment"> * 但是多态性是针对方法来说，方法有动态绑定一说。</span></span><br><span class="line"><span class="comment"> * 属性没有多态性。属性都是按照编译时类型处理的。</span></span><br><span class="line"><span class="comment">		对于变量来说，变量声明时，左边的类型就是它的编译时类型</span></span><br><span class="line"><span class="comment"> 		对于强制类型转换来说，()中写的类型是什么，它的编译时类型就是什么。如果有连续多次的强制类型转换，看最后一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise26</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">		System.out.println(a.num);<span class="comment">//a编译时类型就是A  1</span></span><br><span class="line">		System.out.println(((B)a).num);<span class="comment">//编译后，因为a被强制成B类，是B类型  2</span></span><br><span class="line">		System.out.println(((A)((B)a)).num);<span class="comment">//编译后，a转成B又转成A，是A类型   1</span></span><br><span class="line">		System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">		<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">		System.out.println(b.num);<span class="comment">//b编译时类型就是B   2</span></span><br><span class="line">		System.out.println(((A)b).num);<span class="comment">//b被强制升级为A类型，按A类型处理， 1</span></span><br><span class="line">		System.out.println(((B)((A)b)).num);<span class="comment">//b先转A又转B，最终是B类型  2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise8</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="keyword">new</span> <span class="title class_">SDText</span>().x+<span class="string">&quot;,&quot;</span>+<span class="keyword">new</span> <span class="title class_">SDText</span>().y+<span class="string">&quot;,&quot;</span>+<span class="keyword">new</span> <span class="title class_">SDText</span>().x);</span><br><span class="line">        <span class="comment">//4，3，6</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SDText</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> SDText sd=<span class="keyword">new</span> <span class="title class_">SDText</span>();</span><br><span class="line">    <span class="comment">//不是，哥们，你这还自娱自乐一次？</span></span><br><span class="line">    <span class="comment">//简单，别方</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> x=<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SDText</span><span class="params">()</span>&#123;</span><br><span class="line">		x++;</span><br><span class="line">		y++;</span><br><span class="line">        System.out.println(x+<span class="string">&quot;&quot;</span>+y);</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态代码块以及静态变量的定义，只会执行一次，且最后执行，表明类加载完成。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1,1,刚开始执行构造函数，不会执行静态的变量定义，静态代码块。故只执行最简单的普通代码，此时x=0；y=0；</span></span><br><span class="line"><span class="comment">//然后执行静态变量的定义，表示类也加载完成，x=3；y=1</span></span><br><span class="line"><span class="comment">4,2</span></span><br><span class="line"><span class="comment">5,3</span></span><br><span class="line"><span class="comment">6,4</span></span><br><span class="line"><span class="comment">4,3,6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise15</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getNum(<span class="string">&quot;（1）i&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> getNum(<span class="string">&quot;（2）j&quot;</span>);</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		print(<span class="string">&quot;（3）父类静态代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		print(<span class="string">&quot;（4）父类非静态代码块，又称为构造代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Fu()&#123;</span><br><span class="line">		print(<span class="string">&quot;（5）父类构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;</span><br><span class="line">		System.out.println(str + <span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(String str)</span>&#123;</span><br><span class="line">		print(str);</span><br><span class="line">		<span class="keyword">return</span> ++i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> getNum(<span class="string">&quot;（6）k&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> getNum(<span class="string">&quot;（7）h&quot;</span>);</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		print(<span class="string">&quot;（8）子类静态代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		print(<span class="string">&quot;（9）子类非静态代码块，又称为构造代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Zi()&#123;</span><br><span class="line">		print(<span class="string">&quot;（10）子类构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;</span><br><span class="line">		System.out.println(str + <span class="string">&quot;-&gt;&quot;</span> + k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(String str)</span>&#123;</span><br><span class="line">		print(str);</span><br><span class="line">		<span class="keyword">return</span> ++k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*自己分析，没啥难的*/</span></span><br></pre></td></tr></table></figure>

<h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise16</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();<span class="comment">//找到就是Son类的&lt;init&gt;()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> getNumber();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father非静态代码块 a = &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    Father()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father()无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>&#123;<span class="comment">//方法重写了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Father:getNumber()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son非静态代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son()：无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son:getNumber()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：没意思，拿捏的死死的</span></span><br><span class="line">Son:getNumber()</span><br><span class="line">Father非静态代码块 a = <span class="number">2</span></span><br><span class="line">Father()无参构造</span><br><span class="line">Son非静态代码</span><br><span class="line">Son()：无参构造</span><br></pre></td></tr></table></figure>

<h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise18</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Other</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Other</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Exercise18</span>().addOne(o);</span><br><span class="line">        System.out.println(o.i);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">(<span class="keyword">final</span> Other o)</span>&#123;<span class="comment">//表明的是对象不能变，其实就是对象引用不能变，指向的地址不能变，内部属性的值可以发生改变。</span></span><br><span class="line"><span class="comment">//        o = new Other();//错误，o不能重新赋值</span></span><br><span class="line">        o.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i; <span class="comment">//如果i前面有final，才是表示i的值不能被修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//final指向的对象，表示的是该引用不能改变。</span></span><br><span class="line"><span class="comment">//引用指向的对象实体中的属性，如果没有使用final修饰，则可以改变</span></span><br><span class="line"><span class="comment">//final不能修饰构造方法。因为加了之后没有任何意义</span></span><br><span class="line"><span class="comment">//构造方法不能被继承和重写。奥里给</span></span><br></pre></td></tr></table></figure>

<h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译不通过，因为在C类中x有歧义。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printX</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//		System.out.println(x);//有歧义，要么写super.x，要么下A.x</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">C</span>().printX();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p>编写一个匿名内部类，它<strong>继承Object</strong>，并在匿名内部类中，声明一个方法public void print()，输出荷包蛋-HL。请编写代码调用这个方法。<strong>巧妙的方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HL &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Object()&#123;</span><br><span class="line">            public void print()&#123;</span><br><span class="line">                System.out.println(&quot;荷包蛋-HL&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>token鉴权---JWT令牌</title>
    <url>/2023/12/02/token%E9%89%B4%E6%9D%83---JWT%E4%BB%A4%E7%89%8C/</url>
    <content><![CDATA[<h2 id="token鉴权"><a href="#token鉴权" class="headerlink" title="token鉴权"></a>token鉴权</h2><p>Token也称为动态密钥，是在加入频道时用于校验用户权限的一组字符串；鉴权是指在用户访问你的系统前，对其进行身份校验。用户在使用声网服务，如加入通话或登录信令系统时，声网会使用 Token 对其鉴权<span id="more"></span></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>客户端向服务端发送用户名和密码等凭据，请求访问某个资源。</li>
<li>服务端收到凭据后，进行身份验证，验证通过后生成一个Token。</li>
<li>服务端将生成的Token返回给客户端。</li>
<li>客户端在之后的每个请求中都携带这个Token。</li>
<li>服务端接收到请求后，从请求中获取Token。</li>
<li>服务端对Token进行验证，验证通过后允许客户端访问相应资源。</li>
</ol>
<h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p><strong>在 Cookie中存储 Token</strong><br>将 Token 存储到 Cookie中，是一种常见的方式。相较于其他方式，这种方式<strong>比较简单，易于实现</strong>。通常情况下， 服务器将Token作为响应的一部分发送给客户端浏览器，浏览器接收到响应之后，将其存储到Cookie中，并在后续的请求中自动将其发送给服务器端。Token 存储在Cookie中的好处是，<strong>这样可以使 Token 跨越不同的页面和路径，同时也可以让 Token 的过期时间变得更加灵活</strong>。但是，使用 Cookie 和 Token 会<strong>带来相应的安全问题</strong>。由于Token是明文存储在浏览器中， 因此可以通过 XSS 攻击或者窃取浏览器中的Cookie等方式直接获取Handle。因此，如果使用 Cookie 存储 Token，则需要谨慎对待。</p>
<p><strong>在 localStorage 中存储 Token</strong><br>相较于 Cookie，localStorage 本身就是一种用于存储数据的方案。 将 Token 存储到 localStorage 中的好处是，<strong>使其更加稳定，即使浏览器被关闭也不会丢失，同时也不会被传入请求中。</strong>使用 localStorage 存储数据的优点是：通过JavaScript编写，使用简单方便，<strong>需要在客户端进行存储，也减少了服务器的压力</strong>，同时也<strong>保证了数据的安全性。</strong>不过需要注意的是，虽然localStorage是将数据保存在浏览器中，但也需要注意浏览器的兼容性问题。</p>
<p><strong>在 sessionStorage 中存储 Token</strong><br>sessionStorage是一种基于键值对存储的机制。将Token存储到sessionStorage中与localStorage类似，都将数据<strong>存储在浏览器中</strong>。它的<strong>存储时间只在一个会话期内有效；如果客户关闭了浏览器或者打开了一个新的浏览器窗口，则会话期将结束，数据也将被删除，避免了因为Token漏洞导致的信息泄露问题。</strong></p>
<p><strong>在服务器端进行存储</strong><br>将Token存储在服务器端，则可以<strong>实现更高的安全性</strong>，因为所有的数据都存储在服务器端，即使数据泄露，攻击者也无法直接访问数据。但是，这种方法也有一定的缺点，<strong>因为将数据存储在服务器上会增加服务器的负载和存储成本，同时也会影响Token的访问速度。</strong></p>
<p><strong>在数据库中存储 Token</strong><br>将Token存储在数据库中的好处是，可以通过对数据库进行<strong>相应的加密措施，来实现更高的数据安全性</strong>。同时，还可以借助<strong>数据库的备份和恢复功能，提供更好的数据可用性，使服务器不会因Token认证中断而崩溃</strong>。</p>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>Token的传递方式通常有以下四种：</p>
<ul>
<li>HTTP header：Token以HTTP header的形式传递，可以避免安全风险。</li>
<li>查询参数：Token以查询参数的形式传递，存在安全风险。</li>
<li>请求体：Token以请求体的形式传递，可以避免安全风险。</li>
<li>HTTPS协议：HTTPS协议会使用SSL进行身份验证和数据传输加密，避免了Token传递中的安全风险。</li>
</ul>
<p>为了避免Token泄漏和被盗用，需要选择最安全的传递方式，并在传递过程中对Token进行加密传输。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><strong>支持跨域访问</strong>：cookie 是不支持跨域的，而 Token 可以放在请求头中传输</li>
<li><strong>无状态</strong>：Token 自身包含了用户登录的信息，无需在服务器端存储 session</li>
<li><strong>移动端支持更好</strong>：当客户端不是浏览器时，cookie 不被支持，采用 Token 无疑更好</li>
<li><strong>无需考虑 CRSF</strong>：不使用 cookie，也就无需考虑 CRSF 的防御</li>
</ul>
<hr>
<ul>
<li><strong>占带宽</strong>：正常情况下要比 session_id 更大，需要消耗更多流量，挤占更多带宽，假如你的网站每月有 10 万次的浏览器，就意味着要多开销几十兆的流量。听起来并不多，但日积月累也是不小一笔开销。实际上，许多人会在 JWT 中存储的信息会更多。</li>
<li>无法在服务端注销，那么就很难解决劫持问题</li>
<li><strong>安全性</strong>：Token中保存了用户的身份验证信息，如果Token被获取，那么持有者就可以使用Token来访问受保护的资源。因此，在Token的传输、存储以及使用过程中需要注意安全问题。</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>常见的Token分为基于session的token和基于jwt令牌的Token。基于session的token类似于session id。下面重点讲述jwt令牌。</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT（JSON Web Token）是一种用于在网络应用间传递信息的开放标准（RFC 7519）。它以 JSON 格式存储被加密后的信息，通常用于验证和身份认证。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>JWT令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz</p>
<ol>
<li>Header</li>
</ol>
<p>头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#例如</span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Payload</li>
</ol>
<p>第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的现成字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。大多存放用户的账号信息，只存储账号，不存储密码。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#例如 </span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;荷包蛋&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> HL</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Signature</li>
</ol>
<p>此部分用于防止jwt内容被篡改。这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明签名算法进行签名。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + &quot;.&quot; +           #第一部分</span><br><span class="line">base64UrlEncode(payload),                 #第二部分</span><br><span class="line">secret)                                   #使用的签名密钥</span><br></pre></td></tr></table></figure>

<h3 id="jwt-生成"><a href="#jwt-生成" class="headerlink" title="jwt 生成"></a>jwt 生成</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入maven依赖   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTcreat</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECRET</span> <span class="operator">=</span> <span class="string">&quot;3113390285&quot;</span>;<span class="comment">//使用的密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRATION_TIME</span> <span class="operator">=</span> <span class="number">3600000</span>;<span class="comment">//秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJwtToken</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        claims.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;荷包蛋HL&quot;</span>);</span><br><span class="line">        claims.put(<span class="string">&quot;root&quot;</span>,<span class="string">&quot;HL&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expirationDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(timeMillis + EXPIRATION_TIME);</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setClaims(claims)<span class="comment">//设置数据</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())<span class="comment">//创建时间</span></span><br><span class="line">                .setExpiration(expirationDate)<span class="comment">//过期时间</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, SECRET)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println( JWTcreat.createJwtToken());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//eyJhbGciOiJIUzUxMiJ9.eyJyb290IjoiSEwiLCJuYW1lIjoi6I235YyF6JuLSEwiLCJleHAiOjE3MDE1MTY2MzIsImlhdCI6MTcwMTUxMzAzMn0.1jRKb3cyoQTcdUdHJpJ7i7payam1H039_e6dSJvwekJTwphZXO45nfRvqb-HmsURB5rbgxVKQ8RfDcGF-hk9Gw</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Jwts.builder()                                      创建一个 JwtBuilder 对象</li>
<li>JwtBuilder.setClaims()                      设置 JWT 的声明（claims）</li>
<li>JwtBuilder.setIssuer()                       设置 JWT 的发行者（issuer）</li>
<li>JwtBuilder.setSubject()                     设置 JWT 的主题（subject）</li>
<li>JwtBuilder.setAudience()                 设置 JWT 的受众（audience）</li>
<li>JwtBuilder.setIssuedAt()                   设置 JWT 的签发时间（issuedAt）</li>
<li>JwtBuilder.setExpiration()                设置 JWT 的过期时间（expiration）</li>
<li>JwtBuilder.signWith()                        设置 JWT 的签名算法和密钥</li>
<li>JwtBuilder.compact()                        生成 JWT 字符串</li>
<li>compact()                                           用于将 JWT 编码为紧凑的字符串形式。即将 JWT 编码为没有空格、没有等号、没有加号、没有斜杠的紧凑字符串形式，以便在 URL 中传输</li>
</ul>
<h3 id="jwt解析"><a href="#jwt解析" class="headerlink" title="jwt解析"></a>jwt解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">               .setSigningKey(SECRET)<span class="comment">//上面设置的密钥</span></span><br><span class="line">               .parseClaimsJws(token)</span><br><span class="line">               .getBody();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Jwts.parser()                            创建一个 JwtParser 对象</li>
<li>JwtParser.setSigningKey()     设置 JWT 的签名密钥</li>
<li>JwtParser.parseClaimsJws()  解析 JWT 字符串并返回一个 Claims 对象，包含了 JWT 中所有的声明（claims）</li>
<li>getBody():                                用于从 JWT 中获取载荷（payload）信息。调用此方法将返回一个 Claims 对象，其中包含了 JWT 载荷中的所有声明信息，可以通过 get 方法获取对应的声明值</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signWith 方法接受两个参数，分别是签名算法和密钥</span><br><span class="line">签名算法的类型必须要和 JWT 头部中的 “alg” 字段一致，否则验证时会提示签名无效,因此，在使用JWT进行签名时，必须要明确指定签名算法</span><br><span class="line">签名算法是由 SignatureAlgorithm 枚举类提供的，它定义了一系列的签名算法，包括 HMAC 和 RSA</span><br><span class="line"></span><br><span class="line">在 signWith 方法中: 如果为对称算法，则密钥应该是一个 byte[] 数组或 String 类型的字符串;</span><br><span class="line">如果为非对称算法，则密钥应该是一个 Key 类型的对象，例如 RSAPrivateKey 或 RSAPublicKey</span><br><span class="line"></span><br><span class="line">SignatureAlgorithm.HS512 算法，属于 HMAC-SHA512 对称加密算法</span><br><span class="line">SignatureAlgorithm.HS256 算法，属于 HMAC-SHA256 对称加密算法</span><br><span class="line">SignatureAlgorithm.RS256 算法，属于 RSA-SHA256 非对称加密算法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CSRF全称为Cross Site Request Forgery，跨域请求伪造。这是一种很常见的Web攻击方式，如下为一个简单的攻击流程。</span><br><span class="line">1）用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</span><br><span class="line">2）在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</span><br><span class="line">3）用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</span><br><span class="line">4）网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</span><br><span class="line">5）浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>java</tag>
        <tag>开发</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>性能测试</title>
    <url>/2023/11/20/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="为什么进行性能测试"><a href="#为什么进行性能测试" class="headerlink" title="为什么进行性能测试"></a>为什么进行性能测试</h3><p>​		满足真实的业务场景（活动场景），支持大量的用户，满足商用需求。</p>
<span id="more"></span>

<h3 id="什么是性能"><a href="#什么是性能" class="headerlink" title="什么是性能"></a>什么是性能</h3><p>​		软件质量属性中的”效率“体现，指时特性与资源特性</p>
<h3 id="什么是性能测试"><a href="#什么是性能测试" class="headerlink" title="什么是性能测试"></a>什么是性能测试</h3><p>​		使用<strong>自动化工具</strong>，模拟不同的场景，对软件各项性能指标进行测试和评估的过程。（ps:网络也是性能评估的一部分，且只能由工具测试，不能像功能测试一样手动执行）</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ol>
<li>评估当前系统的能力</li>
<li>寻找性能瓶颈，优化性能</li>
<li>评估软件是否能满足未来的需要</li>
</ol>
<h3 id="功能测试与性能测试"><a href="#功能测试与性能测试" class="headerlink" title="功能测试与性能测试"></a>功能测试与性能测试</h3><p>​		功能测试：验证软件系统操作功能是否符合产品功能需求规格，主要聚焦在功能（正向、逆向）；</p>
<p>​		性能测试：验证软件系统是否满足业务需求场景，主要聚焦业务场景的满足（时间、资源）；</p>
<p>​		一般项目中，先通过功能测试，后进行性能测试。</p>
<h2 id="性能测试策略"><a href="#性能测试策略" class="headerlink" title="性能测试策略"></a>性能测试策略</h2><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>​		狭义：<strong>单用户测试</strong>。测试环境确定后，对业务中的重要业务做单独的测试，获取单用户运行的各项性能指标。（不是指单次测试）</p>
<p>​		广义：在某时刻建立一个已知性能的性能基准线，当<strong>系统软硬件环境</strong>发生变化之后再进行一次基准测试以确定变化对性能的影响。（类似控制变量法）</p>
<p>​		作用：基准测试不会单独存在，为多用户并发测试和综合测试场景提供参考依据，且为系统环境配置，优化前后的性能变化提供参考。</p>
<h3 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h3><p>​		通过<strong>逐步增加系统负载</strong>，确定在<strong>满足系统的性能指标</strong>（如响应时间等）的情况下，找出系统所能承受的<strong>最大负载量</strong>的测试。一般时长为1—2小时。</p>
<p>​		作用：找出系统的最大负载量（也可得到极限负载量），当最大负载量达到需求时，系统才能上线使用。</p>
<h3 id="稳定性测试"><a href="#稳定性测试" class="headerlink" title="稳定性测试"></a>稳定性测试</h3><p>​		在应用程序<strong>稳定运行</strong>（用户在正常的业务负载下）的情况下进行<strong>长时间测试</strong>（1天—1周），保证<strong>系统长时间稳定运行</strong>。</p>
<p>​		作用：系统在用户要求的业务负载下运行达到相应的时间，才能正式上线使用。</p>
<p>​		注意：只有用户在<strong>正常的业务负载</strong>下才能进行稳定性测试，若用户要求的负载量<strong>大于系统最大负载量</strong>，不能进行稳定性测试。应当进行负载测试，找出性能瓶颈，提升系统最大负载量后再进行稳定性测试。</p>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>​		在<strong>强负载下</strong>的测试，查看系统在<strong>峰值情况</strong>下是否具有<strong>功能隐患</strong>，是否具有良好的<strong>容错能力与可恢复能力</strong>。常用的测试场景有：极限负载情况下导致系统崩溃的<strong>破坏性压力测试</strong>和高负载下的长时间<strong>稳定性压力测试</strong>。</p>
<p>​		注意：破坏性压力测试的负载量为系统的<strong>极限负载量</strong>，即系统即将崩溃。稳定性压力测试的负载量应当<strong>大于系统的最大负载量，小于系统的极限负载量</strong>。</p>
<h3 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h3><p>​		并发测试（绝对并发）：指在<strong>极短的时间</strong>内，发送<strong>多个请求</strong>，验证系统对<strong>并发</strong>的处理能力。与负载测试（相对并发）相区别。特定活动场景如：抢红包、双11秒杀等。</p>
<h2 id="性能测试指标"><a href="#性能测试指标" class="headerlink" title="性能测试指标"></a>性能测试指标</h2><p>​		一些经过运算得出的结果，来量化衡量某种操作的性能好坏；如：响应时间（RT）。</p>
<h3 id="响应时间（RT）"><a href="#响应时间（RT）" class="headerlink" title="响应时间（RT）"></a>响应时间（RT）</h3><p>​		指用户从客户端发起一个请求开始，到客户端接收到从服务器端返回的结果，整个过程耗费的时间。即<strong>服务器的处理时间</strong>加<strong>请求&#x2F;结果的网络传输时间</strong>。</p>
<p>​		注意：不包括发消息时前端页面的处理时间和收到消息后前端页面的渲染显示时间。</p>
<h3 id="并发（用户）数"><a href="#并发（用户）数" class="headerlink" title="并发（用户）数"></a>并发（用户）数</h3><p>​		某一时刻<strong>同时</strong>向服务器<strong>发起请求</strong>的用户数（请求数）。</p>
<h3 id="吞吐量（Throughput"><a href="#吞吐量（Throughput" class="headerlink" title="吞吐量（Throughput)"></a>吞吐量（Throughput)</h3><p>​		指<strong>单位时间内</strong>处理客户端请求的数量，<strong>直接</strong>体现系统的性能承载能力。</p>
<p>​		QPS：Query Per Second。<strong>每秒查询数</strong>，即服务器每秒处理的指定请求（查询请求）的数量。</p>
<p>​		TPS：Transactions Per Second。<strong>每秒事务数</strong>，即服务器每秒处理的事务请求的数量。 事务：即对应的一次业务操作，可能包含多个请求。一般由测试人员定义事务的大小。当一个事务对应一个请求时，TPS&#x3D;QPS。</p>
<h3 id="点击数"><a href="#点击数" class="headerlink" title="点击数"></a>点击数</h3><p>​		指客户端向服务端发送请求时，<strong>所有的页面资源元素</strong>（图片，链接，css，js等）的请求总量。</p>
<p>​		注意：只有web项目才有此指标；且点击数不是页面上的一次点击，而是这次点击所发出的总的请求数。</p>
<h3 id="错误率"><a href="#错误率" class="headerlink" title="错误率"></a>错误率</h3><p>​		指系统在<strong>负载情况</strong>下，失败业务的概率。即错误率&#x3D;（失败业务&#x2F;业务总数）*100%。大多数系统都会要求错误率无限接近于0；错误率是一个性能指标，不是功能上的随机bug。先解决随机功能bug才能进行性能测试。</p>
<p>​		注意：只有在负载情况下的失败才是性能上的问题，才能统计错误率，否则只能是功能上的随机bug。</p>
<p>​		例如，一个用户发起10次请求，成功8次，错误2次，这只能说明出现了随机功能bug。因为没有具体的负载业务场景。</p>
<h3 id="资源使用率"><a href="#资源使用率" class="headerlink" title="资源使用率"></a>资源使用率</h3><p>​		系统各种资源的使用情况，<strong>一般</strong>资源使用率&#x3D;（资源使用量&#x2F;资源总量）*100%。对于cpu与内存，指代的是使用的cpu与内存的百分比；而对于磁盘IO与网络，指的是读取写入速度的百分比与网络传输速度的百分比。</p>
<h2 id="性能测试的流程"><a href="#性能测试的流程" class="headerlink" title="性能测试的流程"></a>性能测试的流程</h2><h3 id="性能测试需求分析"><a href="#性能测试需求分析" class="headerlink" title="性能测试需求分析"></a>性能测试需求分析</h3><p>​		熟悉需求，获取性能需求指标。</p>
<p>​		明确被测系统（业务功能、架构）—明确测试内容（高频业务&#x2F;逻辑复杂业务、数据量大业务）—明确测试策略（负载、稳定…)—明确测试指标（预期指标对比&#x2F;预估指标）</p>
<h3 id="性能测试的计划和方案"><a href="#性能测试的计划和方案" class="headerlink" title="性能测试的计划和方案"></a>性能测试的计划和方案</h3><p>​		WWW方案。What、Who、How。</p>
<h3 id="性能测试用例"><a href="#性能测试用例" class="headerlink" title="性能测试用例"></a>性能测试用例</h3><p>​		用例名称、用例编号、用例描述、前置条件、用例步骤、期望性能结果、实际结果。</p>
<h3 id="性能测试执行"><a href="#性能测试执行" class="headerlink" title="性能测试执行"></a>性能测试执行</h3><p>​		建立测试环境—编写测试脚本—性能测试监控—执行测试脚本。</p>
<h3 id="性能分析与调优"><a href="#性能分析与调优" class="headerlink" title="性能分析与调优"></a>性能分析与调优</h3><p>​		性能测试分析人员根据对结果的分析，如果不符合性能需求，则提出性能bug，由开发人员进行后续的调优。而后继续进行性能验证，直到满足性能需求为止。</p>
<h3 id="性能测试报告总结"><a href="#性能测试报告总结" class="headerlink" title="性能测试报告总结"></a>性能测试报告总结</h3><ul>
<li>测试工作的回顾</li>
<li>缺陷分析和调优</li>
<li>风险评估</li>
<li>性能测试结果</li>
<li>总结与该进</li>
</ul>
<p>简单使用jmeter进行性能测试，详见<a href="/2023/12/16/Jmeter---%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/" title="Jmeter---压力测试">Jmeter---压力测试</a></p>
<p>​		关于性能测试需求分析，描述正确的是:（ACD）<br>A、性能测试需求分析时，需要对系统的业务功能非常熟悉</p>
<p>B、性能测试需求分析时，可以不用关心系统的技术实现</p>
<p>C、有明确需求指标时，性能测试的指标完全根据需求来确定</p>
<p>D、没有明确的需求指标时，性能测试的指标根据经验来确定</p>
<p>ps：需要关心系统的技术实现，不同的环境、操作系统、资源对系统的性能影响。</p>
<p>​		关于性能测试环境，描述正确的是: （AD）</p>
<p>A、性能测试环境和功能测试环境一样，需要使用指定的软件及版本</p>
<p>B、性能测试环境和功能测试环境一样，可以多个测试人员一起使用</p>
<p>C、性能测试环境和功能测试环境一样，可以把软件都安装在一台服务器上，只需要保证环境可以正常访问即可</p>
<p>D、性能测试环境可以找运维和开发协助搭建</p>
<p>ps：多个测试人员一起使用就瓜分了系统资源了，判断不出具体的系统时间，空间特性；要保证测试环境与真实环境一致，测试才有意义。</p>
<p>​		关于性能测试执行，描述正确的是: （ABC）</p>
<p>A、性能测试脚本执行前，必须保证所有的脚本都调试通过了</p>
<p>B、性能测试脚本执行前，还需要设置脚本运行的场景〔并发数、运行时间、启动方式等等)</p>
<p>C、性能测试脚本执行时，需要同步监控服务器的各项性能指标</p>
<p>D、服务器的各项性能指标，可以在性能测试结束后再统一收集</p>
<p>ps：性能指标需要同步收集，最后只能收集到状态或小部分指标，不够全面准确。</p>
<p>​		关于性能测试分析和调优，描述正确的是:（AD）<br>A、测试人员需要对性能测试结果进行分析，如果有问题则提交bug</p>
<p>B、测试人员需要对性能测试的问题进行调优，找到问题的原因，并给出解决建议</p>
<p>C、经验丰富的性能调优人员，通常能准确的定位出性能的根本原因，一次就能修改成功</p>
<p>D、性能调优后，需要测试对比是否有性能提升;通常性能调优要经过很多轮的优化才能最终达成性能指标</p>
<p>ps：调优是开发的工作。</p>
]]></content>
      <tags>
        <tag>测试</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣--394</title>
    <url>/2023/11/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98--394%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="力扣每日一题–394字符串解码"><a href="#力扣每日一题–394字符串解码" class="headerlink" title="力扣每日一题–394字符串解码"></a>力扣每日一题–394字符串解码</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。<span id="more"></span></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>首先分析，出现的数字倍数可能不只是小于10的，完全可能是成百上千的，于是对于数字需要一直遍历，才能得出对应的数字意义。</p>
<p>其次，可能[ ]里面还包含有[ ]，故对[ ]的结果，应当存储起来，后续可能会再用到。</p>
<p>最后，经过分析，采用栈解答此问题。对于数字，一直遍历出对应得数字，得到值后放入栈中。对于字母和 [ ，直接放入栈中。当遍历到 ] 时，直接将其出栈到 [ 。之后再出栈，得到对应的倍数（ [ 之后出栈的数必定是对应的倍数）。将其按照倍数进行填充，结果再次入栈。直到原字符串遍历完毕。最后遍历栈，得出最后结果。（若使用传统的栈，则最后将整个栈翻转再遍历得出最后的结果）</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//数字需要重复判断，才能确定是数字啦</span></span><br><span class="line">        <span class="comment">//数字和左括号直接入栈，遇见右括号的时候，出栈</span></span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">LinkedList</span>();<span class="comment">//栈</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(index)))</span><br><span class="line">          &#123;</span><br><span class="line">              String s1=getDigit(s);</span><br><span class="line">              <span class="comment">//list.addLast(s1);</span></span><br><span class="line">              list.push(s1);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(index)==<span class="string">&#x27;[&#x27;</span>||Character.isLetter(s.charAt(index)))</span><br><span class="line">          <span class="comment">//list.addLast(s.charAt(index++)+&quot;&quot;);</span></span><br><span class="line">          list.push(s.charAt(index++)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">else</span>  <span class="comment">//出栈</span></span><br><span class="line">          &#123;</span><br><span class="line">              StringBuilder out=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">             LinkedList&lt;String&gt; temp=<span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">          <span class="comment">//  while(list.peekLast()!=&quot;[&quot;)</span></span><br><span class="line">         <span class="comment">//  while( !&quot;[&quot;.equals(list.peekLast()))</span></span><br><span class="line">         <span class="keyword">while</span>(!<span class="string">&quot;[&quot;</span>.equals(list.peek()))</span><br><span class="line">           <span class="comment">//String不是重写==了吗？不就是调用</span></span><br><span class="line">           <span class="comment">//好像搞反了，别人重写的是equals，，==始终就是比的地址，对象的话，歪日</span></span><br><span class="line">           <span class="comment">//垃圾了垃圾了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//temp.addLast(list.pop());</span></span><br><span class="line">                temp.push(list.pop());</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// list.removeLast();</span></span><br><span class="line">           list.pop();</span><br><span class="line">            <span class="type">int</span> f=Integer.parseInt(list.pop());</span><br><span class="line">           <span class="comment">// Collections.reverse(temp);</span></span><br><span class="line">            String k=toString(temp);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;f;i++)</span><br><span class="line">            out.append(k);</span><br><span class="line">            <span class="comment">//list.addLast(out.toString());</span></span><br><span class="line">            list.push(out.toString());</span><br><span class="line">            index++;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> toString(list);  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">(LinkedList&lt;String&gt; temp)</span></span><br><span class="line">    &#123;</span><br><span class="line">      StringBuilder out=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(String c:temp)</span><br><span class="line">      out.append(c);</span><br><span class="line">      <span class="keyword">return</span> out.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDigit</span><span class="params">(String t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder out=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(Character.isDigit(t.charAt(index)))</span><br><span class="line">           out.append(t.charAt(index++));</span><br><span class="line">        <span class="keyword">return</span> out.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>为什么写这道题呢？是因为自己中间犯了些小错误。也对LinkedList有了些新的认识。</p>
<h3 id="LInkedList"><a href="#LInkedList" class="headerlink" title="LInkedList"></a>LInkedList</h3><p>​		采用双向链表结构，使用效率高于ArrayList。常用于栈和队列的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用作栈</span></span><br><span class="line">push()<span class="comment">//向list的首部插入数据，对应addFirst()方法</span></span><br><span class="line">pop()<span class="comment">//删除list的首部的数据，并将它返回，对应removeFirst()方法</span></span><br><span class="line">peek()<span class="comment">//得到list的首部数据，但是不删除它，对应peekFirst()方法</span></span><br><span class="line"><span class="comment">/*使用这三个函数也可以得到一个栈的操作</span></span><br><span class="line"><span class="comment">addLast()</span></span><br><span class="line"><span class="comment">removeLast()</span></span><br><span class="line"><span class="comment">peekLast()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//用作队列</span></span><br><span class="line">offer()<span class="comment">//向list的尾部插入数据，对应addLast()方法</span></span><br><span class="line">poll()<span class="comment">//删除list的首部数据，并将其返回，对应removeFirst()方法</span></span><br><span class="line">peek()<span class="comment">//得到list的首部数据，但是不删除它，对应peekFirst()方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比较：这么一看，栈和队列的删除方法其实是一个东西对吧。不是指删除的内容是一样的，但是对应的操作都是删除list首部的元素。</span></span><br><span class="line"><span class="comment">ps:我之前一直以为栈的操作对应的就是addFirst()和removeFirst(),队列的操作就是addLast()和removeLast(),丢，这么一看，被自己蠢哭了。addLast()和removeLast()对应的还是栈的操作了，先进后出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">//用作List</span></span><br><span class="line">add()<span class="comment">//向list尾部插入数据</span></span><br><span class="line">remove()<span class="comment">//删除list尾部数据</span></span><br></pre></td></tr></table></figure>

<p>建议以后使用LinkedList时，<strong>都采用addFist(),removeLast()等这种方法操作list。而不使用push，poll()等方法</strong>。自己决定插入和删除的位置，更加的灵活多变，也更强大。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣经典题---编辑距离</title>
    <url>/2023/12/12/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%A2%98---%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。你可以对一个单词进行如下三种操作：<span id="more"></span></p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>编辑距离（Edit Distance），也称为Levenshtein距离，是一种用于比较两个字符串之间相似度或差异的度量方法。它表示在将一个字符串转换为另一个字符串所需的最少编辑操作次数，这些编辑操作可以是<strong>插入（Insertion）、删除（Deletion）、替换（Substitution）或交换（Transposition）</strong>字符。</p>
<p><strong>交换</strong>字符：交换相邻的字符串，减少编辑距离，通常代价也设为1。若没有交换操作，使用插入，删除，替换操作替代时，会增大编辑距离。（删除前一个字符，再向后一个字符插入，2步）</p>
<ol>
<li>创建一个(m+1) x (n+1)的矩阵D，其中D[i][j]表示将S1的前i个字符转换为S2的前j个字符所需的最小编辑距离。</li>
<li>初始化矩阵D的第一行和第一列：<ul>
<li>D[i][0] &#x3D; i，表示将S1的前i个字符转换为一个空字符串所需的编辑距离。</li>
<li>D[0][j] &#x3D; j，表示将一个空字符串转换为S2的前j个字符所需的编辑距离。</li>
</ul>
</li>
<li>开始填充矩阵D的其余部分。对于每个D[i][j]，可以执行以下操作：<ul>
<li>如果S1的第i个字符等于S2的第j个字符，则D[i][j] &#x3D; D[i-1][j-1]，即不需要执行任何编辑操作。</li>
<li>否则，D[i][j] &#x3D; min(D[i-1][j], D[i][j-1], D[i-1][j-1]) + 1。这表示需要执行插入、删除或替换操作，选择其中编辑距离最小的操作，并将当前编辑距离加1。</li>
</ul>
</li>
<li>最终，矩阵D的右下角元素D[m][n]将是S1和S2之间的编辑距离，即将S1转换为S2所需的最小编辑操作次数。</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">题目给定了两个单词，设为 A 和 B，这样我们就能够六种操作方法。但我们可以发现，如果我们有单词 A 和单词B：</span><br><span class="line"></span><br><span class="line">对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为 doge，单词 B 为 dog 时，我们既</span><br><span class="line">可以删除单词 A 的最后一个字符 e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的 doge；</span><br><span class="line"></span><br><span class="line">同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；</span><br><span class="line">对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为 bat，单词 B 为 cat 时，我们修改</span><br><span class="line">单词 A 的第一个字母 b -&gt; c，和修改单词 B 的第一个字母 c -&gt; b 是等价的。</span><br><span class="line"></span><br><span class="line">这样一来，本质不同的操作实际上只有三种：</span><br><span class="line">在单词 A 中插入一个字符；</span><br><span class="line">在单词 B 中插入一个字符；</span><br><span class="line">修改单词 A 的一个字符。</span><br><span class="line"></span><br><span class="line">这样以来，我们就可以把原问题转化为规模较小的子问题。我们用 A = horse，B = ros 作为例子，来看一看是如</span><br><span class="line">何把这个问题转化为规模较小的若干子问题的。</span><br><span class="line">在单词 A 中插入一个字符：如果我们知道 horse 到 ro 的编辑距离为 a，那么显然 horse 到 ros 的编辑距离</span><br><span class="line">不会超过 a + 1。这是因为我们可以在 a 次操作后将 horse 和 ro 变为相同的字符串，只需要额外的 1 次操</span><br><span class="line">作，在单词 A 的末尾添加字符 s，就能在 a + 1 次操作后将 horse 和 ro 变为相同的字符串；</span><br><span class="line">在单词 B 中插入一个字符：如果我们知道 hors 到 ros 的编辑距离为 b，那么显然 horse 到 ros 的编辑距离</span><br><span class="line">不会超过 b + 1，原因同上；</span><br><span class="line">修改单词 A 的一个字符：如果我们知道 hors 到 ro 的编辑距离为 c，那么显然 horse 到 ros 的编辑距离不会</span><br><span class="line">超过 c + 1，原因同上。</span><br><span class="line"></span><br><span class="line">那么从 horse 变成 ros 的编辑距离应该为 min(a + 1, b + 1, c + 1)。</span><br><span class="line"></span><br><span class="line">注意：为什么我们总是在单词 A 和 B 的末尾插入或者修改字符，能不能在其它的地方进行操作呢？答案是可以的，</span><br><span class="line">但是我们知道，操作的顺序是不影响最终的结果的。例如对于单词 cat，我们希望在 c 和 a 之间添加字符 d 并且</span><br><span class="line">将字符 t 修改为字符 b，那么这两个操作无论为什么顺序，都会得到最终的结果 cdab。</span><br><span class="line"></span><br><span class="line">因此，我们就可以使用动态规划来解决这个问题了。我们用 D[i][j] 表示 A 的前 i 个字母和 B 的前 j 个字母之</span><br><span class="line">间的编辑距离。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n + m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DP 数组</span></span><br><span class="line">        <span class="type">int</span>[][] D = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        <span class="comment">//从i到空字符串需要i步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            D[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            D[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> D[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> D[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left_down</span> <span class="operator">=</span> D[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) != word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    left_down += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                D[i][j] = Math.min(left, Math.min(down, left_down));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> D[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>接口自动化测试---基础</title>
    <url>/2023/11/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="接口测试基础"><a href="#接口测试基础" class="headerlink" title="接口测试基础"></a>接口测试基础</h2><p>接口：系统之间数据交互的通道。</p>
<p>接口测试：基于不同的输入参数，校验接口响应数据与预期数据是否一致。<span id="more"></span></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>接口文档解析——一般都有对应得接口信息。如没有，则自行获取。对于web接口，可以采用开发者模式F12得到相应的接口信息。对于app接口，则采用抓包的方式获取接口信息，如Fidder</li>
<li>设计测试用例</li>
<li>脚本开发</li>
<li>执行脚本</li>
<li>缺陷跟踪</li>
<li>测试报告</li>
</ul>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL：是互联网上标准资源得地址，一般称为统一资源定位符</p>
<p>组成：协议::&#x2F;&#x2F;hostname[:port]&#x2F;path&#x2F;[?查询参数1&amp;查询参数2]，即协议，服务器地址，端口号，资源路径，参数</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP：超文本传输协议，基于请求与响应的应用层协议</p>
<ul>
<li>HTTP请求（请求行，请求头，请求体）</li>
<li>HTTP响应（响应行，响应头，响应体）</li>
</ul>
<h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul>
<li><p>请求行：<img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231130192119149.png" alt="image-20231130192119149"></p>
<ul>
<li><p>位置：第一行</p>
</li>
<li><p>作用：说明请求方法、访问的资源、协议版本</p>
</li>
<li><p>常用方法</p>
<ul>
<li>Get</li>
<li>Post</li>
<li>Put</li>
<li>Delect</li>
</ul>
</li>
</ul>
</li>
<li><p>请求头</p>
<ul>
<li>位置：第二行到空白行之间</li>
<li>作用：通知服务端请求信息</li>
<li>特点：由键值对组成，每行一对</li>
<li>Content-Type：请求体数据类型<ul>
<li>text&#x2F;html：HTML格式</li>
<li>image&#x2F;jpeg：jpg图片格式</li>
<li><strong>application&#x2F;json</strong>：JSON数据格式</li>
<li><strong>application&#x2F;x-www-form-urlencoded</strong>：表单默认的提交数据格式</li>
<li>multipart&#x2F;form-data：表单中进行文件上传</li>
</ul>
</li>
</ul>
</li>
<li><p>请求体：<strong>（可以没有对应的请求体内容）</strong></p>
<ul>
<li>位置：空白行之后的内容</li>
<li>作用：传输数据实体 </li>
<li>注意：请求体常在<strong>POST、PUT</strong>方法中使用 </li>
<li>常配合的请求头：<strong>Content-Type</strong>和<strong>Content-Length</strong></li>
</ul>
</li>
</ul>
<h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h4><ul>
<li>状态行 <img src="https://oss-hl.oss-cn-chengdu.aliyuncs.com/img/image-20231130193147639.png" alt="image-20231130193147639" style="zoom:67%;" /><ul>
<li>位置：响应数据第一行 </li>
<li>作用：描述服务器处理结果 </li>
<li>内容: 状态行由协议版本号、<strong>状态码</strong>、状态消息组成</li>
<li>状态码：表示此次请求的响应状态，详细见最后的状态码表。<ul>
<li>1XX：指示信息</li>
<li><strong>2XX</strong>：成功 </li>
<li>3XX：重定向 </li>
<li><strong>4XX</strong>：客户端错误 </li>
<li><strong>5XX</strong>：服务端错误</li>
</ul>
</li>
</ul>
</li>
<li>响应头<ul>
<li>位置：第二行开始到空白行之间 </li>
<li>作用：描述客户端端要使用的一些附加信息 </li>
<li>特点: 响应头由键值对组成，每行一对</li>
<li>也有Content-Type与Content-Length，表明返回的数据类型与长度</li>
</ul>
</li>
<li>响应体<ul>
<li>位置：响应数据空白行之后</li>
<li>作用：服务器返回的数据实体 </li>
<li>特点：有图片、json、xml、html等多种类型</li>
</ul>
</li>
</ul>
<p>使用工具进行接口自动化测试将使用新的文章记录。</p>
<hr>
<p>使用Jmeter进行自动化测试，详见<a href="/2023/12/13/Jmeter---%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/" title="Jmeter---接口测试">Jmeter---接口测试</a></p>
<hr>
<h2 id="接口自动化测试"><a href="#接口自动化测试" class="headerlink" title="接口自动化测试"></a>接口自动化测试</h2><ul>
<li>选取自动化测试用例 </li>
<li>搭建自动化测试环境 </li>
<li>搭建自动化测试框架 </li>
<li>代码实现自动化 </li>
<li>输出测试报告 </li>
<li>实现持续集成</li>
</ul>
<h3 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install requests  <span class="comment">#安装</span></span><br><span class="line">request --version 	<span class="comment">#验证</span></span><br></pre></td></tr></table></figure>

<h4 id="Requests发送请求"><a href="#Requests发送请求" class="headerlink" title="Requests发送请求"></a>Requests发送请求</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.请求方法（url，params=<span class="literal">None</span>，data=<span class="literal">None</span>，json=<span class="literal">None</span>，headers=<span class="literal">None</span>，files=<span class="literal">None</span>）<span class="comment">#必须传入对应的url地址，其余参数非必须</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;说明：</span></span><br><span class="line"><span class="string">常见的请求方法： get/post/put/delete</span></span><br><span class="line"><span class="string">url：请求的url地址</span></span><br><span class="line"><span class="string">params：请求查询参数</span></span><br><span class="line"><span class="string">data：请求体为form表单参数</span></span><br><span class="line"><span class="string">json：请求体为json参数</span></span><br><span class="line"><span class="string">headers：请求头参数</span></span><br><span class="line"><span class="string">Files：文件参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Response响应"><a href="#Response响应" class="headerlink" title="Response响应"></a>Response响应</h4><ul>
<li>response.status_code ：状态码 </li>
<li>response.json() ：JSON形式的响应内容</li>
<li>response.text ：文本形式的响应内容 </li>
<li>response.url ：请求url </li>
<li>response.encoding：查看响应头部字符编码 </li>
<li>response.headers ：头信息 </li>
<li>response.cookies ：cookie信息</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;application&quot;</span>:<span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;applicaiton_client_type&quot;</span>:<span class="string">&quot;weixin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;accounts&quot;</span>:<span class="string">&quot;huace_xm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span>:<span class="number">123456</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;username&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs5 = requests.request(url=<span class="string">&quot;http://shop-xo.hctestedu.com/index.php?s=api/region/index&quot;</span>,</span><br><span class="line">                 method=<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                 params=params,</span><br><span class="line">                 data=data)</span><br><span class="line"><span class="built_in">print</span>(rs5.json())</span><br><span class="line"><span class="comment">#使用对应的方法，参数，调用对应的方法或者request方法，得到响应结果</span></span><br></pre></td></tr></table></figure>

<h2 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h2><ul>
<li>200 OK 服务器成功返回用户请求的数据 </li>
<li>201 CREATED 用户新建或修改数据成功 </li>
<li>204 NO CONTENT 用户删除数据成功 </li>
<li>301 Moved Permanently 被请求的资源已永久移动到新位置 </li>
<li>302 Move Temporarily 被请求的资源临时性移动到新位置 </li>
<li>400 Bad Request 客户端请求有语法错误，不能被服务器所理解 </li>
<li>401 Unauthorized 未授权的（未登录） </li>
<li>403 Forbidden 表示用户得到授权，但是访问是被禁止的 </li>
<li>404 Not Found 请求资源不存在 </li>
<li>500 INTERNAL SERVER ERROR 服务器发生错误，用户将无法判断发出的请求是否成功 </li>
<li>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<a href="/2023/12/02/2023-12-01-%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95---%E8%BF%9B%E9%98%B6/" title="接口自动化测试---进阶">接口自动化测试---进阶</a>
]]></content>
      <tags>
        <tag>测试</tag>
        <tag>接口测试</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>日志logger</title>
    <url>/2023/11/25/%E6%97%A5%E5%BF%97logger/</url>
    <content><![CDATA[<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>​		1）什么是日志</p>
<p>​		日志（Log）是指记录程序运行状态的信息。在程序运行过程中，它可以记录代码中变量的变化情况，跟踪代码运行时的轨迹，向文件或控制台输出代码的调试信息等。</p>
<span id="more"></span>

<p>​		2）特点</p>
<ol>
<li>调试程序</li>
<li>定位跟踪bug</li>
<li>根据日志，查看系统运行是否出错</li>
<li>分析用户行为，与数据统计</li>
</ol>
<p>​		3）日志级别	</p>
<ul>
<li>DEBUG 调试级别：打印非常详细的日志信息，通常用于对代码的调试</li>
<li>INFO 信息级别：打印一般的日志信息，突出强调程序的运行过程</li>
<li>WARNING 警告级别：打印警告日志信息，表明会出现潜在错误的情形，一般不影响软件的正常使用</li>
<li>ERROR 错误级别：打印错误异常信息，该级别的错误可能会导致系统的一些功能无法正常使用</li>
<li>CRITICAL 严重错误级别：一个严重的错误，这表明系统可能无法继续运</li>
</ul>
<p>​		4）说明</p>
<ul>
<li><p>上面的日志级别是从上到下依次升高的，即：DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</p>
</li>
<li><p>当为程序指定一个日志级别后，程序会记录所有日志级别大于或等于指定日志级别的日志信息，而不是仅仅记录指定级别的日志信息</p>
</li>
<li><p>开发常用级别DEBUG、INFO、WARNING、ERROR ；测试常用级别：INFO、ERROR</p>
</li>
</ul>
<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>​		Python中有一个标准库模块logging可以直接记录日志</p>
<p>​		1）基本用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&quot;这是一条调试信息&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;这是一条普通信息&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;这是一条警告信息&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;这是一条错误信息&quot;</span>)</span><br><span class="line">logging.critical(<span class="string">&quot;这是一条严重错误信息&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">WARNING:root:这是一条警告信息</span></span><br><span class="line"><span class="string">ERROR:root:这是一条错误信息</span></span><br><span class="line"><span class="string">CRITICAL:root:这是一条严重错误信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;why</span></span><br><span class="line"><span class="string">默认的日志级别为warning，故只输出warning和高级别日志</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​		2）更改日志级别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"><span class="comment">#这样就会输出debug以上的日志信息，即所有日志信息</span></span><br><span class="line"><span class="comment">#注意要再使用日志之前就更改日志级别，否则还是默认的warning级别</span></span><br></pre></td></tr></table></figure>

<p>​		注意：</p>
<ul>
<li><p>在开发环境和测试环境中，为了尽可能详细的查看程序的运行状态来保证上线后的稳定性，可以使用DEBUG或INFO级别的日志获取</p>
<p>详细的日志信息，这是非常耗费机器性能的。</p>
</li>
<li><p>在生产环境中，通常只记录程序的异常信息、错误信息等（设置成WARNING或ERROR级别），这样既可以减小服务器的I&#x2F;O压力，也</p>
<p>可以提高获取错误日志信息的效率和方便问题的排查。</p>
</li>
</ul>
<p>​		3）日志格式</p>
<p>​		默认的日志的格式为：日志级别:Logger名称:日志内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义日志格式</span></span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&quot;%(levelname)s:%(name)s:%(message)s&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​		format中用到的占位符字符串格式</p>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%(name)s</td>
<td align="center">Logger的名字</td>
</tr>
<tr>
<td align="center">%(levelno)s</td>
<td align="center">数字形式的日志级别</td>
</tr>
<tr>
<td align="center"><strong>%(levelname)s</strong></td>
<td align="center">文本形式的日志级别</td>
</tr>
<tr>
<td align="center">%(pathname)s</td>
<td align="center">调用日志输出函数的模块的完整路径名，可能没有</td>
</tr>
<tr>
<td align="center"><strong>%(filename)s</strong></td>
<td align="center">调用日志输出函数的模块的文件名</td>
</tr>
<tr>
<td align="center">%(module)s</td>
<td align="center">调用日志输出函数的模块名</td>
</tr>
<tr>
<td align="center">%(funcName)s</td>
<td align="center">调用日志输出函数的函数名</td>
</tr>
<tr>
<td align="center"><strong>%(lineno)d</strong></td>
<td align="center">调用日志输出函数的语句所在的代码行</td>
</tr>
<tr>
<td align="center">%(created)f</td>
<td align="center">当前时间，用UNIX标准的表示时间的浮 点数表示</td>
</tr>
<tr>
<td align="center">%(relativeCreated)d</td>
<td align="center">输出日志信息时的，自Logger创建以来的毫秒数</td>
</tr>
<tr>
<td align="center"><strong>%(asctime)s</strong></td>
<td align="center">字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”</td>
</tr>
<tr>
<td align="center">%(thread)d</td>
<td align="center">线程ID。可能没有</td>
</tr>
<tr>
<td align="center">%(threadName)s</td>
<td align="center">线程名。可能没有</td>
</tr>
<tr>
<td align="center">%(process)d</td>
<td align="center">进程ID。可能没有</td>
</tr>
<tr>
<td align="center"><strong>%(message)s</strong></td>
<td align="center">用户输出的消息</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment">#常用格式</span></span><br><span class="line">fmt = <span class="string">&#x27;%(asctime)s %(levelname)s [%(name)s] [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&#x27;</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=fmt)</span><br><span class="line"><span class="comment">#注意，若写多条basicConfig只生效一条</span></span><br><span class="line"><span class="comment">#故将日志级别，格式，输出写在一条语句中</span></span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&quot;调试&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;信息&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;警告&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​		4）日志输出</p>
<p>​		默认情况下Python的logging模块将日志打印到了标准输出中（控制台）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将日志输出到文件中</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">fmt = <span class="string">&#x27;%(asctime)s %(levelname)s [%(name)s] [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&#x27;</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">&quot;a.log&quot;</span>, level=logging.INFO, <span class="built_in">format</span>=fmt)</span><br><span class="line"><span class="comment">#同时指定日志级别，日志格式，日志输出</span></span><br><span class="line"><span class="comment">#这种方式写入文件，中文乱码</span></span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&quot;调试&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;信息&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;警告&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​		注意：通过以上操作，可以进行基本的日志操作。但是如何将日志文件同时输出到文件和控制台呢？将警告日志输出到控制台，错误日志输出到文件中该如何操作呢？日志文件过大如何处理呢？</p>
<h3 id="logger-高阶"><a href="#logger-高阶" class="headerlink" title="logger 高阶"></a>logger 高阶</h3><p>​		1）logger 4大模块</p>
<ul>
<li>日志器———Logger———使用日志的入口</li>
<li>处理器———Handler———日志的输出，即输出到控制台还是文件中</li>
<li>格式器 ———Formatter ———决定日志记录的最终输出格式</li>
<li>过滤器 ———Filter——— 提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</li>
</ul>
<p>​		2）模块间的关系</p>
<ul>
<li>日志器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等</li>
<li>不同的处理器（handler）可以将日志输出到不同的位置</li>
<li>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置</li>
<li>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</li>
<li>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志</li>
</ul>
<p>​		简单点说就是：日志器（logger）是入口，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。</p>
<h4 id="Logger-类"><a href="#Logger-类" class="headerlink" title="Logger 类"></a>Logger 类</h4><p>​		1）使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger = logging.getLogger()</span><br><span class="line">logger = logging.getLogger(<span class="string">&quot;myLogger&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​		logging.getLogger()方法有一个可选参数name，该参数表示将要返回的日志器的名称标识，如果不提供该参数，则返回root日志器</p>
<p>对象。 若以相同的name参数值多次调用getLogger()方法，将会返回指向同一个logger对象的引用（类似单例的感觉，<strong>就是采用相同的名字多次调用返回的是同一个对象</strong>）。</p>
<p>​		2）方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.debug()</span><br><span class="line">logger.info()</span><br><span class="line">logger.warning()    <span class="comment">#输出日志</span></span><br><span class="line">logger.error()</span><br><span class="line">logger.critical()</span><br><span class="line"></span><br><span class="line">logger.setLevel()   <span class="comment">#设置日志器将会处理的日志消息的最低级别</span></span><br><span class="line">logger.addHandler() <span class="comment">#为该logger对象添加一个handler对象</span></span><br><span class="line">logger.addFilter()  <span class="comment">#为该logger对象添加一个filter对象</span></span><br></pre></td></tr></table></figure>

<h4 id="Handler-类"><a href="#Handler-类" class="headerlink" title="Handler 类"></a>Handler 类</h4><p>​	Handler对象的作用是将消息分发到handler指定的位置，比如：<strong>控制台、文件、网络、邮件</strong>等。 Logger对象可以通过addHandler()方</p>
<p>法为自己添加<strong>多个</strong>handler对象。</p>
<p>​		1）使用</p>
<p>​	在程序中不应该直接实例化和使用Handler实例，因为Handler是一个基类，它只定义了Handler应该有的接口。 应该使用Handler实</p>
<p>现类来创建对象，logging中内置的常用的Handler包括：</p>
<ul>
<li><strong>logging.StreamHandler</strong>       		  将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象,控制台输出。</li>
<li>logging.FileHandler              		    将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</li>
<li><strong>logging.handlers.RotatingFileHandler</strong> 			  将日志消息发送到磁盘文件，并支持日志文件按大小切割</li>
<li><strong>logging.hanlders.TimedRotatingFileHandler</strong>   将日志消息发送到磁盘文件，并支持日志文件按时间切割</li>
<li>logging.handlers.HTTPHandler 							   将日志消息以GET或POST的方式发送给一个HTTP服务器</li>
<li>logging.handlers.SMTPHandler						 	   将日志消息发送给一个指定的email地址</li>
</ul>
<p>​		2）方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler.setLevel() <span class="comment">#设置handler将会处理的日志消息的最低严重级别</span></span><br><span class="line">handler.setFormatter() <span class="comment">#为handler设置一个格式器对象</span></span><br><span class="line">handler.addFilter() <span class="comment">#为handler添加一个过滤器对象</span></span><br></pre></td></tr></table></figure>

<h4 id="Formatter-类"><a href="#Formatter-类" class="headerlink" title="Formatter 类"></a>Formatter 类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用</span></span><br><span class="line">formatter = logging.Formatter(fmt=<span class="literal">None</span>, datefmt=<span class="literal">None</span>, style=<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line"><span class="comment">#fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值</span></span><br><span class="line"><span class="comment">#datefmt：指定日期格式字符串，如果不指定该参数则默认使用&quot;%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line"><span class="comment">#style：Python 3.2新增的参数，可取值为 &#x27;%&#x27;, &#x27;&#123;&#x27;和 &#x27;$&#x27;，如果不指定该参数则默认使用&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​		Filter 类使用较少，可自行查阅</p>
<h3 id="logger-应用"><a href="#logger-应用" class="headerlink" title="logger 应用"></a>logger 应用</h3><p>​		1）将日志同时输出到控制台和文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()  <span class="comment">#初始化日志文件</span></span><br><span class="line"><span class="comment">#自定义格式</span></span><br><span class="line">fmt = <span class="string">&#x27;%(asctime)s %(levelname)s [%(name)s] [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&#x27;</span></span><br><span class="line">formatter = logging.Formatter(fmt) <span class="comment">#定义格式器</span></span><br><span class="line"></span><br><span class="line">sh = logging.StreamHandler() <span class="comment">#指定输出的handler，输出到控制台</span></span><br><span class="line">sh.setFormatter(formatter) <span class="comment">#将格式器加入到控制器中</span></span><br><span class="line">logger.addHandler(sh)  <span class="comment">#添加控制器</span></span><br><span class="line"></span><br><span class="line">fh = logging.FileHandler(<span class="string">&quot;./b.log&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment">#输出到文件的控制器,设置utf-8格式，中文不乱码</span></span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">logger.addHandler(fh)</span><br></pre></td></tr></table></figure>

<p>​		2）每日生成一个文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fh = logging.handlers.TimedRotatingFileHandler(filename, when=<span class="string">&#x27;h&#x27;</span>, interval=<span class="number">1</span>, backupCount=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#使用按找时间片分隔文件的控制器实现类</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">将日志信息记录到文件中，以特定的时间间隔切换日志文件。</span></span><br><span class="line"><span class="string">filename: 日志文件名</span></span><br><span class="line"><span class="string">when: 时间单位，可选参数</span></span><br><span class="line"><span class="string">	S - Seconds</span></span><br><span class="line"><span class="string">	M - Minutes</span></span><br><span class="line"><span class="string">	H - Hours</span></span><br><span class="line"><span class="string">	D - Days，按照日期</span></span><br><span class="line"><span class="string">	midnight - 每晚12点，天</span></span><br><span class="line"><span class="string">	W&#123;0-6&#125; -  0 - Monday，周几</span></span><br><span class="line"><span class="string">interval: 时间间隔，就代表几个when</span></span><br><span class="line"><span class="string">backupCount: 日志文件备份数量。如果backupCount大于0，那么当生成新的日志文件时，将只保留backupCount个文件，删除最老的文件。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.handlers <span class="comment">#使用高级的处理器必须导这个包，不然报错</span></span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line">logger.setLevel(logging.DEBUG)<span class="comment">#总的日志级别</span></span><br><span class="line"><span class="comment"># 日志格式</span></span><br><span class="line">fmt = <span class="string">&quot;%(asctime)s %(levelname)s [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&quot;</span></span><br><span class="line">formatter = logging.Formatter(fmt)</span><br><span class="line"><span class="comment"># 输出到文件，每日一个文件</span></span><br><span class="line">fh = logging.handlers.TimedRotatingFileHandler(<span class="string">&quot;./a.log&quot;</span>, when=<span class="string">&#x27;MIDNIGHT&#x27;</span>, interval=<span class="number">1</span>, backupCount=<span class="number">31</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="comment">#注意都设置utf-8格式</span></span><br><span class="line"><span class="comment">#每天分隔一个文件，保留31个</span></span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line">fh.setLevel(logging.INFO)<span class="comment">#可以文件中记录的日志级别</span></span><br><span class="line"><span class="comment">#控制器的级别应该大于等于日志器的级别，否则为日志器的级别</span></span><br><span class="line"><span class="comment">#日志器默认为warning</span></span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;我真帅&quot;</span>)</span><br><span class="line">logger.info(<span class="string">&quot;我真棒&quot;</span>)</span><br><span class="line"><span class="comment">#文件中只会存储我真棒</span></span><br></pre></td></tr></table></figure>

<p>​		3）单例模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.handlers <span class="comment">#使用高级的处理器必须导这个包，不然报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetLogger</span>:</span><br><span class="line">    logger=<span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLogger</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">if</span> cls.logger <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.logger = logging.getLogger()</span><br><span class="line">            cls.logger.setLevel(logging.DEBUG)</span><br><span class="line">			<span class="comment"># 日志格式</span></span><br><span class="line">            fmt = <span class="string">&quot;%(asctime)s %(levelname)s [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&quot;</span></span><br><span class="line">            formatter = logging.Formatter(fmt)</span><br><span class="line">   			 <span class="comment"># 输出到文件，每日一个文件</span></span><br><span class="line">            fh = logging.handlers.TimedRotatingFileHandler(<span class="string">&quot;./a.log&quot;</span>, when=<span class="string">&#x27;MIDNIGHT&#x27;</span>, interval=<span class="number">1</span>, backupCount=<span class="number">31</span>)   <span class="comment">#每天分隔一个文件，保留31个</span></span><br><span class="line">            fh.setFormatter(formatter)</span><br><span class="line">            fh.setLevel(logging.INFO)<span class="comment">#可以设置记录的日志级别</span></span><br><span class="line">            cls.logger.addHandler(fh)</span><br><span class="line">            sh = logging.StreamHandler() <span class="comment">#指定输出的handler，输出到控制台</span></span><br><span class="line">			sh.setFormatter(formatter) <span class="comment">#将格式器加入到控制器中</span></span><br><span class="line">			cls.logger.addHandler(sh)  <span class="comment">#添加控制器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls.logger</span><br><span class="line">    </span><br><span class="line"><span class="comment">#单例很重要，奥里给</span></span><br></pre></td></tr></table></figure>

<p>​		4）yml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">disable_existing_loggers:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">formatters:</span></span><br><span class="line">  <span class="attr">simpleFormatter:</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">&#x27;%(asctime)s %(levelname)s [%(filename)s(%(funcName)s:%(lineno)d)] - %(message)s&#x27;</span></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line">  <span class="attr">consoleHandler:</span></span><br><span class="line">    <span class="attr">class:</span> <span class="string">logging.StreamHandler</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">formatter:</span> <span class="string">simpleFormatter</span></span><br><span class="line">    <span class="attr">stream:</span> <span class="string">ext://sys.stdout</span></span><br><span class="line">  <span class="attr">fileHandler:</span></span><br><span class="line">    <span class="attr">class:</span> <span class="string">logging.handlers.RotatingFileHandler</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">formatter:</span> <span class="string">simpleFormatter</span></span><br><span class="line">    <span class="attr">filename:</span> <span class="string">sample.log</span></span><br><span class="line">    <span class="attr">maxBytes:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">backupCount:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">loggers:</span></span><br><span class="line">  <span class="attr">sampleLogger:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">handlers:</span> [<span class="string">fileHandler</span>, <span class="string">consoleHandler</span>]</span><br><span class="line">    <span class="attr">propagate:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">root:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">INFO</span></span><br><span class="line">  <span class="attr">handlers:</span> [<span class="string">consoleHandler</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./logconf/log.yaml&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    config = yaml.safe_load(f.read())</span><br><span class="line">    logging.config.dictConfig(config)</span><br><span class="line"></span><br><span class="line">logger_r = logging.getLogger()  <span class="comment">#使用root日志</span></span><br><span class="line">logger_s = logging.getLogger(<span class="string">&#x27;sampleLogger&#x27;</span>) <span class="comment">#使用指定的日志，sampleLogger</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>日志</tag>
        <tag>logger</tag>
      </tags>
  </entry>
</search>
